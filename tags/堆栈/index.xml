<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>堆栈 on LuyangのBlog</title>
    <link>/tags/%E5%A0%86%E6%A0%88/</link>
    <description>Recent content in 堆栈 on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 03 Jun 2025 00:00:00 +0800</lastBuildDate>
    <atom:link href="/tags/%E5%A0%86%E6%A0%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>可变长度数组（VLA）在C语言中的演进、争议与现代替代方案</title>
      <link>/posts/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84vla%E5%9C%A8c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%BC%94%E8%BF%9B%E4%BA%89%E8%AE%AE%E4%B8%8E%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 03 Jun 2025 00:00:00 +0800</pubDate>
      <guid>/posts/%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%95%B0%E7%BB%84vla%E5%9C%A8c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%BC%94%E8%BF%9B%E4%BA%89%E8%AE%AE%E4%B8%8E%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88/</guid>
      <description>&lt;h2 id=&#34;可变长度数组vla在c语言中的演进争议与现代替代方案&#34;&gt;可变长度数组（VLA）在C语言中的演进、争议与现代替代方案&lt;/h2&gt;&#xA;&lt;p&gt;​&lt;strong&gt;摘要&lt;/strong&gt;​：本文系统分析了C99标准引入的可变长度数组（Variable-Length Array, VLA）特性，从其技术原理、标准演进、性能特征和安全风险等维度展开深度探讨。结合ISO/IEC标准文档与核心编译器实现，本文揭示了VLA在栈内存动态分配机制上的根本局限，并通过实证分析验证了其在安全关键系统中的重大隐患。研究指出，现代C语言开发中应优先选择柔性数组成员（Flexible Array Member）和动态内存分配等替代方案，并给出了在限制性环境中处理动态数组的技术建议。&lt;/p&gt;&#xA;&lt;p&gt;​&lt;strong&gt;关键词&lt;/strong&gt;​：可变长度数组；C语言；栈溢出；内存安全；C99；C11；Flexible Array Member&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1-引言&#34;&gt;1. 引言&lt;/h3&gt;&#xA;&lt;p&gt;[[可变长度数组]]（Variable-Length Array, [[VLA]]）是 C99 标准（ISO/IEC 9899:1999）引入的革新特性，允许数组维度在运行时确定。其语法形式简洁：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;size_t&lt;/span&gt; n) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; arr[n];  &lt;span style=&#34;color:#75715e&#34;&gt;// VLA：长度为运行时变量n&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ... 数组操作&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该特性旨在提供优于&lt;code&gt;alloca()&lt;/code&gt;的标准化栈上动态内存分配方案[1]。然而，其实际应用引发了持续的技术争议。本文从工程实践角度分析VLA的设计哲学、实现机制及现实困境。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-vla的技术实现与内存模型&#34;&gt;2. VLA的技术实现与内存模型&lt;/h3&gt;&#xA;&lt;h4 id=&#34;21-栈内存动态分配原理&#34;&gt;2.1 栈内存动态分配原理&lt;/h4&gt;&#xA;&lt;p&gt;VLA的存储空间通过栈指针动态调整实现：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-assembly&#34; data-lang=&#34;assembly&#34;&gt;; x86-64 GCC 编译伪代码 (n = rdi)&#xA;process:&#xA;    sub rsp, rdi   ; 直接扩展栈空间为n字节&#xA;    mov rax, rsp    ; rax指向数组首地址&#xA;    ...             ; 数组操作&#xA;    add rsp, rdi   ; 栈指针恢复&#xA;    ret&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相较于静态数组，VLA消除了编译期尺寸固定的约束，但代价是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;​&lt;strong&gt;栈空间不确定性&lt;/strong&gt;​：引发栈溢出风险（Stack Overflow）&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;无错误恢复机制&lt;/strong&gt;​：分配失败时触发未定义行为（UB）[2]&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;释放不可控&lt;/strong&gt;​：仅在作用域结束时释放，无法手动管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;22-编译器兼容性现状&#34;&gt;2.2 编译器兼容性现状&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;​&lt;strong&gt;完整支持&lt;/strong&gt;​：[[GCC]], [[Clang]] (默认启用)&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;可选支持&lt;/strong&gt;​：C11起需&lt;code&gt;__STDC_NO_VLA__&lt;/code&gt;未定义[3]&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;明确禁用&lt;/strong&gt;​：[[MSVC]]始终拒绝支持（VS2019文档明确标注”不支持C99 VLA”）[4]&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-安全风险与性能缺陷的实证分析&#34;&gt;3. 安全风险与性能缺陷的实证分析&lt;/h3&gt;&#xA;&lt;h4 id=&#34;31-栈溢出漏洞测试&#34;&gt;3.1 栈溢出漏洞测试&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vuln&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;size_t&lt;/span&gt; n) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; vla[n];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;VLA at %p&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)vla);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;vuln&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;64&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 申请64MB栈空间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;strong&gt;执行结果&lt;/strong&gt;​：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pingpong on LuyangのBlog</title>
    <link>/tags/pingpong/</link>
    <description>Recent content in Pingpong on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 04 Jun 2025 02:30:00 +0800</lastBuildDate>
    <atom:link href="/tags/pingpong/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>📘 PingPong Buffer 设计文档</title>
      <link>/posts/-pingpong-buffer-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-pingpong-buffer-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</guid>
      <description>&lt;h1 id=&#34;-pingpong-buffer-设计文档&#34;&gt;📘 PingPong Buffer 设计文档&lt;/h1&gt;&#xA;&lt;h2 id=&#34;一设计目标&#34;&gt;一、设计目标&lt;/h2&gt;&#xA;&lt;p&gt;PingPongBuffer（双缓冲区）旨在解决生产者与消费者异步处理数据时的数据一致性与性能问题。适用于&lt;strong&gt;实时数据传输&lt;/strong&gt;、&lt;strong&gt;中断采集&lt;/strong&gt;、&lt;strong&gt;多线程通信&lt;/strong&gt;等场景，具备如下核心目标：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保证&lt;strong&gt;读写互不干扰&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;支持&lt;strong&gt;高吞吐、低延迟&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;能够应对&lt;strong&gt;速率不匹配&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;可维护、可调试、可扩展&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;二核心设计理念&#34;&gt;二、核心设计理念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-双缓冲结构&#34;&gt;2.1 双缓冲结构&lt;/h3&gt;&#xA;&lt;p&gt;使用两个固定大小的缓冲区 &lt;code&gt;buffer[0]&lt;/code&gt; 和 &lt;code&gt;buffer[1]&lt;/code&gt;，通过索引或标志位控制读写指向不同缓冲区。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Buffer Index&lt;/th&gt;&#xA;          &lt;th&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;write_idx&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;当前写入缓冲区索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;read_idx&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;当前读取缓冲区索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;通过原子操作（或锁）切换这两个缓冲区，实现无锁或低锁竞争的数据交替使用。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;22-原子切换机制&#34;&gt;2.2 原子切换机制&lt;/h3&gt;&#xA;&lt;p&gt;采用 &lt;code&gt;std::atomic&amp;lt;int&amp;gt;&lt;/code&gt; 索引变量配合 &lt;code&gt;memory_order_release/acquire&lt;/code&gt; 保证跨线程或中断的数据可见性与一致性。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;write_idx.store(new_index, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;memory_order_release);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;read_idx.store(old_write_index, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;memory_order_acquire);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h3 id=&#34;23-数据完整性控制&#34;&gt;2.3 数据完整性控制&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;BeginWrite/EndWrite&lt;/code&gt; 和 &lt;code&gt;BeginRead/EndRead&lt;/code&gt; 保障帧级数据完整性&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;frame_valid&lt;/code&gt; 标志位标识 buffer 是否写满可读&lt;/li&gt;&#xA;&lt;li&gt;支持 &lt;code&gt;frame_id&lt;/code&gt;、时间戳等附加信息追踪数据来源及一致性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;三异常与过载处理机制&#34;&gt;三、异常与过载处理机制&lt;/h2&gt;&#xA;&lt;h3 id=&#34;31-生产者快于消费者overrun&#34;&gt;3.1 生产者快于消费者（overrun）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当前写 buffer flip 后，若旧 buffer 尚未消费 → 记录覆盖行为&lt;/li&gt;&#xA;&lt;li&gt;引入 &lt;code&gt;overrun_counter&lt;/code&gt;，并提供异常提示接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;buffer_valid[read_idx]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    overrun_counter&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;32-异常帧检测&#34;&gt;3.2 异常帧检测&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;frame_id&lt;/code&gt; 不连续时提示丢帧&lt;/li&gt;&#xA;&lt;li&gt;时间戳差距过大可认为数据阻塞&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;四状态重置与配置变更&#34;&gt;四、状态重置与配置变更&lt;/h2&gt;&#xA;&lt;p&gt;支持 &lt;code&gt;reset()&lt;/code&gt; 操作，在底层硬件重配置（如分辨率、频率）或系统热切换场景中清空缓冲状态，防止旧数据干扰：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

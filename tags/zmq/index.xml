<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zmq on LuyangのBlog</title>
    <link>/tags/zmq/</link>
    <description>Recent content in Zmq on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 16 May 2023 20:19:08 +0800</lastBuildDate>
    <atom:link href="/tags/zmq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ZeroMQ REQ/RSP 模式与 `zmq_poll` 深度解析</title>
      <link>/posts/zeromq-req-rsp-%E6%A8%A1%E5%BC%8F%E4%B8%8E-zmq-poll-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 16 May 2023 20:19:08 +0800</pubDate>
      <guid>/posts/zeromq-req-rsp-%E6%A8%A1%E5%BC%8F%E4%B8%8E-zmq-poll-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;zeromq-reqrsp-模式与-zmq_poll-深度解析&#34;&gt;ZeroMQ REQ/RSP 模式与 &lt;code&gt;zmq_poll&lt;/code&gt; 深度解析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;&#xA;&lt;p&gt;本文档旨在深入探讨 ZeroMQ (简称 ZMQ) 中经典的 REQ/RSP（请求/响应）模式，特别是结合 &lt;code&gt;zmq_poll&lt;/code&gt; 使用时的机制、底层原理和最佳实践。我们将结合 ZMQ 的核心设计思想与源码结构，对 &lt;code&gt;poll&lt;/code&gt; 的工作方式进行详尽的分析，并提供生产级的标准 C++ 使用模板，以帮助开发者在实际项目中构建高效、稳定且具备高可用性的分布式应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-zeromq-reqrsp-模式简介&#34;&gt;1. ZeroMQ REQ/RSP 模式简介&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-模式定义&#34;&gt;1.1 模式定义&lt;/h3&gt;&#xA;&lt;p&gt;REQ/RSP 模式是 ZMQ 中最基础也最严格的通信模式之一。它构建了一个严格的、轮流进行的请求-响应工作流，在网络的两端形成一个&lt;strong&gt;分布式的有限状态机（Distributed Finite State Machine, FSM）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;REQ (Requester) Socket&lt;/strong&gt;: 扮演客户端的角色。其协议行为被严格规定：必须首先调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送一个请求，然后&lt;strong&gt;必须&lt;/strong&gt;调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 等待一个响应。在成功收到响应之前，任何再次发送的尝试都会立即失败并返回错误码 &lt;code&gt;EFSM&lt;/code&gt; (Error: Finite State Machine)，因为套接字正处于“等待响应”的状态。这种严格性保证了请求不会被无序发送。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RSP (Responder) Socket&lt;/strong&gt;: 扮演服务端的角色。其行为同样被严格规定：必须首先调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 等待一个请求，然后&lt;strong&gt;必须&lt;/strong&gt;调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送一个响应。在一个请求被响应之前，它不会接收新的请求。在一个响应发送后，它必须等待下一个新请求的到来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;真实世界类比&lt;/strong&gt;: 想象一下在银行柜台办理业务。顾客（REQ）必须先提交申请（&lt;code&gt;send&lt;/code&gt;），然后等待柜员办理完成并返回结果（&lt;code&gt;recv&lt;/code&gt;）。在等待期间，顾客不能提交第二个申请。同样，柜员（RSP）必须先接收一个申请（&lt;code&gt;recv&lt;/code&gt;），处理后返还结果（&lt;code&gt;send&lt;/code&gt;），然后才能服务下一位顾客。&lt;/p&gt;&#xA;&lt;p&gt;这种严格的“你问我答”模式是其最大的&lt;strong&gt;优点&lt;/strong&gt;也是&lt;strong&gt;缺点&lt;/strong&gt;。优点在于它极大地简化了简单RPC（远程过程调用）场景的编程模型，逻辑清晰。缺点在于其同步性和严格的锁定步骤，如果响应方出现故障或网络丢包，请求方会无限期地“卡”在等待状态，导致整个应用失去响应。这正是 &lt;code&gt;zmq_poll&lt;/code&gt; 机制存在的根本原因。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-底层状态机state-machine&#34;&gt;1.2 底层状态机（State Machine）&lt;/h3&gt;&#xA;&lt;p&gt;理解 REQ/RSP 的关键在于理解其背后的状态机。这个状态机不是在程序代码中显式定义的，而是由 ZMQ 在套接字内部强制执行的。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;REQ Socket 状态机&lt;/strong&gt;:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;send_ready&lt;/code&gt;: 初始状态，可以发送请求。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;send_request&lt;/code&gt;: 调用 &lt;code&gt;zmq_send()&lt;/code&gt; 后，内部状态切换至 &lt;code&gt;expect_reply&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;expect_reply&lt;/code&gt;: 等待接收响应。此时，再次调用 &lt;code&gt;zmq_send()&lt;/code&gt; 将立即失败，返回 &lt;code&gt;EFSM&lt;/code&gt;。这是为了防止客户端在未得到确认的情况下发出大量请求，从而压垮服务端。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_reply&lt;/code&gt;: 成功调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 接收到响应后，状态机自动回到 &lt;code&gt;send_ready&lt;/code&gt; 状态，可以发起下一次请求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RSP Socket 状态机&lt;/strong&gt;:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_ready&lt;/code&gt;: 初始状态，可以接收请求。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_request&lt;/code&gt;: 成功调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 接收到一个请求后，内部状态切换至 &lt;code&gt;send_reply&lt;/code&gt;。此时，再次调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 将会阻塞（如果配置为阻塞模式），因为它期望程序接下来发送一个响应。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;send_reply&lt;/code&gt;: 可以调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送响应。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;reply_sent&lt;/code&gt;: 发送响应后，状态机自动回到 &lt;code&gt;receive_ready&lt;/code&gt; 状态，准备处理来自&lt;strong&gt;任何&lt;/strong&gt;已连接客户端的下一个请求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;重要细节&lt;/strong&gt;: 当一个 RSP 套接字连接到多个 REQ 客户端时，它仍然是&lt;strong&gt;串行处理&lt;/strong&gt;。它从一个客户端接收请求，发送响应，然后才能从另一个（或同一个）客户端接收下一个请求。ZMQ 内部会自动处理来自不同客户端的请求排队。如果你需要并发处理请求，应当选择更高级的模式，如 DEALER/ROUTER。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

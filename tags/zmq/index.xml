<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zmq on LuyangのBlog</title>
    <link>/tags/zmq/</link>
    <description>Recent content in Zmq on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 08 Jul 2025 02:30:00 +0800</lastBuildDate>
    <atom:link href="/tags/zmq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>📘 深入理解 ZeroMQ 异步连接与 REQ 消息堆积行为</title>
      <link>/posts/-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-zeromq-%E5%BC%82%E6%AD%A5%E8%BF%9E%E6%8E%A5%E4%B8%8E-req-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E8%A1%8C%E4%B8%BA/</link>
      <pubDate>Tue, 08 Jul 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-zeromq-%E5%BC%82%E6%AD%A5%E8%BF%9E%E6%8E%A5%E4%B8%8E-req-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E8%A1%8C%E4%B8%BA/</guid>
      <description>&lt;h1 id=&#34;-深入理解-zeromq-异步连接与-req-消息堆积行为&#34;&gt;📘 深入理解 ZeroMQ 异步连接与 REQ 消息堆积行为&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-文档概览&#34;&gt;✨ 文档概览&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;章节&lt;/th&gt;&#xA;          &lt;th&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1. 简介&lt;/td&gt;&#xA;          &lt;td&gt;ZeroMQ &lt;code&gt;connect()&lt;/code&gt; 行为误区&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2. 异步连接机制&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;connect()&lt;/code&gt; 实现原理与延迟连接&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3. REQ socket 特性&lt;/td&gt;&#xA;          &lt;td&gt;REQ 的 FSM 状态机与堆积陷阱&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;4. 内存增长问题分析&lt;/td&gt;&#xA;          &lt;td&gt;实例重现与底层解释&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;5. 如何规避问题&lt;/td&gt;&#xA;          &lt;td&gt;参数设置、代码优化方案&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;6. 替代方案&lt;/td&gt;&#xA;          &lt;td&gt;使用 DEALER 替代 REQ 的可行性&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;7. 源码分析&lt;/td&gt;&#xA;          &lt;td&gt;ZeroMQ 源码路径与关键组件说明&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;8. 附录与参考资料&lt;/td&gt;&#xA;          &lt;td&gt;官方文献、工具、命令等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1--简介为什么连接成功了服务端却没起来&#34;&gt;1. 🔰 简介：为什么连接成功了服务端却没起来？&lt;/h2&gt;&#xA;&lt;p&gt;当你调用如下代码时：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;zmq&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;socket_t socket(context, zmq&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;socket_type&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;req);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;socket.connect(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tcp://127.0.0.1:5555&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LogInfo(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Socket connected to endpoint&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可能会误以为服务端已经在线并成功连接。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;这是一个常见误区。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;-正确理解&#34;&gt;✅ 正确理解：&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt; 只是将目标 endpoint 添加到内部连接目标列表中，并不会立即发起 TCP 连接或等待对端响应。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这是 ZeroMQ 异步非阻塞通信模型的特性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ZeroMQ REQ/RSP 模式与 `zmq_poll` 深度解析</title>
      <link>/posts/zeromq-req-rsp-%E6%A8%A1%E5%BC%8F%E4%B8%8E-zmq-poll-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 16 May 2023 20:19:08 +0800</pubDate>
      <guid>/posts/zeromq-req-rsp-%E6%A8%A1%E5%BC%8F%E4%B8%8E-zmq-poll-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;zeromq-reqrsp-模式与-zmq_poll-深度解析&#34;&gt;ZeroMQ REQ/RSP 模式与 &lt;code&gt;zmq_poll&lt;/code&gt; 深度解析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;&#xA;&lt;p&gt;本文档旨在深入探讨 ZeroMQ (简称 ZMQ) 中经典的 REQ/RSP（请求/响应）模式，特别是结合 &lt;code&gt;zmq_poll&lt;/code&gt; 使用时的机制、底层原理和最佳实践。我们将结合 ZMQ 的核心设计思想与源码结构，对 &lt;code&gt;poll&lt;/code&gt; 的工作方式进行详尽的分析，并提供生产级的标准 C++ 使用模板，以帮助开发者在实际项目中构建高效、稳定且具备高可用性的分布式应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-zeromq-reqrsp-模式简介&#34;&gt;1. ZeroMQ REQ/RSP 模式简介&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-模式定义&#34;&gt;1.1 模式定义&lt;/h3&gt;&#xA;&lt;p&gt;REQ/RSP 模式是 ZMQ 中最基础也最严格的通信模式之一。它构建了一个严格的、轮流进行的请求-响应工作流，在网络的两端形成一个&lt;strong&gt;分布式的有限状态机（Distributed Finite State Machine, FSM）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;REQ (Requester) Socket&lt;/strong&gt;: 扮演客户端的角色。其协议行为被严格规定：必须首先调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送一个请求，然后&lt;strong&gt;必须&lt;/strong&gt;调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 等待一个响应。在成功收到响应之前，任何再次发送的尝试都会立即失败并返回错误码 &lt;code&gt;EFSM&lt;/code&gt; (Error: Finite State Machine)，因为套接字正处于“等待响应”的状态。这种严格性保证了请求不会被无序发送。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RSP (Responder) Socket&lt;/strong&gt;: 扮演服务端的角色。其行为同样被严格规定：必须首先调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 等待一个请求，然后&lt;strong&gt;必须&lt;/strong&gt;调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送一个响应。在一个请求被响应之前，它不会接收新的请求。在一个响应发送后，它必须等待下一个新请求的到来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;真实世界类比&lt;/strong&gt;: 想象一下在银行柜台办理业务。顾客（REQ）必须先提交申请（&lt;code&gt;send&lt;/code&gt;），然后等待柜员办理完成并返回结果（&lt;code&gt;recv&lt;/code&gt;）。在等待期间，顾客不能提交第二个申请。同样，柜员（RSP）必须先接收一个申请（&lt;code&gt;recv&lt;/code&gt;），处理后返还结果（&lt;code&gt;send&lt;/code&gt;），然后才能服务下一位顾客。&lt;/p&gt;&#xA;&lt;p&gt;这种严格的“你问我答”模式是其最大的&lt;strong&gt;优点&lt;/strong&gt;也是&lt;strong&gt;缺点&lt;/strong&gt;。优点在于它极大地简化了简单RPC（远程过程调用）场景的编程模型，逻辑清晰。缺点在于其同步性和严格的锁定步骤，如果响应方出现故障或网络丢包，请求方会无限期地“卡”在等待状态，导致整个应用失去响应。这正是 &lt;code&gt;zmq_poll&lt;/code&gt; 机制存在的根本原因。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-底层状态机state-machine&#34;&gt;1.2 底层状态机（State Machine）&lt;/h3&gt;&#xA;&lt;p&gt;理解 REQ/RSP 的关键在于理解其背后的状态机。这个状态机不是在程序代码中显式定义的，而是由 ZMQ 在套接字内部强制执行的。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;REQ Socket 状态机&lt;/strong&gt;:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;send_ready&lt;/code&gt;: 初始状态，可以发送请求。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;send_request&lt;/code&gt;: 调用 &lt;code&gt;zmq_send()&lt;/code&gt; 后，内部状态切换至 &lt;code&gt;expect_reply&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;expect_reply&lt;/code&gt;: 等待接收响应。此时，再次调用 &lt;code&gt;zmq_send()&lt;/code&gt; 将立即失败，返回 &lt;code&gt;EFSM&lt;/code&gt;。这是为了防止客户端在未得到确认的情况下发出大量请求，从而压垮服务端。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_reply&lt;/code&gt;: 成功调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 接收到响应后，状态机自动回到 &lt;code&gt;send_ready&lt;/code&gt; 状态，可以发起下一次请求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RSP Socket 状态机&lt;/strong&gt;:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_ready&lt;/code&gt;: 初始状态，可以接收请求。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_request&lt;/code&gt;: 成功调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 接收到一个请求后，内部状态切换至 &lt;code&gt;send_reply&lt;/code&gt;。此时，再次调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 将会阻塞（如果配置为阻塞模式），因为它期望程序接下来发送一个响应。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;send_reply&lt;/code&gt;: 可以调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送响应。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;reply_sent&lt;/code&gt;: 发送响应后，状态机自动回到 &lt;code&gt;receive_ready&lt;/code&gt; 状态，准备处理来自&lt;strong&gt;任何&lt;/strong&gt;已连接客户端的下一个请求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;重要细节&lt;/strong&gt;: 当一个 RSP 套接字连接到多个 REQ 客户端时，它仍然是&lt;strong&gt;串行处理&lt;/strong&gt;。它从一个客户端接收请求，发送响应，然后才能从另一个（或同一个）客户端接收下一个请求。ZMQ 内部会自动处理来自不同客户端的请求排队。如果你需要并发处理请求，应当选择更高级的模式，如 DEALER/ROUTER。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

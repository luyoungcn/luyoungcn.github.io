<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编译器 on LuyangのBlog</title>
    <link>https://luyoungcn.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/</link>
    <description>Recent content in 编译器 on LuyangのBlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0800</lastBuildDate><atom:link href="https://luyoungcn.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>交叉编译工具链</title>
      <link>https://luyoungcn.github.io/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      
      <guid>https://luyoungcn.github.io/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/</guid>
      <description>&lt;p&gt;交叉编译工具链是一个由编译器、连接器和解释器组成的综合开发环境，交叉编译工具链主要由binutils、gcc和glibc三个部分组成。&lt;/p&gt;
&lt;p&gt;有时出于减小 libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、dietlibc 和 newlib。&lt;/p&gt;
&lt;p&gt;从授权上，分为免费授权版和付费授权版。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;免费版目前有三大主流工具商提供&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一是GNU（提供源码，自行编译制作）&lt;/li&gt;
&lt;li&gt;第二是 Codesourcery&lt;/li&gt;
&lt;li&gt;第三是Linora&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;收费版&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ARM原厂提供的armcc&lt;/li&gt;
&lt;li&gt;IAR提供的编译器&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arm-none-linux-gnueabi-gcc&lt;/code&gt;：是 &lt;code&gt;Codesourcery&lt;/code&gt; 公司（目前已经被Mentor收购）基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARM（32位）系统中所有环节的代码，包括裸机程序、u-boot、Linux kernel、filesystem和App应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arm-linux-gnueabihf-gcc&lt;/code&gt;：是由 &lt;code&gt;Linaro&lt;/code&gt; 公司基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARM（32位）系统中所有环节的代码，包括裸机程序、u-boot、Linux kernel、filesystem和App应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;aarch64-linux-gnu-gcc&lt;/code&gt;：是由 &lt;code&gt;Linaro&lt;/code&gt; 公司基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARMv8 64位目标中的裸机程序、u-boot、Linux kernel、filesystem和App应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arm-none-elf-gcc&lt;/code&gt;：是 &lt;code&gt;Codesourcery&lt;/code&gt; 公司（目前已经被Mentor收购）基于GCC推出的的ARM交叉编译工具。可用于交叉编译ARM MCU（32位）芯片，如ARM7、ARM9、Cortex-M/R芯片程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arm-none-eabi-gcc&lt;/code&gt;：是 GNU 推出的的ARM交叉编译工具。可用于交叉编译ARM MCU（32位）芯片，如ARM7、ARM9、Cortex-M/R芯片程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交叉编译工具链的命名规则为：&lt;code&gt;arch [-vendor] [-os] [-(gnu)eabi]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arch – 体系架构，如ARM，MIPS（通过交叉编译工具生成的可执行文件或系统镜像的运行平台或环境）&lt;/li&gt;
&lt;li&gt;vendor – 工具链提供商&lt;/li&gt;
&lt;li&gt;os – 目标操作系统（host主要操作平台，也就是编译时的系统）&lt;/li&gt;
&lt;li&gt;eabi – 嵌入式应用二进制接口（Embedded Application Binary Interface）根据对操作系统的支持与否，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arm-none-eabi：这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork(2)。他使用的是newlib这个专用于嵌入式系统的C库。&lt;/li&gt;
&lt;li&gt;arm-none-linux-eabi：用于Linux的，使用Glibc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;p&gt;1、arm-none-eabi-gcc（ARM architecture，no vendor，not target an operating system，complies with the ARM EABI）
用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application），一般适合 ARM7、Cortex-M 和 Cortex-R 内核的芯片使用，所以不支持那些跟操作系统关系密切的函数，比如fork(2)，他使用的是 newlib 这个专用于嵌入式系统的C库。&lt;/p&gt;
&lt;p&gt;2、arm-none-linux-gnueabi-gcc
(ARM architecture, no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI)
主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。arm-none-linux-gnueabi基于GCC，使用Glibc库，经过 Codesourcery 公司优化过推出的编译器。arm-none-linux-gnueabi-xxx 交叉编译工具的浮点运算非常优秀。一般ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。&lt;/p&gt;
&lt;p&gt;3、arm-eabi-gcc
Android ARM 编译器。&lt;/p&gt;
&lt;p&gt;4、armcc
ARM 公司推出的编译工具，功能和 arm-none-eabi 类似，可以编译裸机程序（u-boot、kernel），但是不能编译 Linux 应用程序。armcc一般和ARM开发工具一起，Keil MDK、ADS、RVDS和DS-5中的编译器都是armcc，所以 armcc 编译器都是收费的（爱国版除外，呵呵~~）。&lt;/p&gt;
&lt;p&gt;5、arm-none-uclinuxeabi-gcc 和 arm-none-symbianelf-gcc
arm-none-uclinuxeabi 用于uCLinux，使用Glibc。
arm-none-symbianelf 用于symbian，没用过，不知道C库是什么 。&lt;/p&gt;
&lt;p&gt;ABI 和 EABIABI&lt;/p&gt;
&lt;p&gt;二进制应用程序接口(Application Binary Interface (ABI) for the ARM Architecture)。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。
EABI：嵌入式ABI。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。
两者主要区别是，ABI是计算机上的，EABI是嵌入式平台上（如ARM，MIPS等）。arm-linux-gnueabi-gcc 和 arm-linux-gnueabihf-gcc
两个交叉编译器分别适用于 armel 和 armhf 两个不同的架构，armel 和 armhf 这两种架构在对待浮点运算采取了不同的策略（有 fpu 的 arm 才能支持这两种浮点运算策略）。
其实这两个交叉编译器只不过是 gcc 的选项 -mfloat-abi 的默认值不同。gcc 的选项 -mfloat-abi 有三种值 soft、softfp、hard（其中后两者都要求 arm 里有 fpu 浮点运算单元，soft 与后两者是兼容的，但 softfp 和 hard 两种模式互不兼容）：
soft： 不用fpu进行浮点计算，即使有fpu浮点运算单元也不用，而是使用软件模式。
softfp： armel架构（对应的编译器为 arm-linux-gnueabi-gcc ）采用的默认值，用fpu计算，但是传参数用普通寄存器传，这样中断的时候，只需要保存普通寄存器，中断负荷小，但是参数需要转换成浮点的再计算。
hard： armhf架构（对应的编译器 arm-linux-gnueabihf-gcc ）采用的默认值，用fpu计算，传参数也用fpu中的浮点寄存器传，省去了转换，性能最好，但是中断负荷高。
把以下测试使用的C文件内容保存成 mfloat.c：
#include &amp;lt;stdio.h&amp;gt;
int main(void)
{
double a,b,c;
a = 23.543;
b = 323.234;
c = b/a;
printf(“the 13/2 = %f\n”, c);
printf(“hello world !\n”);
return 0;
}
1、使用 arm-linux-gnueabihf-gcc 编译，使用“-v”选项以获取更详细的信息：&lt;/p&gt;
&lt;h1 id=&#34;arm-linux-gnueabihf-gcc--v-mfloatc&#34;&gt;arm-linux-gnueabihf-gcc -v mfloat.c&lt;/h1&gt;
&lt;p&gt;COLLECT_GCC_OPTIONS=’-v’ ‘-march=armv7-a’ ‘-mfloat-abi=hard’ ‘-mfpu=vfpv3-d16′ ‘-mthumb’
-mfloat-abi=hard
可看出使用hard硬件浮点模式。
2、使用 arm-linux-gnueabi-gcc 编译：&lt;/p&gt;
&lt;h1 id=&#34;arm-linux-gnueabi-gcc--v-mfloatc&#34;&gt;arm-linux-gnueabi-gcc -v mfloat.c&lt;/h1&gt;
&lt;p&gt;COLLECT_GCC_OPTIONS=’-v’ ‘-march=armv7-a’ ‘-mfloat-abi=softfp’ ‘-mfpu=vfpv3-d16′ ‘-mthumb’
-mfloat-abi=softfp
可看出使用softfp模式。&lt;/p&gt;
&lt;p&gt;参考资料&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;交叉编译器 arm-linux-gnueabi 和 arm-linux-gnueabihf 的区别：http://www.cnblogs.com/xiaotlili/p/3306100.html&lt;/li&gt;
&lt;li&gt;arm-none-linux-gnueabi，arm-none-eabi 与arm-eabi 区别：http://blog.csdn.net/mantis_1984/article/details/21049273&lt;/li&gt;
&lt;li&gt;What’s the difference between arm-linux- / arm-none-linux-gnueabi- / arm-fsl-linux-gnueabi- in LTIB?https://community.freescale.com/thread/313490&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://elinux.org/RPi_Kernel_Compilation&#34;&gt;http://elinux.org/RPi_Kernel_Compilation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/raspberrypi/linux&#34;&gt;https://github.com/raspberrypi/linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://packages.ubuntu.com/precise/gcc-arm-linux-gnueabi&#34;&gt;http://packages.ubuntu.com/precise/gcc-arm-linux-gnueabi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mitchtech.net/raspberry-pi-kernel-compile/&#34;&gt;http://mitchtech.net/raspberry-pi-kernel-compile/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>

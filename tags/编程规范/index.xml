<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程规范 on LuyangのBlog</title>
    <link>/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</link>
    <description>Recent content in 编程规范 on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 18 Dec 2024 10:00:00 +0800</lastBuildDate>
    <atom:link href="/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C C&#43;&#43; 跨语言兼容的完整逻辑</title>
      <link>/posts/c-c&#43;&#43;-%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%85%BC%E5%AE%B9%E7%9A%84%E5%AE%8C%E6%95%B4%E9%80%BB%E8%BE%91/</link>
      <pubDate>Wed, 18 Dec 2024 10:00:00 +0800</pubDate>
      <guid>/posts/c-c&#43;&#43;-%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%85%BC%E5%AE%B9%E7%9A%84%E5%AE%8C%E6%95%B4%E9%80%BB%E8%BE%91/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://images.unsplash.com/photo-1580927752452-89d86da3fa0a?q=80&amp;amp;w=1000&amp;amp;auto=format&amp;amp;fit=crop&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;引言跨语言调用的隐形陷阱&#34;&gt;引言：跨语言调用的&amp;quot;隐形陷阱&amp;quot;&lt;/h2&gt;&#xA;&lt;p&gt;如果你曾在C++项目中调用过C语言编写的库，大概率遇到过这样的链接错误：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;undefined reference to &lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;foo&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;int&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;明明头文件包含了，函数也实现了，为何编译器找不到符号？这背后的罪魁祸首，正是C++的&lt;strong&gt;名字修饰（Name Mangling）&lt;/strong&gt; 机制——C和C++编译器对函数符号的编码规则截然不同，导致跨语言调用时出现&amp;quot;声明与实现对不上号&amp;quot;的尴尬局面。&lt;/p&gt;&#xA;&lt;p&gt;而&lt;code&gt;__BEGIN_DECLS&lt;/code&gt;与&lt;code&gt;__END_DECLS&lt;/code&gt;这对宏，正是解决该问题的&amp;quot;黄金搭档&amp;quot;。它们看似简单，却蕴含着C/C++混合编程的核心设计思想。本文将从&lt;strong&gt;头文件设计、源文件实现、软件风格规范&lt;/strong&gt;三个维度，带你全方位吃透这对宏的使用逻辑与最佳实践。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;一跨语言兼容的核心矛盾名字修饰的坑&#34;&gt;一、跨语言兼容的核心矛盾：名字修饰的坑&lt;/h2&gt;&#xA;&lt;p&gt;要理解&lt;code&gt;__BEGIN_DECLS&lt;/code&gt;的价值，首先要搞懂C和C++在编译链接阶段的本质差异：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-符号编码规则差异&#34;&gt;1. 符号编码规则差异&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;C编译器&lt;/strong&gt;（如GCC）：函数名直接作为链接符号，不携带参数类型信息。例如&lt;code&gt;void foo(int)&lt;/code&gt;编译后符号为&lt;code&gt;_foo&lt;/code&gt;（不同编译器前缀可能不同，但无额外类型编码）；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;C++编译器&lt;/strong&gt;（如G++）：为支持函数重载和模板，会将函数名+参数类型编码为复杂符号。例如&lt;code&gt;void foo(int)&lt;/code&gt;编译后符号为&lt;code&gt;_Z3fooi&lt;/code&gt;（&lt;code&gt;Z&lt;/code&gt;表示编码开始，&lt;code&gt;3&lt;/code&gt;表示函数名长度，&lt;code&gt;foo&lt;/code&gt;是函数名，&lt;code&gt;i&lt;/code&gt;表示int类型）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-跨语言调用的致命问题&#34;&gt;2. 跨语言调用的致命问题&lt;/h3&gt;&#xA;&lt;p&gt;当C++代码调用C语言实现的函数时：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;C++编译器按自己的规则修饰函数名（如&lt;code&gt;_Z3fooi&lt;/code&gt;）；&lt;/li&gt;&#xA;&lt;li&gt;C语言编译的库中，函数符号是原始形态（如&lt;code&gt;_foo&lt;/code&gt;）；&lt;/li&gt;&#xA;&lt;li&gt;链接器找不到匹配的符号，直接报错&amp;quot;未定义引用&amp;quot;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;而C++提供的&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;语法，正是用来解决这个问题——它告诉C++编译器：&amp;quot;{}内的代码按C语言规则编译，不要进行名字修饰&amp;quot;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;3-__begin_decls的本质宏封装的兼容性桥梁&#34;&gt;3. &lt;code&gt;__BEGIN_DECLS&lt;/code&gt;的本质：宏封装的&amp;quot;兼容性桥梁&amp;quot;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;__BEGIN_DECLS&lt;/code&gt;与&lt;code&gt;__END_DECLS&lt;/code&gt;本质上是对&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;的封装，核心目标是：&lt;strong&gt;让同一份声明在C和C++环境下均合法，且编译链接行为一致&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;其原始定义（来自&lt;code&gt;sys/cdefs.h&lt;/code&gt;）如下，逻辑非常简洁：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#ifdef&#x9;__cplusplus&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# define __BEGIN_DECLS&#x9;extern &amp;#34;C&amp;#34; {  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C++环境：开启C规则&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# define __END_DECLS&#x9;}             &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C++环境：关闭C规则&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#else&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# define __BEGIN_DECLS              &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C环境：空宏（无意义）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# define __END_DECLS                &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C环境：空宏（无意义）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#endif&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;二头文件维度接口契约的兼容设计&#34;&gt;二、头文件维度：接口契约的兼容设计&lt;/h2&gt;&#xA;&lt;p&gt;头文件（&lt;code&gt;.h/.hpp&lt;/code&gt;）是跨语言调用的&amp;quot;接口契约&amp;quot;，&lt;code&gt;__BEGIN_DECLS&lt;/code&gt;的核心应用场景也在这里。一份合格的跨语言头文件，必须满足&amp;quot;C编译器能过，C++编译器也能过&amp;quot;的基本要求。&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-头文件使用规范三大核心原则&#34;&gt;1. 头文件使用规范：三大核心原则&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1宏的引入与位置&#34;&gt;（1）宏的引入与位置&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;必须将&lt;code&gt;__BEGIN_DECLS&lt;/code&gt;定义在&lt;strong&gt;公共基础头文件&lt;/strong&gt;（如&lt;code&gt;sys/cdefs.h&lt;/code&gt;或项目自定义的&lt;code&gt;common/cdefs.h&lt;/code&gt;）中，避免在多个头文件重复定义；&lt;/li&gt;&#xA;&lt;li&gt;宏调用必须放在&lt;strong&gt;头文件保护宏内部&lt;/strong&gt;，防止重复包含导致&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt;嵌套（C++编译器不允许重复包裹）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;✅ 正确示例：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

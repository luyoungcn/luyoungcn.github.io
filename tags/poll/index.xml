<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Poll on LuyangのBlog</title>
    <link>/tags/poll/</link>
    <description>Recent content in Poll on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 16 May 2023 20:19:08 +0800</lastBuildDate>
    <atom:link href="/tags/poll/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ZeroMQ REQ/RSP 模式与 `zmq_poll` 深度解析</title>
      <link>/posts/zeromq-req-rsp-%E6%A8%A1%E5%BC%8F%E4%B8%8E-zmq-poll-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 16 May 2023 20:19:08 +0800</pubDate>
      <guid>/posts/zeromq-req-rsp-%E6%A8%A1%E5%BC%8F%E4%B8%8E-zmq-poll-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;zeromq-reqrsp-模式与-zmq_poll-深度解析&#34;&gt;ZeroMQ REQ/RSP 模式与 &lt;code&gt;zmq_poll&lt;/code&gt; 深度解析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;&#xA;&lt;p&gt;本文档旨在深入探讨 ZeroMQ (简称 ZMQ) 中经典的 REQ/RSP（请求/响应）模式，特别是结合 &lt;code&gt;zmq_poll&lt;/code&gt; 使用时的机制、底层原理和最佳实践。我们将结合 ZMQ 的核心设计思想与源码结构，对 &lt;code&gt;poll&lt;/code&gt; 的工作方式进行详尽的分析，并提供生产级的标准 C++ 使用模板，以帮助开发者在实际项目中构建高效、稳定且具备高可用性的分布式应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-zeromq-reqrsp-模式简介&#34;&gt;1. ZeroMQ REQ/RSP 模式简介&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-模式定义&#34;&gt;1.1 模式定义&lt;/h3&gt;&#xA;&lt;p&gt;REQ/RSP 模式是 ZMQ 中最基础也最严格的通信模式之一。它构建了一个严格的、轮流进行的请求-响应工作流，在网络的两端形成一个&lt;strong&gt;分布式的有限状态机（Distributed Finite State Machine, FSM）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;REQ (Requester) Socket&lt;/strong&gt;: 扮演客户端的角色。其协议行为被严格规定：必须首先调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送一个请求，然后&lt;strong&gt;必须&lt;/strong&gt;调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 等待一个响应。在成功收到响应之前，任何再次发送的尝试都会立即失败并返回错误码 &lt;code&gt;EFSM&lt;/code&gt; (Error: Finite State Machine)，因为套接字正处于“等待响应”的状态。这种严格性保证了请求不会被无序发送。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RSP (Responder) Socket&lt;/strong&gt;: 扮演服务端的角色。其行为同样被严格规定：必须首先调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 等待一个请求，然后&lt;strong&gt;必须&lt;/strong&gt;调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送一个响应。在一个请求被响应之前，它不会接收新的请求。在一个响应发送后，它必须等待下一个新请求的到来。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;真实世界类比&lt;/strong&gt;: 想象一下在银行柜台办理业务。顾客（REQ）必须先提交申请（&lt;code&gt;send&lt;/code&gt;），然后等待柜员办理完成并返回结果（&lt;code&gt;recv&lt;/code&gt;）。在等待期间，顾客不能提交第二个申请。同样，柜员（RSP）必须先接收一个申请（&lt;code&gt;recv&lt;/code&gt;），处理后返还结果（&lt;code&gt;send&lt;/code&gt;），然后才能服务下一位顾客。&lt;/p&gt;&#xA;&lt;p&gt;这种严格的“你问我答”模式是其最大的&lt;strong&gt;优点&lt;/strong&gt;也是&lt;strong&gt;缺点&lt;/strong&gt;。优点在于它极大地简化了简单RPC（远程过程调用）场景的编程模型，逻辑清晰。缺点在于其同步性和严格的锁定步骤，如果响应方出现故障或网络丢包，请求方会无限期地“卡”在等待状态，导致整个应用失去响应。这正是 &lt;code&gt;zmq_poll&lt;/code&gt; 机制存在的根本原因。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-底层状态机state-machine&#34;&gt;1.2 底层状态机（State Machine）&lt;/h3&gt;&#xA;&lt;p&gt;理解 REQ/RSP 的关键在于理解其背后的状态机。这个状态机不是在程序代码中显式定义的，而是由 ZMQ 在套接字内部强制执行的。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;REQ Socket 状态机&lt;/strong&gt;:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;send_ready&lt;/code&gt;: 初始状态，可以发送请求。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;send_request&lt;/code&gt;: 调用 &lt;code&gt;zmq_send()&lt;/code&gt; 后，内部状态切换至 &lt;code&gt;expect_reply&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;expect_reply&lt;/code&gt;: 等待接收响应。此时，再次调用 &lt;code&gt;zmq_send()&lt;/code&gt; 将立即失败，返回 &lt;code&gt;EFSM&lt;/code&gt;。这是为了防止客户端在未得到确认的情况下发出大量请求，从而压垮服务端。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_reply&lt;/code&gt;: 成功调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 接收到响应后，状态机自动回到 &lt;code&gt;send_ready&lt;/code&gt; 状态，可以发起下一次请求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RSP Socket 状态机&lt;/strong&gt;:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_ready&lt;/code&gt;: 初始状态，可以接收请求。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;receive_request&lt;/code&gt;: 成功调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 接收到一个请求后，内部状态切换至 &lt;code&gt;send_reply&lt;/code&gt;。此时，再次调用 &lt;code&gt;zmq_recv()&lt;/code&gt; 将会阻塞（如果配置为阻塞模式），因为它期望程序接下来发送一个响应。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;send_reply&lt;/code&gt;: 可以调用 &lt;code&gt;zmq_send()&lt;/code&gt; 发送响应。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;reply_sent&lt;/code&gt;: 发送响应后，状态机自动回到 &lt;code&gt;receive_ready&lt;/code&gt; 状态，准备处理来自&lt;strong&gt;任何&lt;/strong&gt;已连接客户端的下一个请求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;重要细节&lt;/strong&gt;: 当一个 RSP 套接字连接到多个 REQ 客户端时，它仍然是&lt;strong&gt;串行处理&lt;/strong&gt;。它从一个客户端接收请求，发送响应，然后才能从另一个（或同一个）客户端接收下一个请求。ZMQ 内部会自动处理来自不同客户端的请求排队。如果你需要并发处理请求，应当选择更高级的模式，如 DEALER/ROUTER。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何在 Linux 用户空间中进行类似 GPIO 中断的处理</title>
      <link>/posts/how_to_handle_gpio_interrupt_like_handling_in_linux_userspace/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      <guid>/posts/how_to_handle_gpio_interrupt_like_handling_in_linux_userspace/</guid>
      <description>&lt;h1 id=&#34;how-to-handle-gpio-interrupt-like-handling-in-linux-userspace&#34;&gt;How to handle GPIO interrupt-like handling in Linux userspace&lt;/h1&gt;&#xA;&lt;h2 id=&#34;文件节点&#34;&gt;文件节点&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/sys/class/gpio/gpio666# ls&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;active_low  device  direction  edge  subsystem  uevent  value&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只用对应 GPIO 有 irq 功能时才会有 edge 文件。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;/sys/class/gpio/export：是一个只写文件，用于导出需要使用的 GPIO 引脚&lt;/li&gt;&#xA;&lt;li&gt;/sys/class/gpio/gpiox/: 是一个文件夹，在引脚导出后自动在 / sys/class/gpio / 目录下生成的&lt;/li&gt;&#xA;&lt;li&gt;/sys/class/gpio/gpiox/active_low：是一个文件，用来控制电平的极性（写 1 是高电平还是写 0 是高电平），默认写 1 是高电平，这个文件不用去管它&lt;/li&gt;&#xA;&lt;li&gt;/sys/class/gpio/gpiox/direction：是一个文件，用来控制 GPIO 是输入还是输出，往direction写 out 就是输出引脚，往direction写 in 就是输入引脚&lt;/li&gt;&#xA;&lt;li&gt;/sys/class/gpio/gpiox/edge：是一个文件，在输入模式下，写 edge 文件，配置 gpio 为外部中断引脚&lt;/li&gt;&#xA;&lt;li&gt;非中断引脚： none&lt;/li&gt;&#xA;&lt;li&gt;上升沿触发： rising&lt;/li&gt;&#xA;&lt;li&gt;下降沿触发： falling&lt;/li&gt;&#xA;&lt;li&gt;边沿触发： both&lt;/li&gt;&#xA;&lt;li&gt;/sys/class/gpio/gpiox/value: 是一个文件，在输出模式下，写该文件表示 gpio 输出；在输入模式下读该文件表示输入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/gpio/sysfs.txt&#34;&gt;sysfs.txt&lt;/a&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;#34;value&amp;#34; ... reads as either 0 (low) or 1 (high). If the GPIO&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  is configured as an output, this value may be written;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  any nonzero value is treated as high.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  If the pin can be configured as interrupt-generating interrupt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  and if it has been configured to generate interrupts (see the&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  description of &amp;#34;edge&amp;#34;), you can poll(2) on that file and&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  poll(2) will return whenever the interrupt was triggered. If&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  you use poll(2), set the events POLLPRI and POLLERR. If you&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  use select(2), set the file descriptor in exceptfds. After&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  poll(2) returns, either lseek(2) to the beginning of the sysfs&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  file and read the new value or close the file and re-open it&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  to read the value.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;#34;edge&amp;#34; ... reads as either &amp;#34;none&amp;#34;, &amp;#34;rising&amp;#34;, &amp;#34;falling&amp;#34;, or&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;both&amp;#34;. Write these strings to select the signal edge(s)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  that will make poll(2) on the &amp;#34;value&amp;#34; file return.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  This file exists only if the pin can be configured as an&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  interrupt generating input pin.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;demo&#34;&gt;demo&lt;/h2&gt;&#xA;&lt;p&gt;一坨屎样代码&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

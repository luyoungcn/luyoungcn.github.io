<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cpp on LuyangのBlog</title>
    <link>/tags/cpp/</link>
    <description>Recent content in Cpp on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Fri, 06 Jun 2025 02:30:00 +0800</lastBuildDate>
    <atom:link href="/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>📌深入 C&#43;&#43; 单例模式：原理、实现方式对比与 shared_ptr 架构设计</title>
      <link>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8E-shared_ptr-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 06 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8E-shared_ptr-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h1 id=&#34;深入-c-单例模式原理实现方式对比与-shared_ptr-架构设计&#34;&gt;📌深入 C++ 单例模式：原理、实现方式对比与 shared_ptr 架构设计&lt;/h1&gt;&#xA;&lt;h2 id=&#34;1-什么是单例基本语义与使用场景&#34;&gt;1️⃣ 什么是单例？基本语义与使用场景&lt;/h2&gt;&#xA;&lt;p&gt;单例（[[Singleton]]）是对象创建模式中最常见的一种，其目标是确保类在系统中&lt;strong&gt;只有一个实例&lt;/strong&gt;，并提供全局访问入口。&lt;/p&gt;&#xA;&lt;h3 id=&#34;-常见使用场景&#34;&gt;✅ 常见使用场景：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;配置中心（ConfigManager）&lt;/li&gt;&#xA;&lt;li&gt;日志系统（Logger）&lt;/li&gt;&#xA;&lt;li&gt;资源池（如内存池、线程池）&lt;/li&gt;&#xA;&lt;li&gt;调度器、会话管理器&lt;/li&gt;&#xA;&lt;li&gt;框架注册表、插件系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-单例的五种常见实现方式&#34;&gt;2️⃣ 单例的五种常见实现方式&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;推荐使用方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;懒汉式 + 线程安全（C++11 标准）局部静态变量（Meyers Singleton）&amp;mdash; 【推荐使用】&lt;/li&gt;&#xA;&lt;li&gt;shared_ptr 单例（更灵活）&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;1-饿汉式单例early-instantiation&#34;&gt;🍃1. 饿汉式单例（Early Instantiation）&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; instance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Singleton Singleton&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 简单易懂，线程安全（由 C++ 静态对象初始化保障）&lt;/li&gt;&#xA;&lt;li&gt;❌ 资源可能浪费，程序启动就构造实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-懒汉式lazy-initialization-非线程安全&#34;&gt;🍃2. 懒汉式（Lazy Initialization）+ 非线程安全&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;instance_)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            instance_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; instance_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;instance_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 仅在需要时创建实例&lt;/li&gt;&#xA;&lt;li&gt;❌ 非线程安全，多个线程可能同时构造多个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-懒汉式--线程安全c11-标准局部静态变量meyers-singleton-推荐使用&#34;&gt;🍃3. 懒汉式 + 线程安全（C++11 标准）局部静态变量（Meyers Singleton）&amp;mdash; 【推荐使用】&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; instance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton inst;  &lt;span style=&#34;color:#75715e&#34;&gt;// C++11 保证线程安全&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 推荐使用：线程安全、懒加载、无锁开销&lt;/li&gt;&#xA;&lt;li&gt;✅ 析构自动管理，依赖 C++ 静态局部变量特性&lt;/li&gt;&#xA;&lt;li&gt;❗ 禁止拷贝构造、赋值运算，防止实例复制&lt;/li&gt;&#xA;&lt;li&gt;✅ 最简洁、安全、高效的方式（默认推荐）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;后面会有这种方式的语法语义与底层源码解析&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌 C&#43;&#43;类成员函数 static 与 const 的声明与定义规则解析</title>
      <link>/posts/-c&#43;&#43;-%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static-%E4%B8%8E-const-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-c&#43;&#43;-%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static-%E4%B8%8E-const-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;-c类成员函数static-与-const-的声明与定义规则解析&#34;&gt;📌 C++类成员函数：&lt;code&gt;static&lt;/code&gt; 与 &lt;code&gt;const&lt;/code&gt; 的声明与定义规则解析&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;为什么头文件声明要写 &lt;code&gt;static/const&lt;/code&gt;，而实现时 &lt;code&gt;static&lt;/code&gt; 要省略、&lt;code&gt;const&lt;/code&gt; 必须保留？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;-核心规则对比表&#34;&gt;🔍 核心规则对比表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;关键字&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;头文件（.h）声明&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;源文件（.cpp）定义&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;底层原因&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;&lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;必须显式声明：&lt;code&gt;static void func();&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;strong&gt;禁止重复&lt;/strong&gt;：直接写 &lt;code&gt;void Class::func()&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;static&lt;/code&gt; 标识函数归属类而非对象；定义时 &lt;code&gt;ClassName::&lt;/code&gt; 已隐含作用域，再写 &lt;code&gt;static&lt;/code&gt; 会被解释为文件作用域函数，破坏封装性。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;必须显式声明：&lt;code&gt;int get() const;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;strong&gt;必须保留&lt;/strong&gt;：&lt;code&gt;int Class::get() const&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;const&lt;/code&gt; 是函数签名的一部分，声明与定义必须严格一致，否则编译器视为不同函数，导致链接错误。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-一static-关键字的声明与定义分离&#34;&gt;⚙️ 一、&lt;code&gt;static&lt;/code&gt; 关键字的声明与定义分离&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-声明时需&#34;&gt;1. &lt;strong&gt;声明时需 &lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在头文件中，&lt;code&gt;static&lt;/code&gt; 明确标识该函数是&lt;strong&gt;类级别共享&lt;/strong&gt;的，不依赖对象实例（无 &lt;code&gt;this&lt;/code&gt; 指针）：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// MyClass.h&#xA;class MyClass {&#xA;public:&#xA;    static void sharedFunc(); // ✅ 声明为静态&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2-定义时禁止&#34;&gt;2. &lt;strong&gt;定义时禁止 &lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在源文件中，&lt;code&gt;ClassName::&lt;/code&gt; 已指明函数归属类作用域。若添加 &lt;code&gt;static&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;会被编译器解释为&lt;strong&gt;文件作用域的静态函数&lt;/strong&gt;（仅当前 &lt;code&gt;.cpp&lt;/code&gt; 可见）；&lt;/li&gt;&#xA;&lt;li&gt;导致无法通过 &lt;code&gt;MyClass::sharedFunc()&lt;/code&gt; 全局访问，破坏封装性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;✅ 正确写法：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌小对象优化（Small Object Optimization）深度解析：C&#43;&#43;容器的性能利器</title>
      <link>/posts/%E5%B0%8F%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96small-object-optimization%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90c&#43;&#43;%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%A9%E5%99%A8/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E5%B0%8F%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96small-object-optimization%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90c&#43;&#43;%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%A9%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;小对象优化small-object-optimization深度解析c容器的性能利器&#34;&gt;小对象优化（Small Object Optimization）深度解析：C++容器的性能利器&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在现代C++开发中，&lt;code&gt;std::string&lt;/code&gt;和&lt;code&gt;std::vector&lt;/code&gt;等标准容器的高效性往往被开发者视为理所当然。然而，这些容器在处理小对象时的卓越性能背后，隐藏着一项重要的优化技术——&lt;strong&gt;小对象优化（Small Object Optimization, SOO）&lt;/strong&gt;。对于追求高性能的C++开发者而言，理解SOO的工作原理不仅有助于编写更高效的代码，更能启发我们在设计自定义容器时采用类似的优化策略。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题背景小对象的性能困境&#34;&gt;问题背景：小对象的性能困境&lt;/h2&gt;&#xA;&lt;h3 id=&#34;堆分配的性能开销&#34;&gt;堆分配的性能开销&lt;/h3&gt;&#xA;&lt;p&gt;当我们使用&lt;code&gt;std::string&lt;/code&gt;或&lt;code&gt;std::vector&lt;/code&gt;存储数据时，这些容器通常需要动态分配内存来存储实际数据。对于大型对象，堆分配的开销相对于数据处理成本而言是可以接受的。但是，当我们频繁处理小对象时，情况就截然不同了：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;分配器开销&lt;/strong&gt;：每次调用&lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt;或&lt;code&gt;malloc&lt;/code&gt;/&lt;code&gt;free&lt;/code&gt;都涉及复杂的内存管理算法，包括寻找合适大小的内存块、维护空闲列表等&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;内存碎片&lt;/strong&gt;：大量小内存块的分配和释放会导致堆内存碎片化，降低内存利用率&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存局部性差&lt;/strong&gt;：堆上分配的小对象在内存中分布散乱，访问时缓存命中率低&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;传统解决方案的局限&#34;&gt;传统解决方案的局限&lt;/h3&gt;&#xA;&lt;p&gt;栈上分配虽然速度极快，但受限于生命周期管理，无法满足容器需要动态调整大小的需求。而纯粹的堆分配虽然灵活，但在处理短字符串、小容量向量等高频场景时，性能开销变得不可忽视。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心问题&lt;/strong&gt;：如何为需要动态内存管理的容器优化小对象的存储性能？&lt;/p&gt;&#xA;&lt;h2 id=&#34;soo核心原理智能的空间换时间策略&#34;&gt;SOO核心原理：智能的空间换时间策略&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本思想&#34;&gt;基本思想&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;小对象优化的核心策略&lt;/strong&gt;是在容器对象内部预留一个&lt;strong&gt;固定大小的内部缓冲区（Internal Buffer）&lt;/strong&gt;。这个缓冲区作为&amp;quot;快速通道&amp;quot;，专门用于存储小对象的数据。&lt;/p&gt;&#xA;&lt;h3 id=&#34;大小判定逻辑&#34;&gt;大小判定逻辑&lt;/h3&gt;&#xA;&lt;p&gt;SOO的工作机制可以用简单的条件判断来描述：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (required_size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; internal_buffer_size) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用内部缓冲区，无需堆分配&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    store_in_internal_buffer(data);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 退回到传统的堆内存分配&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    allocate_on_heap(data);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;zero-overhead抽象&#34;&gt;Zero-Overhead抽象&lt;/h3&gt;&#xA;&lt;p&gt;SOO的精妙之处在于对使用者完全透明。无论底层使用的是内部缓冲区还是堆内存，容器提供的接口行为完全一致，这体现了C++中&amp;quot;Zero-Overhead&amp;quot;抽象的设计理念。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现剖析以stdstring为例&#34;&gt;实现剖析：以std::string为例&lt;/h2&gt;&#xA;&lt;h3 id=&#34;典型数据结构设计&#34;&gt;典型数据结构设计&lt;/h3&gt;&#xA;&lt;p&gt;一个支持SOO的&lt;code&gt;std::string&lt;/code&gt;内部结构可能如下所示：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;optimized_string&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; size_t INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;union&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 大对象模式：指向堆内存&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            size_t size;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            size_t capacity;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } heap_data;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 小对象模式：直接存储在对象内部&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// +1 for null terminator&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; remaining_size; &lt;span style=&#34;color:#75715e&#34;&gt;// 用于标识当前模式和剩余空间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        } stack_data;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 通过特定位或值判断当前使用的存储模式&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; stack_data.remaining_size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; INTERNAL_BUFFER_SIZE;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; stack_data.buffer : heap_data.ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    size_t &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               (INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; stack_data.remaining_size) &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               heap_data.size;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;状态区分机制&#34;&gt;状态区分机制&lt;/h3&gt;&#xA;&lt;p&gt;区分当前使用内部缓冲区还是堆内存是SOO实现的关键技术点。常见策略包括：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌深入分析 =delete 与私有化构造和析构函数的本质区别</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90-delete-%E4%B8%8E%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90-delete-%E4%B8%8E%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;p&gt;[[c++]] [[delete]] [[构造函数]] [[析构函数]]&lt;/p&gt;&#xA;&lt;h2 id=&#34;深入分析-delete-与私有化构造和析构函数的本质区别&#34;&gt;深入分析：= delete 与私有化构造和析构函数的本质区别&lt;/h2&gt;&#xA;&lt;p&gt;​&lt;strong&gt;直接结论&lt;/strong&gt;​：&lt;br&gt;&#xA;绝对不能将构造函数和析构函数写为 = delete 这会直接破坏单例模式的核心功能。以下是详细技术分析：&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;一语法层面的根本差异&#34;&gt;一、语法层面的根本差异&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方案&lt;/th&gt;&#xA;          &lt;th&gt;可访问性&lt;/th&gt;&#xA;          &lt;th&gt;编译器行为&lt;/th&gt;&#xA;          &lt;th&gt;对单例模式的影响&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;​&lt;strong&gt;私有构造函数&lt;/strong&gt;​&lt;/td&gt;&#xA;          &lt;td&gt;仅类内部可访问&lt;/td&gt;&#xA;          &lt;td&gt;允许类内部代码构造对象&lt;/td&gt;&#xA;          &lt;td&gt;实现单例的核心手段&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;Singleton() = delete&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;函数被彻底删除&lt;/td&gt;&#xA;          &lt;td&gt;任何构造尝试直接报错&lt;/td&gt;&#xA;          &lt;td&gt;完全无法创建对象&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方案&lt;/th&gt;&#xA;          &lt;th&gt;可访问性&lt;/th&gt;&#xA;          &lt;th&gt;编译器行为&lt;/th&gt;&#xA;          &lt;th&gt;对单例模式的影响&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;​&lt;strong&gt;私有析构函数&lt;/strong&gt;​&lt;/td&gt;&#xA;          &lt;td&gt;仅类内部可访问&lt;/td&gt;&#xA;          &lt;td&gt;允许类内部析构对象&lt;/td&gt;&#xA;          &lt;td&gt;防止外部delete操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;~Singleton() = delete&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;函数被彻底删除&lt;/td&gt;&#xA;          &lt;td&gt;对象销毁时直接报错&lt;/td&gt;&#xA;          &lt;td&gt;对象无法被正确释放&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;二关键错误场景演示&#34;&gt;二、关键错误场景演示&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton instance;  &lt;span style=&#34;color:#75715e&#34;&gt;// 这里会编译失败！&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;// 构造函数被删除&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 析构函数被删除&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;编译器报错信息&#34;&gt;编译器报错信息&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error: use of deleted &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Singleton::Singleton()&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         static Singleton instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;note: declared here&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     Singleton&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; delete;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ^~~~~~~~~~~&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error: use of deleted &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Singleton::~Singleton()&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         static Singleton instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;note: declared here&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ~Singleton&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; delete;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h3 id=&#34;三技术原理深度解析&#34;&gt;三、技术原理深度解析&lt;/h3&gt;&#xA;&lt;h4 id=&#34;构造函数删除的致命问题&#34;&gt;构造函数删除的致命问题&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;静态局部变量初始化&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;static Singleton instance&lt;/code&gt;本质需要调用构造函数，但构造函数已被删除 → 编译失败&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;单例模式基础破坏&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;删除构造函数意味着该类无法被实例化，完全失去单例存在的意义&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;析构函数删除的连锁反应&#34;&gt;析构函数删除的连锁反应&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;静态变量销毁问题&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序退出时，静态变量&lt;code&gt;instance&lt;/code&gt;需要调用析构函数 → 因析构函数被删除导致链接错误&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;内存泄漏伪装者&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;即使通过特殊手段构造对象，也无法正常释放资源 → 违反RAII原则&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;四正确方案对比验证&#34;&gt;四、正确方案对比验证&lt;/h3&gt;&#xA;&lt;h4 id=&#34;正确实现私有构造析构&#34;&gt;正确实现（私有构造/析构）&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton instance;  &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：调用私有构造函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 禁用拷贝操作&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Singleton(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：私有默认构造&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：私有析构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;关键优势&#34;&gt;关键优势&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;构造可控性&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过私有构造函数限制对象创建途径，确保唯一实例&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;析构安全性&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;私有析构函数阻止外部&lt;code&gt;delete&lt;/code&gt;操作，依赖系统自动释放&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;资源管理合规&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;静态局部变量在程序结束时自动调用析构函数，符合RAII规范&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;五特殊场景扩展讨论&#34;&gt;五、特殊场景扩展讨论&lt;/h3&gt;&#xA;&lt;h4 id=&#34;q如果确实需要完全禁止某个类的实例化&#34;&gt;Q：如果确实需要完全禁止某个类的实例化？&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UtilityClass&lt;/span&gt; {  &lt;span style=&#34;color:#75715e&#34;&gt;// 工具类，仅包含静态方法&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    UtilityClass() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;UtilityClass() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper1&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper2&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;strong&gt;适用场景&lt;/strong&gt;​：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌深入理解 C&#43;&#43; 中的 std ref 和 cref 的引用封装机制</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-c&#43;&#43;-%E4%B8%AD%E7%9A%84-std-ref-%E5%92%8C-cref-%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%81%E8%A3%85%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-c&#43;&#43;-%E4%B8%AD%E7%9A%84-std-ref-%E5%92%8C-cref-%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%81%E8%A3%85%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;深入理解-c-中的-std-ref-和-cref-的引用封装机制&#34;&gt;深入理解 C++ 中的 std ref 和 cref 的引用封装机制&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在现代 C++ 编程中，&lt;strong&gt;按值传参是常态，但有时候我们确实需要传引用&lt;/strong&gt;。尤其是在使用 &lt;code&gt;std::bind&lt;/code&gt;、&lt;code&gt;std::thread&lt;/code&gt;、标准算法等场景下，如果不加注意，原本希望传引用的变量却被复制，导致逻辑失效甚至程序崩溃。&lt;br&gt;&#xA;本文将带你深入理解 &lt;code&gt;std::ref&lt;/code&gt; 和 &lt;code&gt;std::cref&lt;/code&gt; 的设计原理、使用场景以及易踩的坑。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;为什么需要引用封装器&#34;&gt;为什么需要引用封装器&lt;/h2&gt;&#xA;&lt;p&gt;先来看一个例子：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; x) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;thread&lt;/span&gt; t(increment, a);  &lt;span style=&#34;color:#75715e&#34;&gt;// ❌ 编译失败&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    t.join();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可能以为把 &lt;code&gt;a&lt;/code&gt; 传进去就是引用了，但事实并非如此。&lt;code&gt;std::thread&lt;/code&gt; 默认按值复制参数。它尝试将 &lt;code&gt;a&lt;/code&gt; 拷贝一份传递给 &lt;code&gt;increment&lt;/code&gt;，而 &lt;code&gt;increment&lt;/code&gt; 期望的是 &lt;code&gt;int&amp;amp;&lt;/code&gt;，于是编译器报错。&lt;/p&gt;&#xA;&lt;p&gt;这个时候，&lt;code&gt;std::ref(a)&lt;/code&gt; 就派上了用场：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;thread&lt;/span&gt; t(increment, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ref(a));  &lt;span style=&#34;color:#75715e&#34;&gt;// ✅ 传引用成功&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;std-ref-和-cref-是什么&#34;&gt;std ref 和 cref 是什么&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;std::ref(obj)&lt;/code&gt;：返回一个 &lt;strong&gt;可修改引用&lt;/strong&gt; 的包装器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;std::cref(obj)&lt;/code&gt;：返回一个 &lt;strong&gt;const 引用&lt;/strong&gt; 的包装器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>asan</title>
      <link>/posts/asan/</link>
      <pubDate>Thu, 01 Jun 2023 09:30:01 +0800</pubDate>
      <guid>/posts/asan/</guid>
      <description>&lt;script src=&#34;https://gist.github.com/luyoungcn/b544977db493d7016f87ae60c51cc4cd.js&#34;&gt;&lt;/script&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 前向声明与指针使用指南</title>
      <link>/posts/c&#43;&#43;-%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      <guid>/posts/c&#43;&#43;-%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;c++ 为什么有些类属性使用普通的指针定义，而不是使用智能指针&#xA;&lt;code&gt;DogClass *ptr;&lt;/code&gt; 而不是 &lt;code&gt;std::unique_ptr&amp;lt;DogClass&amp;gt; ptr&lt;/code&gt;;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;c-前向声明与指针使用指南&#34;&gt;C++ 前向声明与指针使用指南&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前向声明与不完整类型&#34;&gt;前向声明与不完整类型&lt;/h2&gt;&#xA;&lt;p&gt;在 C++ 中，&lt;strong&gt;前向声明&lt;/strong&gt;（Forward Declaration）允许我们在不包含完整类定义的情况下引用一个类。这对于减少编译依赖和解决循环依赖问题非常有用。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 前向声明示例&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyClass&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 只声明存在性，不提供定义&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，&lt;code&gt;MyClass&lt;/code&gt; 被称为&lt;strong&gt;不完整类型&lt;/strong&gt;（Incomplete Type），因为编译器只知道该类存在，但不知道它的大小、成员或方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;stdunique_ptr-与不完整类型&#34;&gt;std::unique_ptr 与不完整类型&lt;/h2&gt;&#xA;&lt;p&gt;当使用 &lt;code&gt;std::unique_ptr&lt;/code&gt; 管理前向声明类的对象时，会出现问题：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 头文件中&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyForwardDeclaredClass&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 前向声明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Container&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;MyForwardDeclaredClass&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ptr_; &lt;span style=&#34;color:#75715e&#34;&gt;// 编译错误!&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码在编译时会失败，错误类似于：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;error: invalid application of &amp;#39;sizeof&amp;#39; to incomplete type &amp;#39;MyForwardDeclaredClass&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;原因分析&#34;&gt;原因分析&lt;/h3&gt;&#xA;&lt;p&gt;这个问题出现的原因是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; 的析构函数需要知道如何删除它管理的对象&lt;/li&gt;&#xA;&lt;li&gt;为此，编译器需要在编译 &lt;code&gt;Container&lt;/code&gt; 类时知道 &lt;code&gt;MyForwardDeclaredClass&lt;/code&gt; 的完整定义&lt;/li&gt;&#xA;&lt;li&gt;当编译器尝试计算不完整类型的 &lt;code&gt;sizeof&lt;/code&gt; 时，无法确定其大小，因此报错&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;具体来说，&lt;code&gt;std::unique_ptr&lt;/code&gt; 的默认删除器 &lt;code&gt;std::default_delete&lt;/code&gt; 在析构时会执行：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;default_delete&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ptr) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static_assert&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(T) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Type must be complete&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt; ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当类型不完整时，&lt;code&gt;sizeof(T)&lt;/code&gt; 无法计算，触发 &lt;code&gt;static_assert&lt;/code&gt; 失败。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

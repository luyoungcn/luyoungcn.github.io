<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cpp on LuyangのBlog</title>
    <link>/tags/cpp/</link>
    <description>Recent content in Cpp on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Mon, 23 Jun 2025 00:00:00 +0800</lastBuildDate>
    <atom:link href="/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入 C&#43;&#43; 的隐秘角落：彻底解析参数依赖查找 (ADL)</title>
      <link>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E7%9A%84%E9%9A%90%E7%A7%98%E8%A7%92%E8%90%BD%E5%BD%BB%E5%BA%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE-adl/</link>
      <pubDate>Mon, 23 Jun 2025 00:00:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E7%9A%84%E9%9A%90%E7%A7%98%E8%A7%92%E8%90%BD%E5%BD%BB%E5%BA%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE-adl/</guid>
      <description>&lt;h1 id=&#34;深入-c-的隐秘角落彻底解析参数依赖查找-adl&#34;&gt;深入 C++ 的隐秘角落：彻底解析参数依赖查找 (ADL)&lt;/h1&gt;&#xA;&lt;p&gt;在 C++ 的世界里，有些特性如同空气，无处不在，默默地支撑着我们代码的优雅与简洁，但我们却很少去探究其背后的原理。&lt;code&gt;std::cout &amp;lt;&amp;lt; &amp;quot;Hello, World!&amp;quot;;&lt;/code&gt; 这行代码对于每个 C++ 开发者来说都再熟悉不过。但是，你是否曾停下来想过，&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 函数明明定义在 &lt;code&gt;std&lt;/code&gt; 命名空间中，为什么我们在调用它时，并不需要写成 &lt;code&gt;std::operator&amp;lt;&amp;lt;(std::cout, &amp;quot;Hello, World!&amp;quot;);&lt;/code&gt; 这种冗长繁琐的形式？&lt;/p&gt;&#xA;&lt;p&gt;这个问题的答案，就隐藏在 C++ 语言一个强大而又微妙的机制中——&lt;strong&gt;参数依赖查找（Argument-Dependent Lookup）&lt;/strong&gt;，通常被缩写为 &lt;strong&gt;ADL&lt;/strong&gt;。它还有一个广为人知的名字，叫 &lt;strong&gt;Koenig 查找（Koenig Lookup）&lt;/strong&gt;，以其发现者 Andrew Koenig 的名字命名。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Scott_Meyers.jpg/500px-Scott_Meyers.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;ADL 是 C++ 名称查找规则的重要组成部分。它极大地提升了泛型编程和操作符重载的可用性，使得代码更符合人类的直觉。然而，它也是一柄双刃剑，如果不了解其工作原理，有时会导致一些令人困惑的编译错误或意想不到的行为。&lt;/p&gt;&#xA;&lt;p&gt;这篇超过5000字的长文，将作为一份详尽的指南，带你拨开 ADL 的层层迷雾。我们将从没有 ADL 的世界开始，逐步揭示 ADL 的核心机制、详细规则、与模板和“隐藏友元”等现代 C++ 技术的协同工作，并最终探讨如何规避其带来的陷阱，编写出更健壮、更可维护的 C++ 代码。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;第一章：前 ADL 时代 —— 常规的无限定名称查找&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.1 名称查找的基本原则&lt;/li&gt;&#xA;&lt;li&gt;1.2 命名空间带来的挑战&lt;/li&gt;&#xA;&lt;li&gt;1.3 没有 ADL 的代码之痛&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二章：ADL 的诞生与核心机制&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2.1 ADL 的正式定义&lt;/li&gt;&#xA;&lt;li&gt;2.2 关键概念：关联命名空间 (Associated Namespaces)&lt;/li&gt;&#xA;&lt;li&gt;2.3 两阶段查找的协作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;第三章：深入 ADL 的规则与细节&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌深入 C&#43;&#43; 单例模式：原理、实现方式对比与 shared_ptr 架构设计</title>
      <link>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8E-shared_ptr-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 06 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8E-shared_ptr-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h1 id=&#34;深入-c-单例模式原理实现方式对比与-shared_ptr-架构设计&#34;&gt;📌深入 C++ 单例模式：原理、实现方式对比与 shared_ptr 架构设计&lt;/h1&gt;&#xA;&lt;h2 id=&#34;1-什么是单例基本语义与使用场景&#34;&gt;1️⃣ 什么是单例？基本语义与使用场景&lt;/h2&gt;&#xA;&lt;p&gt;单例（[[Singleton]]）是对象创建模式中最常见的一种，其目标是确保类在系统中&lt;strong&gt;只有一个实例&lt;/strong&gt;，并提供全局访问入口。&lt;/p&gt;&#xA;&lt;h3 id=&#34;-常见使用场景&#34;&gt;✅ 常见使用场景：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;配置中心（ConfigManager）&lt;/li&gt;&#xA;&lt;li&gt;日志系统（Logger）&lt;/li&gt;&#xA;&lt;li&gt;资源池（如内存池、线程池）&lt;/li&gt;&#xA;&lt;li&gt;调度器、会话管理器&lt;/li&gt;&#xA;&lt;li&gt;框架注册表、插件系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-单例的五种常见实现方式&#34;&gt;2️⃣ 单例的五种常见实现方式&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;推荐使用方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;懒汉式 + 线程安全（C++11 标准）局部静态变量（Meyers Singleton）&amp;mdash; 【推荐使用】&lt;/li&gt;&#xA;&lt;li&gt;shared_ptr 单例（更灵活）&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;1-饿汉式单例early-instantiation&#34;&gt;🍃1. 饿汉式单例（Early Instantiation）&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; instance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Singleton Singleton&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 简单易懂，线程安全（由 C++ 静态对象初始化保障）&lt;/li&gt;&#xA;&lt;li&gt;❌ 资源可能浪费，程序启动就构造实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-懒汉式lazy-initialization-非线程安全&#34;&gt;🍃2. 懒汉式（Lazy Initialization）+ 非线程安全&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;instance_)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            instance_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; instance_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;instance_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 仅在需要时创建实例&lt;/li&gt;&#xA;&lt;li&gt;❌ 非线程安全，多个线程可能同时构造多个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-懒汉式--线程安全c11-标准局部静态变量meyers-singleton-推荐使用&#34;&gt;🍃3. 懒汉式 + 线程安全（C++11 标准）局部静态变量（Meyers Singleton）&amp;mdash; 【推荐使用】&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; instance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton inst;  &lt;span style=&#34;color:#75715e&#34;&gt;// C++11 保证线程安全&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 推荐使用：线程安全、懒加载、无锁开销&lt;/li&gt;&#xA;&lt;li&gt;✅ 析构自动管理，依赖 C++ 静态局部变量特性&lt;/li&gt;&#xA;&lt;li&gt;❗ 禁止拷贝构造、赋值运算，防止实例复制&lt;/li&gt;&#xA;&lt;li&gt;✅ 最简洁、安全、高效的方式（默认推荐）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;后面会有这种方式的语法语义与底层源码解析&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌 C&#43;&#43;类成员函数 static 与 const 的声明与定义规则解析</title>
      <link>/posts/-c&#43;&#43;-%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static-%E4%B8%8E-const-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-c&#43;&#43;-%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static-%E4%B8%8E-const-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;-c类成员函数static-与-const-的声明与定义规则解析&#34;&gt;📌 C++类成员函数：&lt;code&gt;static&lt;/code&gt; 与 &lt;code&gt;const&lt;/code&gt; 的声明与定义规则解析&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;为什么头文件声明要写 &lt;code&gt;static/const&lt;/code&gt;，而实现时 &lt;code&gt;static&lt;/code&gt; 要省略、&lt;code&gt;const&lt;/code&gt; 必须保留？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;-核心规则对比表&#34;&gt;🔍 核心规则对比表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;关键字&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;头文件（.h）声明&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;源文件（.cpp）定义&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;底层原因&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;&lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;必须显式声明：&lt;code&gt;static void func();&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;strong&gt;禁止重复&lt;/strong&gt;：直接写 &lt;code&gt;void Class::func()&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;static&lt;/code&gt; 标识函数归属类而非对象；定义时 &lt;code&gt;ClassName::&lt;/code&gt; 已隐含作用域，再写 &lt;code&gt;static&lt;/code&gt; 会被解释为文件作用域函数，破坏封装性。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;必须显式声明：&lt;code&gt;int get() const;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;strong&gt;必须保留&lt;/strong&gt;：&lt;code&gt;int Class::get() const&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;const&lt;/code&gt; 是函数签名的一部分，声明与定义必须严格一致，否则编译器视为不同函数，导致链接错误。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-一static-关键字的声明与定义分离&#34;&gt;⚙️ 一、&lt;code&gt;static&lt;/code&gt; 关键字的声明与定义分离&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-声明时需&#34;&gt;1. &lt;strong&gt;声明时需 &lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在头文件中，&lt;code&gt;static&lt;/code&gt; 明确标识该函数是&lt;strong&gt;类级别共享&lt;/strong&gt;的，不依赖对象实例（无 &lt;code&gt;this&lt;/code&gt; 指针）：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// MyClass.h&#xA;class MyClass {&#xA;public:&#xA;    static void sharedFunc(); // ✅ 声明为静态&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2-定义时禁止&#34;&gt;2. &lt;strong&gt;定义时禁止 &lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在源文件中，&lt;code&gt;ClassName::&lt;/code&gt; 已指明函数归属类作用域。若添加 &lt;code&gt;static&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;会被编译器解释为&lt;strong&gt;文件作用域的静态函数&lt;/strong&gt;（仅当前 &lt;code&gt;.cpp&lt;/code&gt; 可见）；&lt;/li&gt;&#xA;&lt;li&gt;导致无法通过 &lt;code&gt;MyClass::sharedFunc()&lt;/code&gt; 全局访问，破坏封装性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;✅ 正确写法：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌小对象优化（Small Object Optimization）深度解析：C&#43;&#43;容器的性能利器</title>
      <link>/posts/%E5%B0%8F%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96small-object-optimization%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90c&#43;&#43;%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%A9%E5%99%A8/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E5%B0%8F%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96small-object-optimization%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90c&#43;&#43;%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%A9%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;小对象优化small-object-optimization深度解析c容器的性能利器&#34;&gt;小对象优化（Small Object Optimization）深度解析：C++容器的性能利器&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在现代C++开发中，&lt;code&gt;std::string&lt;/code&gt;和&lt;code&gt;std::vector&lt;/code&gt;等标准容器的高效性往往被开发者视为理所当然。然而，这些容器在处理小对象时的卓越性能背后，隐藏着一项重要的优化技术——&lt;strong&gt;小对象优化（Small Object Optimization, SOO）&lt;/strong&gt;。对于追求高性能的C++开发者而言，理解SOO的工作原理不仅有助于编写更高效的代码，更能启发我们在设计自定义容器时采用类似的优化策略。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题背景小对象的性能困境&#34;&gt;问题背景：小对象的性能困境&lt;/h2&gt;&#xA;&lt;h3 id=&#34;堆分配的性能开销&#34;&gt;堆分配的性能开销&lt;/h3&gt;&#xA;&lt;p&gt;当我们使用&lt;code&gt;std::string&lt;/code&gt;或&lt;code&gt;std::vector&lt;/code&gt;存储数据时，这些容器通常需要动态分配内存来存储实际数据。对于大型对象，堆分配的开销相对于数据处理成本而言是可以接受的。但是，当我们频繁处理小对象时，情况就截然不同了：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;分配器开销&lt;/strong&gt;：每次调用&lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt;或&lt;code&gt;malloc&lt;/code&gt;/&lt;code&gt;free&lt;/code&gt;都涉及复杂的内存管理算法，包括寻找合适大小的内存块、维护空闲列表等&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;内存碎片&lt;/strong&gt;：大量小内存块的分配和释放会导致堆内存碎片化，降低内存利用率&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存局部性差&lt;/strong&gt;：堆上分配的小对象在内存中分布散乱，访问时缓存命中率低&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;传统解决方案的局限&#34;&gt;传统解决方案的局限&lt;/h3&gt;&#xA;&lt;p&gt;栈上分配虽然速度极快，但受限于生命周期管理，无法满足容器需要动态调整大小的需求。而纯粹的堆分配虽然灵活，但在处理短字符串、小容量向量等高频场景时，性能开销变得不可忽视。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心问题&lt;/strong&gt;：如何为需要动态内存管理的容器优化小对象的存储性能？&lt;/p&gt;&#xA;&lt;h2 id=&#34;soo核心原理智能的空间换时间策略&#34;&gt;SOO核心原理：智能的空间换时间策略&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本思想&#34;&gt;基本思想&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;小对象优化的核心策略&lt;/strong&gt;是在容器对象内部预留一个&lt;strong&gt;固定大小的内部缓冲区（Internal Buffer）&lt;/strong&gt;。这个缓冲区作为&amp;quot;快速通道&amp;quot;，专门用于存储小对象的数据。&lt;/p&gt;&#xA;&lt;h3 id=&#34;大小判定逻辑&#34;&gt;大小判定逻辑&lt;/h3&gt;&#xA;&lt;p&gt;SOO的工作机制可以用简单的条件判断来描述：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (required_size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; internal_buffer_size) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用内部缓冲区，无需堆分配&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    store_in_internal_buffer(data);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 退回到传统的堆内存分配&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    allocate_on_heap(data);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;zero-overhead抽象&#34;&gt;Zero-Overhead抽象&lt;/h3&gt;&#xA;&lt;p&gt;SOO的精妙之处在于对使用者完全透明。无论底层使用的是内部缓冲区还是堆内存，容器提供的接口行为完全一致，这体现了C++中&amp;quot;Zero-Overhead&amp;quot;抽象的设计理念。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现剖析以stdstring为例&#34;&gt;实现剖析：以std::string为例&lt;/h2&gt;&#xA;&lt;h3 id=&#34;典型数据结构设计&#34;&gt;典型数据结构设计&lt;/h3&gt;&#xA;&lt;p&gt;一个支持SOO的&lt;code&gt;std::string&lt;/code&gt;内部结构可能如下所示：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;optimized_string&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; size_t INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;union&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 大对象模式：指向堆内存&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            size_t size;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            size_t capacity;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } heap_data;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 小对象模式：直接存储在对象内部&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// +1 for null terminator&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; remaining_size; &lt;span style=&#34;color:#75715e&#34;&gt;// 用于标识当前模式和剩余空间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        } stack_data;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 通过特定位或值判断当前使用的存储模式&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; stack_data.remaining_size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; INTERNAL_BUFFER_SIZE;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; stack_data.buffer : heap_data.ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    size_t &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               (INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; stack_data.remaining_size) &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               heap_data.size;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;状态区分机制&#34;&gt;状态区分机制&lt;/h3&gt;&#xA;&lt;p&gt;区分当前使用内部缓冲区还是堆内存是SOO实现的关键技术点。常见策略包括：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌深入分析 =delete 与私有化构造和析构函数的本质区别</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90-delete-%E4%B8%8E%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90-delete-%E4%B8%8E%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;p&gt;[[c++]] [[delete]] [[构造函数]] [[析构函数]]&lt;/p&gt;&#xA;&lt;h2 id=&#34;深入分析-delete-与私有化构造和析构函数的本质区别&#34;&gt;深入分析：= delete 与私有化构造和析构函数的本质区别&lt;/h2&gt;&#xA;&lt;p&gt;​&lt;strong&gt;直接结论&lt;/strong&gt;​：&lt;br&gt;&#xA;绝对不能将构造函数和析构函数写为 = delete 这会直接破坏单例模式的核心功能。以下是详细技术分析：&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;一语法层面的根本差异&#34;&gt;一、语法层面的根本差异&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方案&lt;/th&gt;&#xA;          &lt;th&gt;可访问性&lt;/th&gt;&#xA;          &lt;th&gt;编译器行为&lt;/th&gt;&#xA;          &lt;th&gt;对单例模式的影响&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;​&lt;strong&gt;私有构造函数&lt;/strong&gt;​&lt;/td&gt;&#xA;          &lt;td&gt;仅类内部可访问&lt;/td&gt;&#xA;          &lt;td&gt;允许类内部代码构造对象&lt;/td&gt;&#xA;          &lt;td&gt;实现单例的核心手段&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;Singleton() = delete&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;函数被彻底删除&lt;/td&gt;&#xA;          &lt;td&gt;任何构造尝试直接报错&lt;/td&gt;&#xA;          &lt;td&gt;完全无法创建对象&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方案&lt;/th&gt;&#xA;          &lt;th&gt;可访问性&lt;/th&gt;&#xA;          &lt;th&gt;编译器行为&lt;/th&gt;&#xA;          &lt;th&gt;对单例模式的影响&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;​&lt;strong&gt;私有析构函数&lt;/strong&gt;​&lt;/td&gt;&#xA;          &lt;td&gt;仅类内部可访问&lt;/td&gt;&#xA;          &lt;td&gt;允许类内部析构对象&lt;/td&gt;&#xA;          &lt;td&gt;防止外部delete操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;~Singleton() = delete&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;函数被彻底删除&lt;/td&gt;&#xA;          &lt;td&gt;对象销毁时直接报错&lt;/td&gt;&#xA;          &lt;td&gt;对象无法被正确释放&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;二关键错误场景演示&#34;&gt;二、关键错误场景演示&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton instance;  &lt;span style=&#34;color:#75715e&#34;&gt;// 这里会编译失败！&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;// 构造函数被删除&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 析构函数被删除&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;编译器报错信息&#34;&gt;编译器报错信息&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error: use of deleted &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Singleton::Singleton()&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         static Singleton instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;note: declared here&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     Singleton&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; delete;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ^~~~~~~~~~~&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error: use of deleted &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Singleton::~Singleton()&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         static Singleton instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;note: declared here&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ~Singleton&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; delete;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h3 id=&#34;三技术原理深度解析&#34;&gt;三、技术原理深度解析&lt;/h3&gt;&#xA;&lt;h4 id=&#34;构造函数删除的致命问题&#34;&gt;构造函数删除的致命问题&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;静态局部变量初始化&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;static Singleton instance&lt;/code&gt;本质需要调用构造函数，但构造函数已被删除 → 编译失败&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;单例模式基础破坏&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;删除构造函数意味着该类无法被实例化，完全失去单例存在的意义&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;析构函数删除的连锁反应&#34;&gt;析构函数删除的连锁反应&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;静态变量销毁问题&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序退出时，静态变量&lt;code&gt;instance&lt;/code&gt;需要调用析构函数 → 因析构函数被删除导致链接错误&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;内存泄漏伪装者&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;即使通过特殊手段构造对象，也无法正常释放资源 → 违反RAII原则&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;四正确方案对比验证&#34;&gt;四、正确方案对比验证&lt;/h3&gt;&#xA;&lt;h4 id=&#34;正确实现私有构造析构&#34;&gt;正确实现（私有构造/析构）&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton instance;  &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：调用私有构造函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 禁用拷贝操作&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Singleton(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：私有默认构造&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：私有析构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;关键优势&#34;&gt;关键优势&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;构造可控性&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过私有构造函数限制对象创建途径，确保唯一实例&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;析构安全性&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;私有析构函数阻止外部&lt;code&gt;delete&lt;/code&gt;操作，依赖系统自动释放&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;资源管理合规&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;静态局部变量在程序结束时自动调用析构函数，符合RAII规范&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;五特殊场景扩展讨论&#34;&gt;五、特殊场景扩展讨论&lt;/h3&gt;&#xA;&lt;h4 id=&#34;q如果确实需要完全禁止某个类的实例化&#34;&gt;Q：如果确实需要完全禁止某个类的实例化？&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UtilityClass&lt;/span&gt; {  &lt;span style=&#34;color:#75715e&#34;&gt;// 工具类，仅包含静态方法&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    UtilityClass() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;UtilityClass() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper1&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper2&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;strong&gt;适用场景&lt;/strong&gt;​：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌深入理解 C&#43;&#43; 中的 std ref 和 cref 的引用封装机制</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-c&#43;&#43;-%E4%B8%AD%E7%9A%84-std-ref-%E5%92%8C-cref-%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%81%E8%A3%85%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-c&#43;&#43;-%E4%B8%AD%E7%9A%84-std-ref-%E5%92%8C-cref-%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%81%E8%A3%85%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;深入理解-c-中的-std-ref-和-cref-的引用封装机制&#34;&gt;深入理解 C++ 中的 std ref 和 cref 的引用封装机制&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在现代 C++ 编程中，&lt;strong&gt;按值传参是常态，但有时候我们确实需要传引用&lt;/strong&gt;。尤其是在使用 &lt;code&gt;std::bind&lt;/code&gt;、&lt;code&gt;std::thread&lt;/code&gt;、标准算法等场景下，如果不加注意，原本希望传引用的变量却被复制，导致逻辑失效甚至程序崩溃。&lt;br&gt;&#xA;本文将带你深入理解 &lt;code&gt;std::ref&lt;/code&gt; 和 &lt;code&gt;std::cref&lt;/code&gt; 的设计原理、使用场景以及易踩的坑。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;为什么需要引用封装器&#34;&gt;为什么需要引用封装器&lt;/h2&gt;&#xA;&lt;p&gt;先来看一个例子：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; x) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;thread&lt;/span&gt; t(increment, a);  &lt;span style=&#34;color:#75715e&#34;&gt;// ❌ 编译失败&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    t.join();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可能以为把 &lt;code&gt;a&lt;/code&gt; 传进去就是引用了，但事实并非如此。&lt;code&gt;std::thread&lt;/code&gt; 默认按值复制参数。它尝试将 &lt;code&gt;a&lt;/code&gt; 拷贝一份传递给 &lt;code&gt;increment&lt;/code&gt;，而 &lt;code&gt;increment&lt;/code&gt; 期望的是 &lt;code&gt;int&amp;amp;&lt;/code&gt;，于是编译器报错。&lt;/p&gt;&#xA;&lt;p&gt;这个时候，&lt;code&gt;std::ref(a)&lt;/code&gt; 就派上了用场：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;thread&lt;/span&gt; t(increment, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ref(a));  &lt;span style=&#34;color:#75715e&#34;&gt;// ✅ 传引用成功&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;std-ref-和-cref-是什么&#34;&gt;std ref 和 cref 是什么&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;std::ref(obj)&lt;/code&gt;：返回一个 &lt;strong&gt;可修改引用&lt;/strong&gt; 的包装器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;std::cref(obj)&lt;/code&gt;：返回一个 &lt;strong&gt;const 引用&lt;/strong&gt; 的包装器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘 C&#43;&#43;非侵入性编程范式</title>
      <link>/posts/-c&#43;&#43;%E9%9D%9E%E4%BE%B5%E5%85%A5%E6%80%A7%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-c&#43;&#43;%E9%9D%9E%E4%BE%B5%E5%85%A5%E6%80%A7%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;c非侵入性编程范式&#34;&gt;C++非侵入性编程范式&lt;/h2&gt;&#xA;&lt;p&gt;文档编号: Cpp-Tech-NIP-20250624-Final&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-摘要&#34;&gt;1. 摘要&lt;/h3&gt;&#xA;&lt;p&gt;本文档为C++开发者提供了一份关于&lt;strong&gt;非侵入性 (Non-Intrusive)&lt;/strong&gt; 编程范式的全面、深入的技术指南。文档从核心定义出发，系统性地阐述了非侵入性设计的理念、基石与关键技术。内容涵盖泛型编程、非成员函数的策略性使用、操作符重载的外部实现机制（包括参数依赖查找ADL与函数重载），以及类型萃取和智能指针等高级应用。本文旨在通过丰富的代码示例和详尽的原理剖析，帮助开发者掌握并应用非侵入性原则，以构建松耦合、高复用性且易于维护的现代C++软件系统。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-何为非侵入性编程&#34;&gt;2. 何为非侵入性编程？&lt;/h3&gt;&#xA;&lt;p&gt;在C++中，&lt;strong&gt;非侵入性 (Non-Intrusive)&lt;/strong&gt; 是一种核心设计哲学，其基本原则是：&lt;strong&gt;在为现有类型（如类、结构体）增加新功能，或使其与某个框架、库协作时，无需修改该类型自身的源代码。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;与之相对的是“侵入性 (Intrusive)”设计，它要求被操作的类型必须做出“内在”的改变，例如继承自特定的基类、包含特定的成员变量或实现特定的成员函数。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心思想对比:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;非侵入性 (Non-Intrusive):&lt;/strong&gt; 功能是“外加”于类型之上的。如同为一部标准手机配上一个多功能手机壳，手机本身无需任何改造。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;侵入性 (Intrusive):&lt;/strong&gt; 功能是“内建”在类型之中的。如同手机在设计制造时就内置了防水和无线充电功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;现代C++推崇非侵入性设计，因为它极大地增强了代码的&lt;strong&gt;灵活性&lt;/strong&gt;与&lt;strong&gt;可复用性&lt;/strong&gt;，允许开发者将无法修改的第三方类型、标准库类型或遗留代码无缝集成到新系统中。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-基石泛型编程与模板&#34;&gt;3. 基石：泛型编程与模板&lt;/h3&gt;&#xA;&lt;p&gt;C++模板是非侵入性设计的基石。通过模板，我们可以编写出独立于任何具体类型的算法和数据结构。这些代码仅对类型提出一组“概念”上的要求（例如，可被复制、可被比较），而非结构上的强制要求。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;std::sort&lt;/code&gt; 算法便是非侵入性的典范。它可以对任何满足其要求的迭代器范围进行排序，而元素类型本身完全无需知晓排序算法的存在。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;示例：为一个无法修改的 &lt;code&gt;Product&lt;/code&gt; 类提供排序能力&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// third_party_library.h - 源码无法修改&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#pragma once&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Product&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Product(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string id, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; price) &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; id_(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(id)), price_(price) {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getId() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; id_; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getPrice&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; price_; } &lt;span style=&#34;color:#75715e&#34;&gt;// 提供一个稳定的公共接口&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string id_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; price_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们无法修改 &lt;code&gt;Product&lt;/code&gt; 类，但我们可以在外部为其添加比较功能。&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘 PingPong Buffer 设计文档</title>
      <link>/posts/-pingpong-buffer-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-pingpong-buffer-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</guid>
      <description>&lt;h1 id=&#34;-pingpong-buffer-设计文档&#34;&gt;📘 PingPong Buffer 设计文档&lt;/h1&gt;&#xA;&lt;h2 id=&#34;一设计目标&#34;&gt;一、设计目标&lt;/h2&gt;&#xA;&lt;p&gt;PingPongBuffer（双缓冲区）旨在解决生产者与消费者异步处理数据时的数据一致性与性能问题。适用于&lt;strong&gt;实时数据传输&lt;/strong&gt;、&lt;strong&gt;中断采集&lt;/strong&gt;、&lt;strong&gt;多线程通信&lt;/strong&gt;等场景，具备如下核心目标：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保证&lt;strong&gt;读写互不干扰&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;支持&lt;strong&gt;高吞吐、低延迟&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;能够应对&lt;strong&gt;速率不匹配&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;可维护、可调试、可扩展&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;二核心设计理念&#34;&gt;二、核心设计理念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-双缓冲结构&#34;&gt;2.1 双缓冲结构&lt;/h3&gt;&#xA;&lt;p&gt;使用两个固定大小的缓冲区 &lt;code&gt;buffer[0]&lt;/code&gt; 和 &lt;code&gt;buffer[1]&lt;/code&gt;，通过索引或标志位控制读写指向不同缓冲区。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Buffer Index&lt;/th&gt;&#xA;          &lt;th&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;write_idx&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;当前写入缓冲区索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;read_idx&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;当前读取缓冲区索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;通过原子操作（或锁）切换这两个缓冲区，实现无锁或低锁竞争的数据交替使用。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;22-原子切换机制&#34;&gt;2.2 原子切换机制&lt;/h3&gt;&#xA;&lt;p&gt;采用 &lt;code&gt;std::atomic&amp;lt;int&amp;gt;&lt;/code&gt; 索引变量配合 &lt;code&gt;memory_order_release/acquire&lt;/code&gt; 保证跨线程或中断的数据可见性与一致性。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;write_idx.store(new_index, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;memory_order_release);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;read_idx.store(old_write_index, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;memory_order_acquire);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h3 id=&#34;23-数据完整性控制&#34;&gt;2.3 数据完整性控制&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;BeginWrite/EndWrite&lt;/code&gt; 和 &lt;code&gt;BeginRead/EndRead&lt;/code&gt; 保障帧级数据完整性&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;frame_valid&lt;/code&gt; 标志位标识 buffer 是否写满可读&lt;/li&gt;&#xA;&lt;li&gt;支持 &lt;code&gt;frame_id&lt;/code&gt;、时间戳等附加信息追踪数据来源及一致性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;三异常与过载处理机制&#34;&gt;三、异常与过载处理机制&lt;/h2&gt;&#xA;&lt;h3 id=&#34;31-生产者快于消费者overrun&#34;&gt;3.1 生产者快于消费者（overrun）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当前写 buffer flip 后，若旧 buffer 尚未消费 → 记录覆盖行为&lt;/li&gt;&#xA;&lt;li&gt;引入 &lt;code&gt;overrun_counter&lt;/code&gt;，并提供异常提示接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;buffer_valid[read_idx]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    overrun_counter&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;32-异常帧检测&#34;&gt;3.2 异常帧检测&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;frame_id&lt;/code&gt; 不连续时提示丢帧&lt;/li&gt;&#xA;&lt;li&gt;时间戳差距过大可认为数据阻塞&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;四状态重置与配置变更&#34;&gt;四、状态重置与配置变更&lt;/h2&gt;&#xA;&lt;p&gt;支持 &lt;code&gt;reset()&lt;/code&gt; 操作，在底层硬件重配置（如分辨率、频率）或系统热切换场景中清空缓冲状态，防止旧数据干扰：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘 现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能</title>
      <link>/posts/-%E7%8E%B0%E4%BB%A3c&#43;&#43;%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-%E7%8E%B0%E4%BB%A3c&#43;&#43;%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD/</guid>
      <description>&lt;h1 id=&#34;现代c中类型擦除技术的全面解析原理模式与性能&#34;&gt;📘现代C++中类型擦除技术的全面解析：原理、模式与性能&lt;/h1&gt;&#xA;&lt;h2 id=&#34;第一部分类型擦除的起源连接静态与动态多态&#34;&gt;第一部分：类型擦除的起源：连接静态与动态多态&lt;/h2&gt;&#xA;&lt;p&gt;本部分旨在阐明[[类型擦除]]技术所解决的根本问题，将其定位为一种旨在克服传统C++[[多态]]技术局限性的高级[[解决方案]]。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-c中的多态困境&#34;&gt;1.1 C++中的多态困境&lt;/h3&gt;&#xA;&lt;p&gt;在C++中，[[多态]]性——即&lt;strong&gt;以统一接口处理不同类型对象的能力&lt;/strong&gt;——是构建灵活、可扩展软件系统的基石。然而，实现多态的传统方法各自存在固有的局限性，这为类型擦除技术的出现提供了动机。&lt;/p&gt;&#xA;&lt;h4 id=&#34;void--方法-c风格多态&#34;&gt;&lt;code&gt;void *&lt;/code&gt; 方法 (C风格多态)&lt;/h4&gt;&#xA;&lt;p&gt;最原始的类型擦除形式是通过 &lt;code&gt;void *&lt;/code&gt; 指针实现的。C标准库中的 &lt;code&gt;qsort&lt;/code&gt; 函数便是典型范例，它能够对任意类型的数组进行排序，正是因为它通过 &lt;code&gt;void *&lt;/code&gt; 接受数据。&lt;/p&gt;&#xA;&lt;p&gt;这种方法的本质在于将任何类型的指针转换为一个通用的、无类型的指针，从而“擦除”了编译时的类型信息。然而，这种极致的灵活性带来了&lt;strong&gt;巨大的代价&lt;/strong&gt;：&lt;strong&gt;类型安全的完全丧失&lt;/strong&gt;。程序员必须承担将 &lt;code&gt;void *&lt;/code&gt; 手动 &lt;code&gt;reinterpret_cast&lt;/code&gt; 回原始正确类型的责任。这是一个极易出错的过程，一旦类型不匹配，便会立即导致未定义行为（[[Undefined Behavior]], UB）。此外，由于[[编译器]]在处理 &lt;code&gt;void *&lt;/code&gt; 时对底层数据类型一无所知，它&lt;strong&gt;无法进行任何有意义的类型驱动优化&lt;/strong&gt;，可能导致&lt;strong&gt;性能下降&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h4 id=&#34;面向对象多态-继承与虚函数&#34;&gt;面向对象多态 (继承与虚函数)&lt;/h4&gt;&#xA;&lt;p&gt;面向对象编程（OOP）提供了C++中实现运行时多态的惯用方法。该方法依赖于一个包含虚函数（virtual functions）的公共基类，各个具体类通过继承该基类并重写虚函数来实现多态行为。&lt;/p&gt;&#xA;&lt;p&gt;这种模式的主要局限性在于其 &lt;strong&gt;侵入性（intrusive）&lt;/strong&gt;。任何希望以多态方式使用的具体类型都 &lt;strong&gt;必须&lt;/strong&gt; 公开继承自这个共同的基类。这在许多场景下是不可行或不理想的，例如，我们无法修改[[标准库类型]]（如 &lt;code&gt;std::string&lt;/code&gt;）、[[内建类型]]（如 &lt;code&gt;int&lt;/code&gt;）或来自第三方库的类型，让它们去继承我们的基类。&lt;/p&gt;&#xA;&lt;p&gt;此外，这种方法存在“类型丢失”问题。当一个派生类对象通过基类引用或指针传递时，编译器在函数内部就“丢失”了该对象的真实类型信息。从编译器的角度看，它只知道这是一个基类对象。这使得某些操作变得异常困难，尤其是多态复制。若要复制一个基类指针指向的对象，必须依赖于额外的样板代码，如 &lt;code&gt;clone()&lt;/code&gt; 虚函数模式，因为无法直接调用派生类的拷贝构造函数。这种设计还会在本不相关的类型之间建立紧密的耦合关系，迫使它们遵从同一个基类接口。&lt;/p&gt;&#xA;&lt;h4 id=&#34;静态多态-模板&#34;&gt;静态多态 (模板)&lt;/h4&gt;&#xA;&lt;p&gt;与运行时多态相对的是静态多态，主要通过C++[[模板]]（[[Templates]]）实现。模板在编译期为每个使用的具体类型生成特化代码，从而保留了完整的类型信息。这使得编译器能够执行深度优化，如函数[[内联]]，从而获得&lt;strong&gt;极高的性能&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;然而，模板的强大能力也伴随着一个核心限制：无法创建 [[异质容器]]（heterogeneous collections）。例如，&lt;code&gt;std::vector&amp;lt;MyClass&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::vector&amp;lt;MyClass&amp;lt;double&amp;gt;&amp;gt;&lt;/code&gt; 是两种完全不同且不相关的类型，它们不能被存储在同一个容器中。为了处理不同类型，编译器会对模板进行“单态化”（monomorphization），为每个类型参数生成一份独立的代码实例，这可能导致最终二进制文件体积膨胀，即所谓的“代码膨胀”（code bloat）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-在现代c语境下定义类型擦除&#34;&gt;1.2 在现代C++语境下定义类型擦除&lt;/h3&gt;&#xA;&lt;p&gt;“类型擦除”这一术语本身在C++社区中存在一定的模糊性，它并非一个单一、被严格定义的语言特性，而是一系列技术和模式的统称 1。广义上，&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;void *&lt;/code&gt; 和继承都可以被视为某种形式的类型擦除。然而，在现代C++的讨论中，尤其是在[[Sean Parent]]和[[Klaus Iglberger]]等专家的影响下，该术语通常指代一种更具体、更强大的设计模式，这也是本报告的核心焦点。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心原则&lt;/strong&gt;：现代C++类型擦除是一种旨在 &lt;strong&gt;将接口与其实现解耦&lt;/strong&gt; 的技术，它为 &lt;strong&gt;不相关的类型&lt;/strong&gt; 提供了 &lt;strong&gt;非侵入式&lt;/strong&gt; 的 &lt;strong&gt;运行时多态&lt;/strong&gt;，同时保持了 &lt;strong&gt;值语义（value semantics）&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>asan</title>
      <link>/posts/asan/</link>
      <pubDate>Thu, 01 Jun 2023 09:30:01 +0800</pubDate>
      <guid>/posts/asan/</guid>
      <description>&lt;script src=&#34;https://gist.github.com/luyoungcn/b544977db493d7016f87ae60c51cc4cd.js&#34;&gt;&lt;/script&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 前向声明与指针使用指南</title>
      <link>/posts/c&#43;&#43;-%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      <guid>/posts/c&#43;&#43;-%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;c++ 为什么有些类属性使用普通的指针定义，而不是使用智能指针&#xA;&lt;code&gt;DogClass *ptr;&lt;/code&gt; 而不是 &lt;code&gt;std::unique_ptr&amp;lt;DogClass&amp;gt; ptr&lt;/code&gt;;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;c-前向声明与指针使用指南&#34;&gt;C++ 前向声明与指针使用指南&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前向声明与不完整类型&#34;&gt;前向声明与不完整类型&lt;/h2&gt;&#xA;&lt;p&gt;在 C++ 中，&lt;strong&gt;前向声明&lt;/strong&gt;（Forward Declaration）允许我们在不包含完整类定义的情况下引用一个类。这对于减少编译依赖和解决循环依赖问题非常有用。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 前向声明示例&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyClass&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 只声明存在性，不提供定义&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，&lt;code&gt;MyClass&lt;/code&gt; 被称为&lt;strong&gt;不完整类型&lt;/strong&gt;（Incomplete Type），因为编译器只知道该类存在，但不知道它的大小、成员或方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;stdunique_ptr-与不完整类型&#34;&gt;std::unique_ptr 与不完整类型&lt;/h2&gt;&#xA;&lt;p&gt;当使用 &lt;code&gt;std::unique_ptr&lt;/code&gt; 管理前向声明类的对象时，会出现问题：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 头文件中&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyForwardDeclaredClass&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 前向声明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Container&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;MyForwardDeclaredClass&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ptr_; &lt;span style=&#34;color:#75715e&#34;&gt;// 编译错误!&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码在编译时会失败，错误类似于：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;error: invalid application of &amp;#39;sizeof&amp;#39; to incomplete type &amp;#39;MyForwardDeclaredClass&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;原因分析&#34;&gt;原因分析&lt;/h3&gt;&#xA;&lt;p&gt;这个问题出现的原因是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; 的析构函数需要知道如何删除它管理的对象&lt;/li&gt;&#xA;&lt;li&gt;为此，编译器需要在编译 &lt;code&gt;Container&lt;/code&gt; 类时知道 &lt;code&gt;MyForwardDeclaredClass&lt;/code&gt; 的完整定义&lt;/li&gt;&#xA;&lt;li&gt;当编译器尝试计算不完整类型的 &lt;code&gt;sizeof&lt;/code&gt; 时，无法确定其大小，因此报错&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;具体来说，&lt;code&gt;std::unique_ptr&lt;/code&gt; 的默认删除器 &lt;code&gt;std::default_delete&lt;/code&gt; 在析构时会执行：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;default_delete&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ptr) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static_assert&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(T) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Type must be complete&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt; ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当类型不完整时，&lt;code&gt;sizeof(T)&lt;/code&gt; 无法计算，触发 &lt;code&gt;static_assert&lt;/code&gt; 失败。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

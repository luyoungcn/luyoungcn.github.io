<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cpp on LuyangのBlog</title>
    <link>/tags/cpp/</link>
    <description>Recent content in Cpp on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Sun, 13 Jul 2025 02:30:00 +0800</lastBuildDate>
    <atom:link href="/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>📘 bin 文件内容特征与编辑器打开模式行为分析</title>
      <link>/posts/bin-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%89%B9%E5%BE%81%E4%B8%8E%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 13 Jul 2025 02:30:00 +0800</pubDate>
      <guid>/posts/bin-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%89%B9%E5%BE%81%E4%B8%8E%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;-bin-文件内容特征与编辑器打开模式行为分析&#34;&gt;📘 bin 文件内容特征与编辑器打开模式行为分析&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;—— 以 UltraEdit 和二进制数据结构为案例剖析&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;一背景与问题现象&#34;&gt;一、背景与问题现象&lt;/h2&gt;&#xA;&lt;p&gt;在使用 [[UltraEdit]]、HxD、VSCode 等文本或十六进制编辑器查看 &lt;code&gt;.bin&lt;/code&gt; 文件时，经常会遇到以下现象：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有些 &lt;code&gt;.bin&lt;/code&gt; 文件一打开就是 &lt;strong&gt;十六进制视图&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;有些 &lt;code&gt;.bin&lt;/code&gt; 文件却被当作 &lt;strong&gt;普通文本文件显示&lt;/strong&gt;，看到一堆“乱码”或 ASCII 字符&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这种行为并不是 bug，而是由&lt;strong&gt;编辑器的智能判断逻辑&lt;/strong&gt;所决定的。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;二bin-文件的本质&#34;&gt;二、bin 文件的本质&lt;/h2&gt;&#xA;&lt;h3 id=&#34;-bin-是什么&#34;&gt;✅ bin 是什么？&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;.bin&lt;/code&gt; 文件本质是“&lt;strong&gt;原始二进制数据的连续存储&lt;/strong&gt;”，不包含结构定义、元数据或格式头。&lt;/p&gt;&#xA;&lt;p&gt;特点如下：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;特性&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;原始性&lt;/td&gt;&#xA;          &lt;td&gt;没有文件头、格式标记、符号等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;结构透明性&lt;/td&gt;&#xA;          &lt;td&gt;实际含义需由上下文或程序代码解析（结构体/位图等）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;广泛用途&lt;/td&gt;&#xA;          &lt;td&gt;存储固件、配置段、内存转储、Flash 镜像、资源文件等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;三ultraedit-打开-bin-文件的模式判断机制&#34;&gt;三、UltraEdit 打开 bin 文件的“模式判断机制”&lt;/h2&gt;&#xA;&lt;h3 id=&#34;-默认逻辑推测自长期使用&#34;&gt;📌 默认逻辑（推测自长期使用）&lt;/h3&gt;&#xA;&lt;p&gt;UltraEdit 在打开 &lt;code&gt;.bin&lt;/code&gt; 文件时，会根据&lt;strong&gt;文件内容前若干字节&lt;/strong&gt;来判断：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;是否为“文本”文件&lt;/strong&gt;（显示为 ASCII）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;是否为“二进制”文件&lt;/strong&gt;（启用十六进制编辑模式）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;-判断依据经验总结&#34;&gt;🚦 判断依据（经验总结）：&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;条件&lt;/th&gt;&#xA;          &lt;th&gt;UltraEdit 默认行为&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;文件前几个字节大部分为 ASCII 可打印字符（0x20~0x7E）&lt;/td&gt;&#xA;          &lt;td&gt;默认以 &lt;strong&gt;文本模式&lt;/strong&gt; 打开&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;包含大量控制字符或不可打印字节（0x00、0xFF、0x80~）&lt;/td&gt;&#xA;          &lt;td&gt;默认以 &lt;strong&gt;十六进制模式&lt;/strong&gt; 打开&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;-举例说明&#34;&gt;📌 举例说明：&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;文件内容（前几字节）&lt;/th&gt;&#xA;          &lt;th&gt;UltraEdit 行为&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;41 42 43 0A 44 45&lt;/code&gt;（ASCII: &amp;ldquo;ABC\nDE&amp;rdquo;）&lt;/td&gt;&#xA;          &lt;td&gt;文本模式（ASCII 显示）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;00 FF 80 1F CD AB&lt;/code&gt;（含非打印字节）&lt;/td&gt;&#xA;          &lt;td&gt;十六进制模式&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;四演示-demo实验证明&#34;&gt;四、演示 Demo（实验证明）&lt;/h2&gt;&#xA;&lt;p&gt;我们设计了一个简洁的 Demo 程序，生成两个 &lt;code&gt;.bin&lt;/code&gt; 文件：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘 深入理解 ZeroMQ 异步连接与 REQ 消息堆积行为</title>
      <link>/posts/-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-zeromq-%E5%BC%82%E6%AD%A5%E8%BF%9E%E6%8E%A5%E4%B8%8E-req-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E8%A1%8C%E4%B8%BA/</link>
      <pubDate>Tue, 08 Jul 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-zeromq-%E5%BC%82%E6%AD%A5%E8%BF%9E%E6%8E%A5%E4%B8%8E-req-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E8%A1%8C%E4%B8%BA/</guid>
      <description>&lt;h1 id=&#34;-深入理解-zeromq-异步连接与-req-消息堆积行为&#34;&gt;📘 深入理解 ZeroMQ 异步连接与 REQ 消息堆积行为&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-文档概览&#34;&gt;✨ 文档概览&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;章节&lt;/th&gt;&#xA;          &lt;th&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1. 简介&lt;/td&gt;&#xA;          &lt;td&gt;ZeroMQ &lt;code&gt;connect()&lt;/code&gt; 行为误区&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2. 异步连接机制&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;connect()&lt;/code&gt; 实现原理与延迟连接&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;3. REQ socket 特性&lt;/td&gt;&#xA;          &lt;td&gt;REQ 的 FSM 状态机与堆积陷阱&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;4. 内存增长问题分析&lt;/td&gt;&#xA;          &lt;td&gt;实例重现与底层解释&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;5. 如何规避问题&lt;/td&gt;&#xA;          &lt;td&gt;参数设置、代码优化方案&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;6. 替代方案&lt;/td&gt;&#xA;          &lt;td&gt;使用 DEALER 替代 REQ 的可行性&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;7. 源码分析&lt;/td&gt;&#xA;          &lt;td&gt;ZeroMQ 源码路径与关键组件说明&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;8. 附录与参考资料&lt;/td&gt;&#xA;          &lt;td&gt;官方文献、工具、命令等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1--简介为什么连接成功了服务端却没起来&#34;&gt;1. 🔰 简介：为什么连接成功了服务端却没起来？&lt;/h2&gt;&#xA;&lt;p&gt;当你调用如下代码时：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;zmq&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;socket_t socket(context, zmq&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;socket_type&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;req);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;socket.connect(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tcp://127.0.0.1:5555&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LogInfo(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Socket connected to endpoint&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可能会误以为服务端已经在线并成功连接。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;这是一个常见误区。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;-正确理解&#34;&gt;✅ 正确理解：&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt; 只是将目标 endpoint 添加到内部连接目标列表中，并不会立即发起 TCP 连接或等待对端响应。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这是 ZeroMQ 异步非阻塞通信模型的特性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌CMake 现代化配置完整指南</title>
      <link>/posts/cmake-%E7%8E%B0%E4%BB%A3%E5%8C%96%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 29 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/cmake-%E7%8E%B0%E4%BB%A3%E5%8C%96%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;h1 id=&#34;cmake-现代化配置完整指南&#34;&gt;CMake 现代化配置完整指南&lt;/h1&gt;&#xA;&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE&#34;&gt;项目基础配置&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#c-%E7%BC%96%E8%AF%91%E6%A0%87%E5%87%86%E8%AE%BE%E7%BD%AE&#34;&gt;C++ 编译标准设置&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%AF%91%E5%99%A8%E9%80%89%E9%A1%B9%E4%B8%8E%E8%AD%A6%E5%91%8A%E9%85%8D%E7%BD%AE&#34;&gt;编译器选项与警告配置&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%BE%93%E5%87%BA%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%AE%A1%E7%90%86&#34;&gt;输出目录结构管理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE&#34;&gt;环境检测与路径配置&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86&#34;&gt;第三方依赖管理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%9B%AE%E6%A0%87%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7&#34;&gt;目标链接与可见性&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2&#34;&gt;安装配置与部署&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87&#34;&gt;自定义构建目标&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE&#34;&gt;完整示例项目&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;项目基础配置&#34;&gt;项目基础配置&lt;/h2&gt;&#xA;&lt;h3 id=&#34;最小版本要求与项目声明&#34;&gt;最小版本要求与项目声明&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cmake&#34; data-lang=&#34;cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cmake_minimum_required(&lt;span style=&#34;color:#e6db74&#34;&gt;VERSION&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;3.14&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;project(&lt;span style=&#34;color:#e6db74&#34;&gt;VisionDemo&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;VERSION&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;1.0.0&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;LANGUAGES&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;CXX&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;cmake_minimum_required&lt;/code&gt;：指定所需的最低CMake版本&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;project&lt;/code&gt;：定义项目名称、版本号和使用的语言&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;VERSION&lt;/code&gt;：设置项目版本，可通过 &lt;code&gt;${PROJECT_VERSION}&lt;/code&gt; 引用&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;LANGUAGES&lt;/code&gt;：明确指定使用的编程语言&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;c-编译标准设置&#34;&gt;C++ 编译标准设置&lt;/h2&gt;&#xA;&lt;h3 id=&#34;全局标准设置&#34;&gt;全局标准设置&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cmake&#34; data-lang=&#34;cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 设置 C++17 标准&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;set(&lt;span style=&#34;color:#e6db74&#34;&gt;CMAKE_CXX_STANDARD&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;17&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;set(&lt;span style=&#34;color:#e6db74&#34;&gt;CMAKE_CXX_STANDARD_REQUIRED&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;ON&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;set(&lt;span style=&#34;color:#e6db74&#34;&gt;CMAKE_CXX_EXTENSIONS&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;OFF&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;各参数含义：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;参数&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;CMAKE_CXX_STANDARD&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;指定C++标准版本&lt;/td&gt;&#xA;          &lt;td&gt;告诉编译器使用哪个C++标准（如17、20、23）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;CMAKE_CXX_STANDARD_REQUIRED&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;强制要求指定标准&lt;/td&gt;&#xA;          &lt;td&gt;ON：编译器必须支持指定标准，否则报错&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;CMAKE_CXX_EXTENSIONS&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;禁用编译器扩展&lt;/td&gt;&#xA;          &lt;td&gt;OFF：使用纯标准C++，提高跨平台兼容性&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;&lt;strong&gt;编译器参数映射：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GCC/Clang: &lt;code&gt;-std=c++17&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;MSVC: &lt;code&gt;/std:c++17&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;针对特定目标的标准设置&#34;&gt;针对特定目标的标准设置&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cmake&#34; data-lang=&#34;cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set_target_properties(&lt;span style=&#34;color:#e6db74&#34;&gt;VisionDemo&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;PROPERTIES&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;CXX_STANDARD&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;17&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;CXX_STANDARD_REQUIRED&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;ON&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#e6db74&#34;&gt;CXX_EXTENSIONS&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;OFF&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;项目中不同目标需要不同的C++标准&lt;/li&gt;&#xA;&lt;li&gt;明确指定某个目标的编译标准&lt;/li&gt;&#xA;&lt;li&gt;覆盖全局设置&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;编译器选项与警告配置&#34;&gt;编译器选项与警告配置&lt;/h2&gt;&#xA;&lt;h3 id=&#34;全局编译选项&#34;&gt;全局编译选项&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cmake&#34; data-lang=&#34;cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;if(&lt;span style=&#34;color:#e6db74&#34;&gt;CMAKE_CXX_COMPILER_ID&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;MATCHES&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GNU|Clang&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    add_compile_options(&lt;span style=&#34;color:#e6db74&#34;&gt;-Wall&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;-Wextra&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;-Wpedantic&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;endif()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;目标特定编译选项推荐&#34;&gt;目标特定编译选项（推荐）&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cmake&#34; data-lang=&#34;cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;if(&lt;span style=&#34;color:#e6db74&#34;&gt;CMAKE_CXX_COMPILER_ID&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;MATCHES&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;GNU|Clang&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;    target_compile_options(&lt;span style=&#34;color:#e6db74&#34;&gt;VisionDemo&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;PRIVATE&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;-Wall&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;-Wextra&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;-Wpedantic&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;-Wno-unused-parameter&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;-Wno-unused-variable&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    )&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;endif()&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;编译选项说明：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘ThreadLocal 全面解析</title>
      <link>/posts/-threadlocal-%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 24 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-threadlocal-%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;The beauty of open source is that it is technically borderless. &amp;mdash; &lt;a href=&#34;https://www.reddit.com/user/AlterTableUsernames/&#34;&gt;u/AlterTableUsernames&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;threadlocal-全面解析&#34;&gt;ThreadLocal 全面解析&lt;/h2&gt;&#xA;&lt;p&gt;在多线程并发编程中，保证线程安全是开发者必须面对的核心挑战之一。&lt;code&gt;ThreadLocal&lt;/code&gt; 作为 Java 提供的一种独特的线程同步解决方案，它另辟蹊径，通过为每个线程提供变量的独立副本，巧妙地避免了多线程间的数据共享和竞争，从而实现了线程安全。本文将从 &lt;code&gt;ThreadLocal&lt;/code&gt; 的基本概念入手，深入剖析其源码实现，探讨其在 C++ 中的对应方案，并结合常见的面试题，为您全方位揭示 &lt;code&gt;ThreadLocal&lt;/code&gt; 的奥秘，包括其精妙的弱引用设计以及潜在的内存泄漏风险。&lt;/p&gt;&#xA;&lt;h3 id=&#34;threadlocal-简介&#34;&gt;ThreadLocal 简介&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;，顾名思义，即“线程局部变量”。它提供了一种创建变量的机制，该变量对于访问它的每个线程都有其自己独立的、初始化的副本。换言之，如果您在主线程中创建了一个 &lt;code&gt;ThreadLocal&lt;/code&gt; 变量，那么在其他任何线程中，都无法直接访问主线程中该变量的值，而是会拥有并操作属于自己线程的那个变量的副本。&lt;/p&gt;&#xA;&lt;p&gt;这种“空间换时间”的策略，核心思想是隔离而非同步。与使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字或 &lt;code&gt;Lock&lt;/code&gt; 锁等同步机制来保护共享资源不同，&lt;code&gt;ThreadLocal&lt;/code&gt; 直接杜绝了资源共享的可能性，从而在根本上避免了线程间的竞争和同步开销。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心应用场景：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;每个线程需要一个独立的实例&lt;/strong&gt;：例如，&lt;code&gt;SimpleDateFormat&lt;/code&gt; 在多线程环境下是非线程安全的。通过 &lt;code&gt;ThreadLocal&lt;/code&gt; 为每个线程创建一个 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 实例，可以有效避免并发问题。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;维护线程上下文信息&lt;/strong&gt;：在复杂的业务逻辑调用链中，为了避免在每个方法参数中都传递用户信息、事务 ID 等上下文信息，可以使用 &lt;code&gt;ThreadLocal&lt;/code&gt; 在线程生命周期内持有这些信息，方便在调用链的任何位置随时获取。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据库连接管理&lt;/strong&gt;：在服务层和数据访问层之间，可以通过 &lt;code&gt;ThreadLocal&lt;/code&gt; 来管理每个线程的数据库连接，确保同一个线程中的多次数据库操作使用的是同一个连接，从而保证事务的一致性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;源码实现讲解&#34;&gt;源码实现讲解&lt;/h3&gt;&#xA;&lt;p&gt;要真正理解 &lt;code&gt;ThreadLocal&lt;/code&gt; 的工作原理，必须深入其源码。&lt;code&gt;ThreadLocal&lt;/code&gt; 的核心在于其内部类 &lt;code&gt;ThreadLocalMap&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心关系图：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn-0.plantuml.com/plantuml/png/PLHHRzj637xNh-3qKhkBjVRL28m6Iu4LQxkXoR27PO0fcRQlFjq9TvHJRzX_7u-IaelwalZ8Zny_ygFzBZ86xbjRl89RWuU0BTmRjbHm-Wltnq2uknh_V_GDsYj0jyi3dx23BsIHZNVnQBf2kEvEna67GaTC8SBU1q1eBA43w_sfY0BGl0GnnXlcOEgUwKFZtPtvX-1D1h764Lyw0X_uw1F_pwa8RcbldD6-HQ4yeoxujm3u4VXPP5pdagkNyel_fl8oIrpVRqh0cDUDl0VYnL88zH7bSKRRamGaUFPcf_50hJ_JOWf9YmwR4nu8ogzunigYEvHAE2dF9Ma2O0MCjHNgzux3vQ-_9IX4KqcfqHBe6vFRoVjFmjCNsbCWrz1rnhWPEYLTezRVwg_KiF8zJN-BZ8ghAlWZKbZ5ZXgpDmti92FH19Njvsv7FOUR67rZXc12t4n67362TmIpXO_Pycq9hrShADzKbNoShM0DZNUCHYddoIa5RM_PT9Q65O7NkM8nWpzrUbjLhyi1cpK0T80XeDJlLRyR8AyYdEW2HW3mOhd07Z3N1CB2A9bYrB5QRRHhZbahso8nmHFLSjPG3HfQtd7mxW0lklAH01lkqQehuy1ZrwcfEhaUgHOp6kquqyuKX3J2e-6ZjcZw85WUOMgouJZtCIUfgis4NaCVQG9N8zNmMYpdHT_RxZjHmvGkH-_jivU7IdZ_hRFefZjp4eTW3aSMsuRz5G3NzURNjEMCTZavcE-zklwftXGWxLFIMlyOTVAiRbnkMdjD0ZrWgF50q7Xh9KwoapqO5jES1oixfW1Xujz90Tb8ZqTvNq4Nw4oEZJle5sBuFTj3IwqNuwn8gmgI4TDGusYbZFAxvrI55ZuDo8-2_259Vt0VzZF1prS89dwlzahXUj1EFmv7KrFZMugmTRsrs-h1_U8VHMiOu5izeYqiqatf8YCRQo7gKTbBDZ3KbsVQwaaVgpwfr1Mjh3aBT67DYP8EdFATztQfBc-dtyvjAdAUGKQpel_12Lya86bWQBpMf3eDbPxo2PkcRtkBJCgLZJ2wEU2KjYRO1r9YAnAID_gzpaqf0QCk_RCQCwoigfv3xyIrlhN_0m00&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;每个 &lt;code&gt;Thread&lt;/code&gt; 对象内部都有一个 &lt;code&gt;threadLocals&lt;/code&gt; 成员变量，其类型就是 &lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;。也就是说，&lt;code&gt;ThreadLocalMap&lt;/code&gt; 实际上是 &lt;code&gt;Thread&lt;/code&gt; 的一个属性，而不是 &lt;code&gt;ThreadLocal&lt;/code&gt; 的。当调用 &lt;code&gt;ThreadLocal&lt;/code&gt; 的 &lt;code&gt;set(T value)&lt;/code&gt; 或 &lt;code&gt;get()&lt;/code&gt; 方法时，&lt;code&gt;ThreadLocal&lt;/code&gt; 会首先获取当前线程的 &lt;code&gt;ThreadLocalMap&lt;/code&gt;，然后以 &lt;code&gt;ThreadLocal&lt;/code&gt; 实例自身作为 key，进行值的存取。&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘深入解析 Java 线程本地化：从 ThreadLocal 到 ScopedValue 的演进与选择</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-java-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8C%96%E4%BB%8E-threadlocal-%E5%88%B0-scopedvalue-%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E9%80%89%E6%8B%A9/</link>
      <pubDate>Tue, 24 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-java-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8C%96%E4%BB%8E-threadlocal-%E5%88%B0-scopedvalue-%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E9%80%89%E6%8B%A9/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;The beauty of open source is that it is technically borderless. &amp;mdash; &lt;a href=&#34;https://www.reddit.com/user/AlterTableUsernames/&#34;&gt;u/AlterTableUsernames&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;深入解析-java-线程本地化从-threadlocal-到-scopedvalue-的演进与选择&#34;&gt;深入解析 Java 线程本地化：从 ThreadLocal 到 ScopedValue 的演进与选择&lt;/h2&gt;&#xA;&lt;h3 id=&#34;摘要&#34;&gt;摘要&lt;/h3&gt;&#xA;&lt;p&gt;在 Java 服务端开发中，将贯穿单次业务流程的上下文信息（如用户身份、分布式追踪ID）在线程内部进行传递，是一项基础且关键的需求。为应对这一挑战，Java 提供了经典的 &lt;code&gt;ThreadLocal&lt;/code&gt; 机制，它通过巧妙地将数据与执行线程绑定，实现了高效的无锁化数据隔离。然而，这一经典方案如同一把双刃剑：其精巧的设计背后，是充满陷阱的无界生命周期、难以追踪的可变性，以及在现代线程池模型下极易触发的内存泄漏风险。&lt;/p&gt;&#xA;&lt;p&gt;随着 Project Loom 计划的成熟，Java 并发编程正经历一场深刻的范式革命。虚拟线程（Virtual Threads）的引入，使得 &lt;code&gt;InheritableThreadLocal&lt;/code&gt; 的继承成本变得不可接受；而结构化并发（Structured Concurrency）的提出，则呼唤一种更安全、更具确定性的上下文传递机制。在此背景下，&lt;code&gt;ScopedValue&lt;/code&gt; 应运而生。它并非 &lt;code&gt;ThreadLocal&lt;/code&gt; 的简单改良，而是从设计哲学上对线程本地数据的一次重塑，用“动态作用域”的不可变绑定，取代了“线程寄生”的可变状态。&lt;/p&gt;&#xA;&lt;p&gt;本文将对 Java 的线程本地化技术进行一次从经典到现代的完整、深入的探索。我们将首先解构 &lt;code&gt;ThreadLocal&lt;/code&gt; 的内部架构，详尽剖析其 &lt;code&gt;Thread-ThreadLocalMap-ThreadLocal&lt;/code&gt; 的委托关系模型，并对其“弱引用Key-强引用Value”等关键设计决策背后的深层思辨进行论证。接着，我们将聚焦于 &lt;code&gt;InheritableThreadLocal&lt;/code&gt; 在线程池和虚拟线程时代下的困境与宿怨。随后，文章将全面转向 &lt;code&gt;ScopedValue&lt;/code&gt;，将其作为面向未来的解决方案，重点阐述其与结构化并发如何天作之合般地解决了数据自动、安全、高效传播的核心难题。最后，本文通过一场涉及正确性、性能与心智模型的全方位对决，为开发者在技术演进的浪潮中做出明智选择提供坚实的理论依据。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;第一章-threadlocal---一个设计精巧而又充满陷阱的经典&#34;&gt;第一章: &lt;code&gt;ThreadLocal&lt;/code&gt; - 一个设计精巧而又充满陷阱的经典&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 的核心使命是在多线程环境下，为每个线程提供一个专属的数据存储空间，从而实现线程级别的数据隔离。它让开发者感觉好像在使用一个普通的全局变量，但实际上每个线程操作的都是自己的独立副本。&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-核心架构委托与寄生的艺术&#34;&gt;1.1 核心架构：委托与寄生的艺术&lt;/h4&gt;&#xA;&lt;p&gt;要理解 &lt;code&gt;ThreadLocal&lt;/code&gt;，首先必须破除一个误解：数据并非存储在 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象本身。&lt;code&gt;ThreadLocal&lt;/code&gt; 实例扮演的是一个“访问工具”或“代理”的角色，真正的存储发生在执行线程 &lt;code&gt;Thread&lt;/code&gt; 对象的内部。这种关系可以被理解为一种巧妙的“委托”或“寄生”模型。&lt;/p&gt;&#xA;&lt;p&gt;它们之间的关系如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Thread&lt;/code&gt; 对象&lt;/strong&gt;: 线程的实体。每个 &lt;code&gt;Thread&lt;/code&gt; 实例内部都有一个 &lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt; 类型的成员变量 &lt;code&gt;threadLocals&lt;/code&gt;。这个 Map 是惰性创建的，只在线程首次需要存储 &lt;code&gt;ThreadLocal&lt;/code&gt; 数据时才被实例化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;ThreadLocal&lt;/code&gt; 的一个内部静态类，是一个为 &lt;code&gt;ThreadLocal&lt;/code&gt; 量身定制的、非通用的哈希表。它才是真正存储数据的容器，其所有权完全归属于 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 对象&lt;/strong&gt;: 它在整个体系中是“定位键”和“访问入口”。你的代码通过调用 &lt;code&gt;ThreadLocal&lt;/code&gt; 实例的 &lt;code&gt;set()&lt;/code&gt; 或 &lt;code&gt;get()&lt;/code&gt; 方法来操作数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;用户数据 (e.g., &lt;code&gt;RequestData&lt;/code&gt;)&lt;/strong&gt;: 期望在线程内共享的业务数据，作为“值”被存储。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;一次 &lt;code&gt;set&lt;/code&gt; 操作的完整轨迹&lt;/strong&gt;:&#xA;当 &lt;code&gt;CONTEXT.set(data)&lt;/code&gt; 被调用时：&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入 C&#43;&#43; 的隐秘角落：彻底解析参数依赖查找 (ADL)</title>
      <link>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E7%9A%84%E9%9A%90%E7%A7%98%E8%A7%92%E8%90%BD%E5%BD%BB%E5%BA%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE-adl/</link>
      <pubDate>Mon, 23 Jun 2025 00:00:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E7%9A%84%E9%9A%90%E7%A7%98%E8%A7%92%E8%90%BD%E5%BD%BB%E5%BA%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE-adl/</guid>
      <description>&lt;h1 id=&#34;深入-c-的隐秘角落彻底解析参数依赖查找-adl&#34;&gt;深入 C++ 的隐秘角落：彻底解析参数依赖查找 (ADL)&lt;/h1&gt;&#xA;&lt;p&gt;在 C++ 的世界里，有些特性如同空气，无处不在，默默地支撑着我们代码的优雅与简洁，但我们却很少去探究其背后的原理。&lt;code&gt;std::cout &amp;lt;&amp;lt; &amp;quot;Hello, World!&amp;quot;;&lt;/code&gt; 这行代码对于每个 C++ 开发者来说都再熟悉不过。但是，你是否曾停下来想过，&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 函数明明定义在 &lt;code&gt;std&lt;/code&gt; 命名空间中，为什么我们在调用它时，并不需要写成 &lt;code&gt;std::operator&amp;lt;&amp;lt;(std::cout, &amp;quot;Hello, World!&amp;quot;);&lt;/code&gt; 这种冗长繁琐的形式？&lt;/p&gt;&#xA;&lt;p&gt;这个问题的答案，就隐藏在 C++ 语言一个强大而又微妙的机制中——&lt;strong&gt;参数依赖查找（Argument-Dependent Lookup）&lt;/strong&gt;，通常被缩写为 &lt;strong&gt;ADL&lt;/strong&gt;。它还有一个广为人知的名字，叫 &lt;strong&gt;Koenig 查找（Koenig Lookup）&lt;/strong&gt;，以其发现者 Andrew Koenig 的名字命名。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Scott_Meyers.jpg/500px-Scott_Meyers.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;ADL 是 C++ 名称查找规则的重要组成部分。它极大地提升了泛型编程和操作符重载的可用性，使得代码更符合人类的直觉。然而，它也是一柄双刃剑，如果不了解其工作原理，有时会导致一些令人困惑的编译错误或意想不到的行为。&lt;/p&gt;&#xA;&lt;p&gt;这篇超过5000字的长文，将作为一份详尽的指南，带你拨开 ADL 的层层迷雾。我们将从没有 ADL 的世界开始，逐步揭示 ADL 的核心机制、详细规则、与模板和“隐藏友元”等现代 C++ 技术的协同工作，并最终探讨如何规避其带来的陷阱，编写出更健壮、更可维护的 C++ 代码。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;第一章：前 ADL 时代 —— 常规的无限定名称查找&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.1 名称查找的基本原则&lt;/li&gt;&#xA;&lt;li&gt;1.2 命名空间带来的挑战&lt;/li&gt;&#xA;&lt;li&gt;1.3 没有 ADL 的代码之痛&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;第二章：ADL 的诞生与核心机制&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2.1 ADL 的正式定义&lt;/li&gt;&#xA;&lt;li&gt;2.2 关键概念：关联命名空间 (Associated Namespaces)&lt;/li&gt;&#xA;&lt;li&gt;2.3 两阶段查找的协作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;第三章：深入 ADL 的规则与细节&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌深入 C&#43;&#43; 单例模式：原理、实现方式对比与 shared_ptr 架构设计</title>
      <link>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8E-shared_ptr-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 06 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5-c&#43;&#43;-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E4%B8%8E-shared_ptr-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;h1 id=&#34;深入-c-单例模式原理实现方式对比与-shared_ptr-架构设计&#34;&gt;📌深入 C++ 单例模式：原理、实现方式对比与 shared_ptr 架构设计&lt;/h1&gt;&#xA;&lt;h2 id=&#34;1-什么是单例基本语义与使用场景&#34;&gt;1️⃣ 什么是单例？基本语义与使用场景&lt;/h2&gt;&#xA;&lt;p&gt;单例（[[Singleton]]）是对象创建模式中最常见的一种，其目标是确保类在系统中&lt;strong&gt;只有一个实例&lt;/strong&gt;，并提供全局访问入口。&lt;/p&gt;&#xA;&lt;h3 id=&#34;-常见使用场景&#34;&gt;✅ 常见使用场景：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;配置中心（ConfigManager）&lt;/li&gt;&#xA;&lt;li&gt;日志系统（Logger）&lt;/li&gt;&#xA;&lt;li&gt;资源池（如内存池、线程池）&lt;/li&gt;&#xA;&lt;li&gt;调度器、会话管理器&lt;/li&gt;&#xA;&lt;li&gt;框架注册表、插件系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-单例的五种常见实现方式&#34;&gt;2️⃣ 单例的五种常见实现方式&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;推荐使用方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;懒汉式 + 线程安全（C++11 标准）局部静态变量（Meyers Singleton）&amp;mdash; 【推荐使用】&lt;/li&gt;&#xA;&lt;li&gt;shared_ptr 单例（更灵活）&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;1-饿汉式单例early-instantiation&#34;&gt;🍃1. 饿汉式单例（Early Instantiation）&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; instance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Singleton Singleton&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 简单易懂，线程安全（由 C++ 静态对象初始化保障）&lt;/li&gt;&#xA;&lt;li&gt;❌ 资源可能浪费，程序启动就构造实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2-懒汉式lazy-initialization-非线程安全&#34;&gt;🍃2. 懒汉式（Lazy Initialization）+ 非线程安全&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;instance_)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            instance_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Singleton;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; instance_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Singleton&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;instance_ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 仅在需要时创建实例&lt;/li&gt;&#xA;&lt;li&gt;❌ 非线程安全，多个线程可能同时构造多个实例&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-懒汉式--线程安全c11-标准局部静态变量meyers-singleton-推荐使用&#34;&gt;🍃3. 懒汉式 + 线程安全（C++11 标准）局部静态变量（Meyers Singleton）&amp;mdash; 【推荐使用】&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; instance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton inst;  &lt;span style=&#34;color:#75715e&#34;&gt;// C++11 保证线程安全&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; inst;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;✅ 推荐使用：线程安全、懒加载、无锁开销&lt;/li&gt;&#xA;&lt;li&gt;✅ 析构自动管理，依赖 C++ 静态局部变量特性&lt;/li&gt;&#xA;&lt;li&gt;❗ 禁止拷贝构造、赋值运算，防止实例复制&lt;/li&gt;&#xA;&lt;li&gt;✅ 最简洁、安全、高效的方式（默认推荐）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;后面会有这种方式的语法语义与底层源码解析&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌 C&#43;&#43;类成员函数 static 与 const 的声明与定义规则解析</title>
      <link>/posts/-c&#43;&#43;-%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static-%E4%B8%8E-const-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-c&#43;&#43;-%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static-%E4%B8%8E-const-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;-c类成员函数static-与-const-的声明与定义规则解析&#34;&gt;📌 C++类成员函数：&lt;code&gt;static&lt;/code&gt; 与 &lt;code&gt;const&lt;/code&gt; 的声明与定义规则解析&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;为什么头文件声明要写 &lt;code&gt;static/const&lt;/code&gt;，而实现时 &lt;code&gt;static&lt;/code&gt; 要省略、&lt;code&gt;const&lt;/code&gt; 必须保留？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;-核心规则对比表&#34;&gt;🔍 核心规则对比表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;strong&gt;关键字&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;头文件（.h）声明&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;源文件（.cpp）定义&lt;/strong&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;strong&gt;底层原因&lt;/strong&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;&lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;必须显式声明：&lt;code&gt;static void func();&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;strong&gt;禁止重复&lt;/strong&gt;：直接写 &lt;code&gt;void Class::func()&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;static&lt;/code&gt; 标识函数归属类而非对象；定义时 &lt;code&gt;ClassName::&lt;/code&gt; 已隐含作用域，再写 &lt;code&gt;static&lt;/code&gt; 会被解释为文件作用域函数，破坏封装性。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;strong&gt;&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td&gt;必须显式声明：&lt;code&gt;int get() const;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;strong&gt;必须保留&lt;/strong&gt;：&lt;code&gt;int Class::get() const&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;const&lt;/code&gt; 是函数签名的一部分，声明与定义必须严格一致，否则编译器视为不同函数，导致链接错误。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-一static-关键字的声明与定义分离&#34;&gt;⚙️ 一、&lt;code&gt;static&lt;/code&gt; 关键字的声明与定义分离&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-声明时需&#34;&gt;1. &lt;strong&gt;声明时需 &lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在头文件中，&lt;code&gt;static&lt;/code&gt; 明确标识该函数是&lt;strong&gt;类级别共享&lt;/strong&gt;的，不依赖对象实例（无 &lt;code&gt;this&lt;/code&gt; 指针）：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// MyClass.h&#xA;class MyClass {&#xA;public:&#xA;    static void sharedFunc(); // ✅ 声明为静态&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2-定义时禁止&#34;&gt;2. &lt;strong&gt;定义时禁止 &lt;code&gt;static&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在源文件中，&lt;code&gt;ClassName::&lt;/code&gt; 已指明函数归属类作用域。若添加 &lt;code&gt;static&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;会被编译器解释为&lt;strong&gt;文件作用域的静态函数&lt;/strong&gt;（仅当前 &lt;code&gt;.cpp&lt;/code&gt; 可见）；&lt;/li&gt;&#xA;&lt;li&gt;导致无法通过 &lt;code&gt;MyClass::sharedFunc()&lt;/code&gt; 全局访问，破坏封装性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;✅ 正确写法：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌小对象优化（Small Object Optimization）深度解析：C&#43;&#43;容器的性能利器</title>
      <link>/posts/%E5%B0%8F%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96small-object-optimization%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90c&#43;&#43;%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%A9%E5%99%A8/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E5%B0%8F%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96small-object-optimization%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90c&#43;&#43;%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%A9%E5%99%A8/</guid>
      <description>&lt;h1 id=&#34;小对象优化small-object-optimization深度解析c容器的性能利器&#34;&gt;小对象优化（Small Object Optimization）深度解析：C++容器的性能利器&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在现代C++开发中，&lt;code&gt;std::string&lt;/code&gt;和&lt;code&gt;std::vector&lt;/code&gt;等标准容器的高效性往往被开发者视为理所当然。然而，这些容器在处理小对象时的卓越性能背后，隐藏着一项重要的优化技术——&lt;strong&gt;小对象优化（Small Object Optimization, SOO）&lt;/strong&gt;。对于追求高性能的C++开发者而言，理解SOO的工作原理不仅有助于编写更高效的代码，更能启发我们在设计自定义容器时采用类似的优化策略。&lt;/p&gt;&#xA;&lt;h2 id=&#34;问题背景小对象的性能困境&#34;&gt;问题背景：小对象的性能困境&lt;/h2&gt;&#xA;&lt;h3 id=&#34;堆分配的性能开销&#34;&gt;堆分配的性能开销&lt;/h3&gt;&#xA;&lt;p&gt;当我们使用&lt;code&gt;std::string&lt;/code&gt;或&lt;code&gt;std::vector&lt;/code&gt;存储数据时，这些容器通常需要动态分配内存来存储实际数据。对于大型对象，堆分配的开销相对于数据处理成本而言是可以接受的。但是，当我们频繁处理小对象时，情况就截然不同了：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;分配器开销&lt;/strong&gt;：每次调用&lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt;或&lt;code&gt;malloc&lt;/code&gt;/&lt;code&gt;free&lt;/code&gt;都涉及复杂的内存管理算法，包括寻找合适大小的内存块、维护空闲列表等&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;内存碎片&lt;/strong&gt;：大量小内存块的分配和释放会导致堆内存碎片化，降低内存利用率&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存局部性差&lt;/strong&gt;：堆上分配的小对象在内存中分布散乱，访问时缓存命中率低&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;传统解决方案的局限&#34;&gt;传统解决方案的局限&lt;/h3&gt;&#xA;&lt;p&gt;栈上分配虽然速度极快，但受限于生命周期管理，无法满足容器需要动态调整大小的需求。而纯粹的堆分配虽然灵活，但在处理短字符串、小容量向量等高频场景时，性能开销变得不可忽视。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心问题&lt;/strong&gt;：如何为需要动态内存管理的容器优化小对象的存储性能？&lt;/p&gt;&#xA;&lt;h2 id=&#34;soo核心原理智能的空间换时间策略&#34;&gt;SOO核心原理：智能的空间换时间策略&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本思想&#34;&gt;基本思想&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;小对象优化的核心策略&lt;/strong&gt;是在容器对象内部预留一个&lt;strong&gt;固定大小的内部缓冲区（Internal Buffer）&lt;/strong&gt;。这个缓冲区作为&amp;quot;快速通道&amp;quot;，专门用于存储小对象的数据。&lt;/p&gt;&#xA;&lt;h3 id=&#34;大小判定逻辑&#34;&gt;大小判定逻辑&lt;/h3&gt;&#xA;&lt;p&gt;SOO的工作机制可以用简单的条件判断来描述：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (required_size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; internal_buffer_size) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用内部缓冲区，无需堆分配&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    store_in_internal_buffer(data);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 退回到传统的堆内存分配&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    allocate_on_heap(data);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;zero-overhead抽象&#34;&gt;Zero-Overhead抽象&lt;/h3&gt;&#xA;&lt;p&gt;SOO的精妙之处在于对使用者完全透明。无论底层使用的是内部缓冲区还是堆内存，容器提供的接口行为完全一致，这体现了C++中&amp;quot;Zero-Overhead&amp;quot;抽象的设计理念。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现剖析以stdstring为例&#34;&gt;实现剖析：以std::string为例&lt;/h2&gt;&#xA;&lt;h3 id=&#34;典型数据结构设计&#34;&gt;典型数据结构设计&lt;/h3&gt;&#xA;&lt;p&gt;一个支持SOO的&lt;code&gt;std::string&lt;/code&gt;内部结构可能如下所示：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;optimized_string&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;constexpr&lt;/span&gt; size_t INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;union&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 大对象模式：指向堆内存&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            size_t size;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            size_t capacity;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } heap_data;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 小对象模式：直接存储在对象内部&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// +1 for null terminator&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; remaining_size; &lt;span style=&#34;color:#75715e&#34;&gt;// 用于标识当前模式和剩余空间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        } stack_data;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    };&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 通过特定位或值判断当前使用的存储模式&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; stack_data.remaining_size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; INTERNAL_BUFFER_SIZE;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; stack_data.buffer : heap_data.ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    size_t &lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; is_using_soo() &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               (INTERNAL_BUFFER_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; stack_data.remaining_size) &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               heap_data.size;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;状态区分机制&#34;&gt;状态区分机制&lt;/h3&gt;&#xA;&lt;p&gt;区分当前使用内部缓冲区还是堆内存是SOO实现的关键技术点。常见策略包括：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌深入分析 =delete 与私有化构造和析构函数的本质区别</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90-delete-%E4%B8%8E%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90-delete-%E4%B8%8E%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;p&gt;[[c++]] [[delete]] [[构造函数]] [[析构函数]]&lt;/p&gt;&#xA;&lt;h2 id=&#34;深入分析-delete-与私有化构造和析构函数的本质区别&#34;&gt;深入分析：= delete 与私有化构造和析构函数的本质区别&lt;/h2&gt;&#xA;&lt;p&gt;​&lt;strong&gt;直接结论&lt;/strong&gt;​：&lt;br&gt;&#xA;绝对不能将构造函数和析构函数写为 = delete 这会直接破坏单例模式的核心功能。以下是详细技术分析：&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;一语法层面的根本差异&#34;&gt;一、语法层面的根本差异&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方案&lt;/th&gt;&#xA;          &lt;th&gt;可访问性&lt;/th&gt;&#xA;          &lt;th&gt;编译器行为&lt;/th&gt;&#xA;          &lt;th&gt;对单例模式的影响&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;​&lt;strong&gt;私有构造函数&lt;/strong&gt;​&lt;/td&gt;&#xA;          &lt;td&gt;仅类内部可访问&lt;/td&gt;&#xA;          &lt;td&gt;允许类内部代码构造对象&lt;/td&gt;&#xA;          &lt;td&gt;实现单例的核心手段&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;Singleton() = delete&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;函数被彻底删除&lt;/td&gt;&#xA;          &lt;td&gt;任何构造尝试直接报错&lt;/td&gt;&#xA;          &lt;td&gt;完全无法创建对象&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方案&lt;/th&gt;&#xA;          &lt;th&gt;可访问性&lt;/th&gt;&#xA;          &lt;th&gt;编译器行为&lt;/th&gt;&#xA;          &lt;th&gt;对单例模式的影响&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;​&lt;strong&gt;私有析构函数&lt;/strong&gt;​&lt;/td&gt;&#xA;          &lt;td&gt;仅类内部可访问&lt;/td&gt;&#xA;          &lt;td&gt;允许类内部析构对象&lt;/td&gt;&#xA;          &lt;td&gt;防止外部delete操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;~Singleton() = delete&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;函数被彻底删除&lt;/td&gt;&#xA;          &lt;td&gt;对象销毁时直接报错&lt;/td&gt;&#xA;          &lt;td&gt;对象无法被正确释放&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;二关键错误场景演示&#34;&gt;二、关键错误场景演示&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton instance;  &lt;span style=&#34;color:#75715e&#34;&gt;// 这里会编译失败！&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;// 构造函数被删除&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 析构函数被删除&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;编译器报错信息&#34;&gt;编译器报错信息&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error: use of deleted &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Singleton::Singleton()&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         static Singleton instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;note: declared here&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     Singleton&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; delete;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ^~~~~~~~~~~&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;error: use of deleted &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Singleton::~Singleton()&amp;#39;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         static Singleton instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;note: declared here&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ~Singleton&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; delete;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     ^&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h3 id=&#34;三技术原理深度解析&#34;&gt;三、技术原理深度解析&lt;/h3&gt;&#xA;&lt;h4 id=&#34;构造函数删除的致命问题&#34;&gt;构造函数删除的致命问题&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;静态局部变量初始化&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;static Singleton instance&lt;/code&gt;本质需要调用构造函数，但构造函数已被删除 → 编译失败&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;单例模式基础破坏&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;删除构造函数意味着该类无法被实例化，完全失去单例存在的意义&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;析构函数删除的连锁反应&#34;&gt;析构函数删除的连锁反应&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;静态变量销毁问题&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序退出时，静态变量&lt;code&gt;instance&lt;/code&gt;需要调用析构函数 → 因析构函数被删除导致链接错误&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;内存泄漏伪装者&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;即使通过特殊手段构造对象，也无法正常释放资源 → 违反RAII原则&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;四正确方案对比验证&#34;&gt;四、正确方案对比验证&lt;/h3&gt;&#xA;&lt;h4 id=&#34;正确实现私有构造析构&#34;&gt;正确实现（私有构造/析构）&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Singleton&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getInstance() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; Singleton instance;  &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：调用私有构造函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; instance;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 禁用拷贝操作&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Singleton(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Singleton&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：私有默认构造&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;Singleton() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 正确：私有析构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;关键优势&#34;&gt;关键优势&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;​&lt;strong&gt;构造可控性&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过私有构造函数限制对象创建途径，确保唯一实例&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;析构安全性&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;私有析构函数阻止外部&lt;code&gt;delete&lt;/code&gt;操作，依赖系统自动释放&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;​&lt;strong&gt;资源管理合规&lt;/strong&gt;​&#xA;&lt;ol&gt;&#xA;&lt;li&gt;静态局部变量在程序结束时自动调用析构函数，符合RAII规范&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;五特殊场景扩展讨论&#34;&gt;五、特殊场景扩展讨论&lt;/h3&gt;&#xA;&lt;h4 id=&#34;q如果确实需要完全禁止某个类的实例化&#34;&gt;Q：如果确实需要完全禁止某个类的实例化？&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UtilityClass&lt;/span&gt; {  &lt;span style=&#34;color:#75715e&#34;&gt;// 工具类，仅包含静态方法&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    UtilityClass() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;UtilityClass() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper1&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper2&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;​&lt;strong&gt;适用场景&lt;/strong&gt;​：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📌深入理解 C&#43;&#43; 中的 std ref 和 cref 的引用封装机制</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-c&#43;&#43;-%E4%B8%AD%E7%9A%84-std-ref-%E5%92%8C-cref-%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%81%E8%A3%85%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-c&#43;&#43;-%E4%B8%AD%E7%9A%84-std-ref-%E5%92%8C-cref-%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%81%E8%A3%85%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h1 id=&#34;深入理解-c-中的-std-ref-和-cref-的引用封装机制&#34;&gt;深入理解 C++ 中的 std ref 和 cref 的引用封装机制&lt;/h1&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在现代 C++ 编程中，&lt;strong&gt;按值传参是常态，但有时候我们确实需要传引用&lt;/strong&gt;。尤其是在使用 &lt;code&gt;std::bind&lt;/code&gt;、&lt;code&gt;std::thread&lt;/code&gt;、标准算法等场景下，如果不加注意，原本希望传引用的变量却被复制，导致逻辑失效甚至程序崩溃。&lt;br&gt;&#xA;本文将带你深入理解 &lt;code&gt;std::ref&lt;/code&gt; 和 &lt;code&gt;std::cref&lt;/code&gt; 的设计原理、使用场景以及易踩的坑。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;为什么需要引用封装器&#34;&gt;为什么需要引用封装器&lt;/h2&gt;&#xA;&lt;p&gt;先来看一个例子：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; x) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    x&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;thread&lt;/span&gt; t(increment, a);  &lt;span style=&#34;color:#75715e&#34;&gt;// ❌ 编译失败&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    t.join();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;你可能以为把 &lt;code&gt;a&lt;/code&gt; 传进去就是引用了，但事实并非如此。&lt;code&gt;std::thread&lt;/code&gt; 默认按值复制参数。它尝试将 &lt;code&gt;a&lt;/code&gt; 拷贝一份传递给 &lt;code&gt;increment&lt;/code&gt;，而 &lt;code&gt;increment&lt;/code&gt; 期望的是 &lt;code&gt;int&amp;amp;&lt;/code&gt;，于是编译器报错。&lt;/p&gt;&#xA;&lt;p&gt;这个时候，&lt;code&gt;std::ref(a)&lt;/code&gt; 就派上了用场：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;thread&lt;/span&gt; t(increment, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ref(a));  &lt;span style=&#34;color:#75715e&#34;&gt;// ✅ 传引用成功&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;std-ref-和-cref-是什么&#34;&gt;std ref 和 cref 是什么&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;std::ref(obj)&lt;/code&gt;：返回一个 &lt;strong&gt;可修改引用&lt;/strong&gt; 的包装器。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;std::cref(obj)&lt;/code&gt;：返回一个 &lt;strong&gt;const 引用&lt;/strong&gt; 的包装器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘 C&#43;&#43;非侵入性编程范式</title>
      <link>/posts/-c&#43;&#43;%E9%9D%9E%E4%BE%B5%E5%85%A5%E6%80%A7%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-c&#43;&#43;%E9%9D%9E%E4%BE%B5%E5%85%A5%E6%80%A7%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;c非侵入性编程范式&#34;&gt;C++非侵入性编程范式&lt;/h2&gt;&#xA;&lt;p&gt;文档编号: Cpp-Tech-NIP-20250624-Final&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-摘要&#34;&gt;1. 摘要&lt;/h3&gt;&#xA;&lt;p&gt;本文档为C++开发者提供了一份关于&lt;strong&gt;非侵入性 (Non-Intrusive)&lt;/strong&gt; 编程范式的全面、深入的技术指南。文档从核心定义出发，系统性地阐述了非侵入性设计的理念、基石与关键技术。内容涵盖泛型编程、非成员函数的策略性使用、操作符重载的外部实现机制（包括参数依赖查找ADL与函数重载），以及类型萃取和智能指针等高级应用。本文旨在通过丰富的代码示例和详尽的原理剖析，帮助开发者掌握并应用非侵入性原则，以构建松耦合、高复用性且易于维护的现代C++软件系统。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2-何为非侵入性编程&#34;&gt;2. 何为非侵入性编程？&lt;/h3&gt;&#xA;&lt;p&gt;在C++中，&lt;strong&gt;非侵入性 (Non-Intrusive)&lt;/strong&gt; 是一种核心设计哲学，其基本原则是：&lt;strong&gt;在为现有类型（如类、结构体）增加新功能，或使其与某个框架、库协作时，无需修改该类型自身的源代码。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;与之相对的是“侵入性 (Intrusive)”设计，它要求被操作的类型必须做出“内在”的改变，例如继承自特定的基类、包含特定的成员变量或实现特定的成员函数。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心思想对比:&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;非侵入性 (Non-Intrusive):&lt;/strong&gt; 功能是“外加”于类型之上的。如同为一部标准手机配上一个多功能手机壳，手机本身无需任何改造。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;侵入性 (Intrusive):&lt;/strong&gt; 功能是“内建”在类型之中的。如同手机在设计制造时就内置了防水和无线充电功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;现代C++推崇非侵入性设计，因为它极大地增强了代码的&lt;strong&gt;灵活性&lt;/strong&gt;与&lt;strong&gt;可复用性&lt;/strong&gt;，允许开发者将无法修改的第三方类型、标准库类型或遗留代码无缝集成到新系统中。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-基石泛型编程与模板&#34;&gt;3. 基石：泛型编程与模板&lt;/h3&gt;&#xA;&lt;p&gt;C++模板是非侵入性设计的基石。通过模板，我们可以编写出独立于任何具体类型的算法和数据结构。这些代码仅对类型提出一组“概念”上的要求（例如，可被复制、可被比较），而非结构上的强制要求。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;std::sort&lt;/code&gt; 算法便是非侵入性的典范。它可以对任何满足其要求的迭代器范围进行排序，而元素类型本身完全无需知晓排序算法的存在。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;示例：为一个无法修改的 &lt;code&gt;Product&lt;/code&gt; 类提供排序能力&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// third_party_library.h - 源码无法修改&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#pragma once&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Product&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Product(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string id, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; price) &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; id_(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(id)), price_(price) {}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; getId() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; id_; }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getPrice&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; price_; } &lt;span style=&#34;color:#75715e&#34;&gt;// 提供一个稳定的公共接口&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string id_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; price_;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们无法修改 &lt;code&gt;Product&lt;/code&gt; 类，但我们可以在外部为其添加比较功能。&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘 PingPong Buffer 设计文档</title>
      <link>/posts/-pingpong-buffer-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-pingpong-buffer-%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</guid>
      <description>&lt;h1 id=&#34;-pingpong-buffer-设计文档&#34;&gt;📘 PingPong Buffer 设计文档&lt;/h1&gt;&#xA;&lt;h2 id=&#34;一设计目标&#34;&gt;一、设计目标&lt;/h2&gt;&#xA;&lt;p&gt;PingPongBuffer（双缓冲区）旨在解决生产者与消费者异步处理数据时的数据一致性与性能问题。适用于&lt;strong&gt;实时数据传输&lt;/strong&gt;、&lt;strong&gt;中断采集&lt;/strong&gt;、&lt;strong&gt;多线程通信&lt;/strong&gt;等场景，具备如下核心目标：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保证&lt;strong&gt;读写互不干扰&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;支持&lt;strong&gt;高吞吐、低延迟&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;能够应对&lt;strong&gt;速率不匹配&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;可维护、可调试、可扩展&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;二核心设计理念&#34;&gt;二、核心设计理念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-双缓冲结构&#34;&gt;2.1 双缓冲结构&lt;/h3&gt;&#xA;&lt;p&gt;使用两个固定大小的缓冲区 &lt;code&gt;buffer[0]&lt;/code&gt; 和 &lt;code&gt;buffer[1]&lt;/code&gt;，通过索引或标志位控制读写指向不同缓冲区。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Buffer Index&lt;/th&gt;&#xA;          &lt;th&gt;用途&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;write_idx&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;当前写入缓冲区索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;read_idx&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;当前读取缓冲区索引&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;通过原子操作（或锁）切换这两个缓冲区，实现无锁或低锁竞争的数据交替使用。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;22-原子切换机制&#34;&gt;2.2 原子切换机制&lt;/h3&gt;&#xA;&lt;p&gt;采用 &lt;code&gt;std::atomic&amp;lt;int&amp;gt;&lt;/code&gt; 索引变量配合 &lt;code&gt;memory_order_release/acquire&lt;/code&gt; 保证跨线程或中断的数据可见性与一致性。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;write_idx.store(new_index, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;memory_order_release);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;read_idx.store(old_write_index, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;memory_order_acquire);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h3 id=&#34;23-数据完整性控制&#34;&gt;2.3 数据完整性控制&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;BeginWrite/EndWrite&lt;/code&gt; 和 &lt;code&gt;BeginRead/EndRead&lt;/code&gt; 保障帧级数据完整性&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;frame_valid&lt;/code&gt; 标志位标识 buffer 是否写满可读&lt;/li&gt;&#xA;&lt;li&gt;支持 &lt;code&gt;frame_id&lt;/code&gt;、时间戳等附加信息追踪数据来源及一致性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;三异常与过载处理机制&#34;&gt;三、异常与过载处理机制&lt;/h2&gt;&#xA;&lt;h3 id=&#34;31-生产者快于消费者overrun&#34;&gt;3.1 生产者快于消费者（overrun）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当前写 buffer flip 后，若旧 buffer 尚未消费 → 记录覆盖行为&lt;/li&gt;&#xA;&lt;li&gt;引入 &lt;code&gt;overrun_counter&lt;/code&gt;，并提供异常提示接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;buffer_valid[read_idx]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    overrun_counter&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;32-异常帧检测&#34;&gt;3.2 异常帧检测&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;frame_id&lt;/code&gt; 不连续时提示丢帧&lt;/li&gt;&#xA;&lt;li&gt;时间戳差距过大可认为数据阻塞&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;四状态重置与配置变更&#34;&gt;四、状态重置与配置变更&lt;/h2&gt;&#xA;&lt;p&gt;支持 &lt;code&gt;reset()&lt;/code&gt; 操作，在底层硬件重配置（如分辨率、频率）或系统热切换场景中清空缓冲状态，防止旧数据干扰：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘 现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能</title>
      <link>/posts/-%E7%8E%B0%E4%BB%A3c&#43;&#43;%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-%E7%8E%B0%E4%BB%A3c&#43;&#43;%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD/</guid>
      <description>&lt;h1 id=&#34;现代c中类型擦除技术的全面解析原理模式与性能&#34;&gt;📘现代C++中类型擦除技术的全面解析：原理、模式与性能&lt;/h1&gt;&#xA;&lt;h2 id=&#34;第一部分类型擦除的起源连接静态与动态多态&#34;&gt;第一部分：类型擦除的起源：连接静态与动态多态&lt;/h2&gt;&#xA;&lt;p&gt;本部分旨在阐明[[类型擦除]]技术所解决的根本问题，将其定位为一种旨在克服传统C++[[多态]]技术局限性的高级[[解决方案]]。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-c中的多态困境&#34;&gt;1.1 C++中的多态困境&lt;/h3&gt;&#xA;&lt;p&gt;在C++中，[[多态]]性——即&lt;strong&gt;以统一接口处理不同类型对象的能力&lt;/strong&gt;——是构建灵活、可扩展软件系统的基石。然而，实现多态的传统方法各自存在固有的局限性，这为类型擦除技术的出现提供了动机。&lt;/p&gt;&#xA;&lt;h4 id=&#34;void--方法-c风格多态&#34;&gt;&lt;code&gt;void *&lt;/code&gt; 方法 (C风格多态)&lt;/h4&gt;&#xA;&lt;p&gt;最原始的类型擦除形式是通过 &lt;code&gt;void *&lt;/code&gt; 指针实现的。C标准库中的 &lt;code&gt;qsort&lt;/code&gt; 函数便是典型范例，它能够对任意类型的数组进行排序，正是因为它通过 &lt;code&gt;void *&lt;/code&gt; 接受数据。&lt;/p&gt;&#xA;&lt;p&gt;这种方法的本质在于将任何类型的指针转换为一个通用的、无类型的指针，从而“擦除”了编译时的类型信息。然而，这种极致的灵活性带来了&lt;strong&gt;巨大的代价&lt;/strong&gt;：&lt;strong&gt;类型安全的完全丧失&lt;/strong&gt;。程序员必须承担将 &lt;code&gt;void *&lt;/code&gt; 手动 &lt;code&gt;reinterpret_cast&lt;/code&gt; 回原始正确类型的责任。这是一个极易出错的过程，一旦类型不匹配，便会立即导致未定义行为（[[Undefined Behavior]], UB）。此外，由于[[编译器]]在处理 &lt;code&gt;void *&lt;/code&gt; 时对底层数据类型一无所知，它&lt;strong&gt;无法进行任何有意义的类型驱动优化&lt;/strong&gt;，可能导致&lt;strong&gt;性能下降&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h4 id=&#34;面向对象多态-继承与虚函数&#34;&gt;面向对象多态 (继承与虚函数)&lt;/h4&gt;&#xA;&lt;p&gt;面向对象编程（OOP）提供了C++中实现运行时多态的惯用方法。该方法依赖于一个包含虚函数（virtual functions）的公共基类，各个具体类通过继承该基类并重写虚函数来实现多态行为。&lt;/p&gt;&#xA;&lt;p&gt;这种模式的主要局限性在于其 &lt;strong&gt;侵入性（intrusive）&lt;/strong&gt;。任何希望以多态方式使用的具体类型都 &lt;strong&gt;必须&lt;/strong&gt; 公开继承自这个共同的基类。这在许多场景下是不可行或不理想的，例如，我们无法修改[[标准库类型]]（如 &lt;code&gt;std::string&lt;/code&gt;）、[[内建类型]]（如 &lt;code&gt;int&lt;/code&gt;）或来自第三方库的类型，让它们去继承我们的基类。&lt;/p&gt;&#xA;&lt;p&gt;此外，这种方法存在“类型丢失”问题。当一个派生类对象通过基类引用或指针传递时，编译器在函数内部就“丢失”了该对象的真实类型信息。从编译器的角度看，它只知道这是一个基类对象。这使得某些操作变得异常困难，尤其是多态复制。若要复制一个基类指针指向的对象，必须依赖于额外的样板代码，如 &lt;code&gt;clone()&lt;/code&gt; 虚函数模式，因为无法直接调用派生类的拷贝构造函数。这种设计还会在本不相关的类型之间建立紧密的耦合关系，迫使它们遵从同一个基类接口。&lt;/p&gt;&#xA;&lt;h4 id=&#34;静态多态-模板&#34;&gt;静态多态 (模板)&lt;/h4&gt;&#xA;&lt;p&gt;与运行时多态相对的是静态多态，主要通过C++[[模板]]（[[Templates]]）实现。模板在编译期为每个使用的具体类型生成特化代码，从而保留了完整的类型信息。这使得编译器能够执行深度优化，如函数[[内联]]，从而获得&lt;strong&gt;极高的性能&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;然而，模板的强大能力也伴随着一个核心限制：无法创建 [[异质容器]]（heterogeneous collections）。例如，&lt;code&gt;std::vector&amp;lt;MyClass&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::vector&amp;lt;MyClass&amp;lt;double&amp;gt;&amp;gt;&lt;/code&gt; 是两种完全不同且不相关的类型，它们不能被存储在同一个容器中。为了处理不同类型，编译器会对模板进行“单态化”（monomorphization），为每个类型参数生成一份独立的代码实例，这可能导致最终二进制文件体积膨胀，即所谓的“代码膨胀”（code bloat）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-在现代c语境下定义类型擦除&#34;&gt;1.2 在现代C++语境下定义类型擦除&lt;/h3&gt;&#xA;&lt;p&gt;“类型擦除”这一术语本身在C++社区中存在一定的模糊性，它并非一个单一、被严格定义的语言特性，而是一系列技术和模式的统称 1。广义上，&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;void *&lt;/code&gt; 和继承都可以被视为某种形式的类型擦除。然而，在现代C++的讨论中，尤其是在[[Sean Parent]]和[[Klaus Iglberger]]等专家的影响下，该术语通常指代一种更具体、更强大的设计模式，这也是本报告的核心焦点。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心原则&lt;/strong&gt;：现代C++类型擦除是一种旨在 &lt;strong&gt;将接口与其实现解耦&lt;/strong&gt; 的技术，它为 &lt;strong&gt;不相关的类型&lt;/strong&gt; 提供了 &lt;strong&gt;非侵入式&lt;/strong&gt; 的 &lt;strong&gt;运行时多态&lt;/strong&gt;，同时保持了 &lt;strong&gt;值语义（value semantics）&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>asan</title>
      <link>/posts/asan/</link>
      <pubDate>Thu, 01 Jun 2023 09:30:01 +0800</pubDate>
      <guid>/posts/asan/</guid>
      <description>&lt;script src=&#34;https://gist.github.com/luyoungcn/b544977db493d7016f87ae60c51cc4cd.js&#34;&gt;&lt;/script&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43; 前向声明与指针使用指南</title>
      <link>/posts/c&#43;&#43;-%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      <guid>/posts/c&#43;&#43;-%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;c++ 为什么有些类属性使用普通的指针定义，而不是使用智能指针&#xA;&lt;code&gt;DogClass *ptr;&lt;/code&gt; 而不是 &lt;code&gt;std::unique_ptr&amp;lt;DogClass&amp;gt; ptr&lt;/code&gt;;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;c-前向声明与指针使用指南&#34;&gt;C++ 前向声明与指针使用指南&lt;/h1&gt;&#xA;&lt;h2 id=&#34;前向声明与不完整类型&#34;&gt;前向声明与不完整类型&lt;/h2&gt;&#xA;&lt;p&gt;在 C++ 中，&lt;strong&gt;前向声明&lt;/strong&gt;（Forward Declaration）允许我们在不包含完整类定义的情况下引用一个类。这对于减少编译依赖和解决循环依赖问题非常有用。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 前向声明示例&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyClass&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 只声明存在性，不提供定义&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，&lt;code&gt;MyClass&lt;/code&gt; 被称为&lt;strong&gt;不完整类型&lt;/strong&gt;（Incomplete Type），因为编译器只知道该类存在，但不知道它的大小、成员或方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;stdunique_ptr-与不完整类型&#34;&gt;std::unique_ptr 与不完整类型&lt;/h2&gt;&#xA;&lt;p&gt;当使用 &lt;code&gt;std::unique_ptr&lt;/code&gt; 管理前向声明类的对象时，会出现问题：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 头文件中&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyForwardDeclaredClass&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 前向声明&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Container&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;MyForwardDeclaredClass&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ptr_; &lt;span style=&#34;color:#75715e&#34;&gt;// 编译错误!&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码在编译时会失败，错误类似于：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;error: invalid application of &amp;#39;sizeof&amp;#39; to incomplete type &amp;#39;MyForwardDeclaredClass&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;原因分析&#34;&gt;原因分析&lt;/h3&gt;&#xA;&lt;p&gt;这个问题出现的原因是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; 的析构函数需要知道如何删除它管理的对象&lt;/li&gt;&#xA;&lt;li&gt;为此，编译器需要在编译 &lt;code&gt;Container&lt;/code&gt; 类时知道 &lt;code&gt;MyForwardDeclaredClass&lt;/code&gt; 的完整定义&lt;/li&gt;&#xA;&lt;li&gt;当编译器尝试计算不完整类型的 &lt;code&gt;sizeof&lt;/code&gt; 时，无法确定其大小，因此报错&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;具体来说，&lt;code&gt;std::unique_ptr&lt;/code&gt; 的默认删除器 &lt;code&gt;std::default_delete&lt;/code&gt; 在析构时会执行：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;default_delete&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;()(T&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ptr) &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static_assert&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(T) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Type must be complete&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt; ptr;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当类型不完整时，&lt;code&gt;sizeof(T)&lt;/code&gt; 无法计算，触发 &lt;code&gt;static_assert&lt;/code&gt; 失败。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>类型擦除 on LuyangのBlog</title>
    <link>/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/</link>
    <description>Recent content in 类型擦除 on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 04 Jun 2025 02:30:00 +0800</lastBuildDate>
    <atom:link href="/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>📘 现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能</title>
      <link>/posts/-%E7%8E%B0%E4%BB%A3c&#43;&#43;%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-%E7%8E%B0%E4%BB%A3c&#43;&#43;%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD/</guid>
      <description>&lt;h1 id=&#34;现代c中类型擦除技术的全面解析原理模式与性能&#34;&gt;📘现代C++中类型擦除技术的全面解析：原理、模式与性能&lt;/h1&gt;&#xA;&lt;h2 id=&#34;第一部分类型擦除的起源连接静态与动态多态&#34;&gt;第一部分：类型擦除的起源：连接静态与动态多态&lt;/h2&gt;&#xA;&lt;p&gt;本部分旨在阐明[[类型擦除]]技术所解决的根本问题，将其定位为一种旨在克服传统C++[[多态]]技术局限性的高级[[解决方案]]。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-c中的多态困境&#34;&gt;1.1 C++中的多态困境&lt;/h3&gt;&#xA;&lt;p&gt;在C++中，[[多态]]性——即&lt;strong&gt;以统一接口处理不同类型对象的能力&lt;/strong&gt;——是构建灵活、可扩展软件系统的基石。然而，实现多态的传统方法各自存在固有的局限性，这为类型擦除技术的出现提供了动机。&lt;/p&gt;&#xA;&lt;h4 id=&#34;void--方法-c风格多态&#34;&gt;&lt;code&gt;void *&lt;/code&gt; 方法 (C风格多态)&lt;/h4&gt;&#xA;&lt;p&gt;最原始的类型擦除形式是通过 &lt;code&gt;void *&lt;/code&gt; 指针实现的。C标准库中的 &lt;code&gt;qsort&lt;/code&gt; 函数便是典型范例，它能够对任意类型的数组进行排序，正是因为它通过 &lt;code&gt;void *&lt;/code&gt; 接受数据。&lt;/p&gt;&#xA;&lt;p&gt;这种方法的本质在于将任何类型的指针转换为一个通用的、无类型的指针，从而“擦除”了编译时的类型信息。然而，这种极致的灵活性带来了&lt;strong&gt;巨大的代价&lt;/strong&gt;：&lt;strong&gt;类型安全的完全丧失&lt;/strong&gt;。程序员必须承担将 &lt;code&gt;void *&lt;/code&gt; 手动 &lt;code&gt;reinterpret_cast&lt;/code&gt; 回原始正确类型的责任。这是一个极易出错的过程，一旦类型不匹配，便会立即导致未定义行为（[[Undefined Behavior]], UB）。此外，由于[[编译器]]在处理 &lt;code&gt;void *&lt;/code&gt; 时对底层数据类型一无所知，它&lt;strong&gt;无法进行任何有意义的类型驱动优化&lt;/strong&gt;，可能导致&lt;strong&gt;性能下降&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h4 id=&#34;面向对象多态-继承与虚函数&#34;&gt;面向对象多态 (继承与虚函数)&lt;/h4&gt;&#xA;&lt;p&gt;面向对象编程（OOP）提供了C++中实现运行时多态的惯用方法。该方法依赖于一个包含虚函数（virtual functions）的公共基类，各个具体类通过继承该基类并重写虚函数来实现多态行为。&lt;/p&gt;&#xA;&lt;p&gt;这种模式的主要局限性在于其 &lt;strong&gt;侵入性（intrusive）&lt;/strong&gt;。任何希望以多态方式使用的具体类型都 &lt;strong&gt;必须&lt;/strong&gt; 公开继承自这个共同的基类。这在许多场景下是不可行或不理想的，例如，我们无法修改[[标准库类型]]（如 &lt;code&gt;std::string&lt;/code&gt;）、[[内建类型]]（如 &lt;code&gt;int&lt;/code&gt;）或来自第三方库的类型，让它们去继承我们的基类。&lt;/p&gt;&#xA;&lt;p&gt;此外，这种方法存在“类型丢失”问题。当一个派生类对象通过基类引用或指针传递时，编译器在函数内部就“丢失”了该对象的真实类型信息。从编译器的角度看，它只知道这是一个基类对象。这使得某些操作变得异常困难，尤其是多态复制。若要复制一个基类指针指向的对象，必须依赖于额外的样板代码，如 &lt;code&gt;clone()&lt;/code&gt; 虚函数模式，因为无法直接调用派生类的拷贝构造函数。这种设计还会在本不相关的类型之间建立紧密的耦合关系，迫使它们遵从同一个基类接口。&lt;/p&gt;&#xA;&lt;h4 id=&#34;静态多态-模板&#34;&gt;静态多态 (模板)&lt;/h4&gt;&#xA;&lt;p&gt;与运行时多态相对的是静态多态，主要通过C++[[模板]]（[[Templates]]）实现。模板在编译期为每个使用的具体类型生成特化代码，从而保留了完整的类型信息。这使得编译器能够执行深度优化，如函数[[内联]]，从而获得&lt;strong&gt;极高的性能&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;然而，模板的强大能力也伴随着一个核心限制：无法创建 [[异质容器]]（heterogeneous collections）。例如，&lt;code&gt;std::vector&amp;lt;MyClass&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::vector&amp;lt;MyClass&amp;lt;double&amp;gt;&amp;gt;&lt;/code&gt; 是两种完全不同且不相关的类型，它们不能被存储在同一个容器中。为了处理不同类型，编译器会对模板进行“单态化”（monomorphization），为每个类型参数生成一份独立的代码实例，这可能导致最终二进制文件体积膨胀，即所谓的“代码膨胀”（code bloat）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-在现代c语境下定义类型擦除&#34;&gt;1.2 在现代C++语境下定义类型擦除&lt;/h3&gt;&#xA;&lt;p&gt;“类型擦除”这一术语本身在C++社区中存在一定的模糊性，它并非一个单一、被严格定义的语言特性，而是一系列技术和模式的统称 1。广义上，&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;void *&lt;/code&gt; 和继承都可以被视为某种形式的类型擦除。然而，在现代C++的讨论中，尤其是在[[Sean Parent]]和[[Klaus Iglberger]]等专家的影响下，该术语通常指代一种更具体、更强大的设计模式，这也是本报告的核心焦点。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心原则&lt;/strong&gt;：现代C++类型擦除是一种旨在 &lt;strong&gt;将接口与其实现解耦&lt;/strong&gt; 的技术，它为 &lt;strong&gt;不相关的类型&lt;/strong&gt; 提供了 &lt;strong&gt;非侵入式&lt;/strong&gt; 的 &lt;strong&gt;运行时多态&lt;/strong&gt;，同时保持了 &lt;strong&gt;值语义（value semantics）&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

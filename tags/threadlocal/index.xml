<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ThreadLocal on LuyangのBlog</title>
    <link>/tags/threadlocal/</link>
    <description>Recent content in ThreadLocal on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 24 Jun 2025 02:30:00 +0800</lastBuildDate>
    <atom:link href="/tags/threadlocal/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>📘ThreadLocal 全面解析</title>
      <link>/posts/-threadlocal-%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Tue, 24 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/-threadlocal-%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;The beauty of open source is that it is technically borderless. &amp;mdash; &lt;a href=&#34;https://www.reddit.com/user/AlterTableUsernames/&#34;&gt;u/AlterTableUsernames&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;threadlocal-全面解析&#34;&gt;ThreadLocal 全面解析&lt;/h2&gt;&#xA;&lt;p&gt;在多线程并发编程中，保证线程安全是开发者必须面对的核心挑战之一。&lt;code&gt;ThreadLocal&lt;/code&gt; 作为 Java 提供的一种独特的线程同步解决方案，它另辟蹊径，通过为每个线程提供变量的独立副本，巧妙地避免了多线程间的数据共享和竞争，从而实现了线程安全。本文将从 &lt;code&gt;ThreadLocal&lt;/code&gt; 的基本概念入手，深入剖析其源码实现，探讨其在 C++ 中的对应方案，并结合常见的面试题，为您全方位揭示 &lt;code&gt;ThreadLocal&lt;/code&gt; 的奥秘，包括其精妙的弱引用设计以及潜在的内存泄漏风险。&lt;/p&gt;&#xA;&lt;h3 id=&#34;threadlocal-简介&#34;&gt;ThreadLocal 简介&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;，顾名思义，即“线程局部变量”。它提供了一种创建变量的机制，该变量对于访问它的每个线程都有其自己独立的、初始化的副本。换言之，如果您在主线程中创建了一个 &lt;code&gt;ThreadLocal&lt;/code&gt; 变量，那么在其他任何线程中，都无法直接访问主线程中该变量的值，而是会拥有并操作属于自己线程的那个变量的副本。&lt;/p&gt;&#xA;&lt;p&gt;这种“空间换时间”的策略，核心思想是隔离而非同步。与使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字或 &lt;code&gt;Lock&lt;/code&gt; 锁等同步机制来保护共享资源不同，&lt;code&gt;ThreadLocal&lt;/code&gt; 直接杜绝了资源共享的可能性，从而在根本上避免了线程间的竞争和同步开销。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心应用场景：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;每个线程需要一个独立的实例&lt;/strong&gt;：例如，&lt;code&gt;SimpleDateFormat&lt;/code&gt; 在多线程环境下是非线程安全的。通过 &lt;code&gt;ThreadLocal&lt;/code&gt; 为每个线程创建一个 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 实例，可以有效避免并发问题。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;维护线程上下文信息&lt;/strong&gt;：在复杂的业务逻辑调用链中，为了避免在每个方法参数中都传递用户信息、事务 ID 等上下文信息，可以使用 &lt;code&gt;ThreadLocal&lt;/code&gt; 在线程生命周期内持有这些信息，方便在调用链的任何位置随时获取。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据库连接管理&lt;/strong&gt;：在服务层和数据访问层之间，可以通过 &lt;code&gt;ThreadLocal&lt;/code&gt; 来管理每个线程的数据库连接，确保同一个线程中的多次数据库操作使用的是同一个连接，从而保证事务的一致性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;源码实现讲解&#34;&gt;源码实现讲解&lt;/h3&gt;&#xA;&lt;p&gt;要真正理解 &lt;code&gt;ThreadLocal&lt;/code&gt; 的工作原理，必须深入其源码。&lt;code&gt;ThreadLocal&lt;/code&gt; 的核心在于其内部类 &lt;code&gt;ThreadLocalMap&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;核心关系图：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn-0.plantuml.com/plantuml/png/PLHHRzj637xNh-3qKhkBjVRL28m6Iu4LQxkXoR27PO0fcRQlFjq9TvHJRzX_7u-IaelwalZ8Zny_ygFzBZ86xbjRl89RWuU0BTmRjbHm-Wltnq2uknh_V_GDsYj0jyi3dx23BsIHZNVnQBf2kEvEna67GaTC8SBU1q1eBA43w_sfY0BGl0GnnXlcOEgUwKFZtPtvX-1D1h764Lyw0X_uw1F_pwa8RcbldD6-HQ4yeoxujm3u4VXPP5pdagkNyel_fl8oIrpVRqh0cDUDl0VYnL88zH7bSKRRamGaUFPcf_50hJ_JOWf9YmwR4nu8ogzunigYEvHAE2dF9Ma2O0MCjHNgzux3vQ-_9IX4KqcfqHBe6vFRoVjFmjCNsbCWrz1rnhWPEYLTezRVwg_KiF8zJN-BZ8ghAlWZKbZ5ZXgpDmti92FH19Njvsv7FOUR67rZXc12t4n67362TmIpXO_Pycq9hrShADzKbNoShM0DZNUCHYddoIa5RM_PT9Q65O7NkM8nWpzrUbjLhyi1cpK0T80XeDJlLRyR8AyYdEW2HW3mOhd07Z3N1CB2A9bYrB5QRRHhZbahso8nmHFLSjPG3HfQtd7mxW0lklAH01lkqQehuy1ZrwcfEhaUgHOp6kquqyuKX3J2e-6ZjcZw85WUOMgouJZtCIUfgis4NaCVQG9N8zNmMYpdHT_RxZjHmvGkH-_jivU7IdZ_hRFefZjp4eTW3aSMsuRz5G3NzURNjEMCTZavcE-zklwftXGWxLFIMlyOTVAiRbnkMdjD0ZrWgF50q7Xh9KwoapqO5jES1oixfW1Xujz90Tb8ZqTvNq4Nw4oEZJle5sBuFTj3IwqNuwn8gmgI4TDGusYbZFAxvrI55ZuDo8-2_259Vt0VzZF1prS89dwlzahXUj1EFmv7KrFZMugmTRsrs-h1_U8VHMiOu5izeYqiqatf8YCRQo7gKTbBDZ3KbsVQwaaVgpwfr1Mjh3aBT67DYP8EdFATztQfBc-dtyvjAdAUGKQpel_12Lya86bWQBpMf3eDbPxo2PkcRtkBJCgLZJ2wEU2KjYRO1r9YAnAID_gzpaqf0QCk_RCQCwoigfv3xyIrlhN_0m00&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;每个 &lt;code&gt;Thread&lt;/code&gt; 对象内部都有一个 &lt;code&gt;threadLocals&lt;/code&gt; 成员变量，其类型就是 &lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt;。也就是说，&lt;code&gt;ThreadLocalMap&lt;/code&gt; 实际上是 &lt;code&gt;Thread&lt;/code&gt; 的一个属性，而不是 &lt;code&gt;ThreadLocal&lt;/code&gt; 的。当调用 &lt;code&gt;ThreadLocal&lt;/code&gt; 的 &lt;code&gt;set(T value)&lt;/code&gt; 或 &lt;code&gt;get()&lt;/code&gt; 方法时，&lt;code&gt;ThreadLocal&lt;/code&gt; 会首先获取当前线程的 &lt;code&gt;ThreadLocalMap&lt;/code&gt;，然后以 &lt;code&gt;ThreadLocal&lt;/code&gt; 实例自身作为 key，进行值的存取。&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘深入解析 Java 线程本地化：从 ThreadLocal 到 ScopedValue 的演进与选择</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-java-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8C%96%E4%BB%8E-threadlocal-%E5%88%B0-scopedvalue-%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E9%80%89%E6%8B%A9/</link>
      <pubDate>Tue, 24 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-java-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8C%96%E4%BB%8E-threadlocal-%E5%88%B0-scopedvalue-%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E9%80%89%E6%8B%A9/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;The beauty of open source is that it is technically borderless. &amp;mdash; &lt;a href=&#34;https://www.reddit.com/user/AlterTableUsernames/&#34;&gt;u/AlterTableUsernames&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;深入解析-java-线程本地化从-threadlocal-到-scopedvalue-的演进与选择&#34;&gt;深入解析 Java 线程本地化：从 ThreadLocal 到 ScopedValue 的演进与选择&lt;/h2&gt;&#xA;&lt;h3 id=&#34;摘要&#34;&gt;摘要&lt;/h3&gt;&#xA;&lt;p&gt;在 Java 服务端开发中，将贯穿单次业务流程的上下文信息（如用户身份、分布式追踪ID）在线程内部进行传递，是一项基础且关键的需求。为应对这一挑战，Java 提供了经典的 &lt;code&gt;ThreadLocal&lt;/code&gt; 机制，它通过巧妙地将数据与执行线程绑定，实现了高效的无锁化数据隔离。然而，这一经典方案如同一把双刃剑：其精巧的设计背后，是充满陷阱的无界生命周期、难以追踪的可变性，以及在现代线程池模型下极易触发的内存泄漏风险。&lt;/p&gt;&#xA;&lt;p&gt;随着 Project Loom 计划的成熟，Java 并发编程正经历一场深刻的范式革命。虚拟线程（Virtual Threads）的引入，使得 &lt;code&gt;InheritableThreadLocal&lt;/code&gt; 的继承成本变得不可接受；而结构化并发（Structured Concurrency）的提出，则呼唤一种更安全、更具确定性的上下文传递机制。在此背景下，&lt;code&gt;ScopedValue&lt;/code&gt; 应运而生。它并非 &lt;code&gt;ThreadLocal&lt;/code&gt; 的简单改良，而是从设计哲学上对线程本地数据的一次重塑，用“动态作用域”的不可变绑定，取代了“线程寄生”的可变状态。&lt;/p&gt;&#xA;&lt;p&gt;本文将对 Java 的线程本地化技术进行一次从经典到现代的完整、深入的探索。我们将首先解构 &lt;code&gt;ThreadLocal&lt;/code&gt; 的内部架构，详尽剖析其 &lt;code&gt;Thread-ThreadLocalMap-ThreadLocal&lt;/code&gt; 的委托关系模型，并对其“弱引用Key-强引用Value”等关键设计决策背后的深层思辨进行论证。接着，我们将聚焦于 &lt;code&gt;InheritableThreadLocal&lt;/code&gt; 在线程池和虚拟线程时代下的困境与宿怨。随后，文章将全面转向 &lt;code&gt;ScopedValue&lt;/code&gt;，将其作为面向未来的解决方案，重点阐述其与结构化并发如何天作之合般地解决了数据自动、安全、高效传播的核心难题。最后，本文通过一场涉及正确性、性能与心智模型的全方位对决，为开发者在技术演进的浪潮中做出明智选择提供坚实的理论依据。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;第一章-threadlocal---一个设计精巧而又充满陷阱的经典&#34;&gt;第一章: &lt;code&gt;ThreadLocal&lt;/code&gt; - 一个设计精巧而又充满陷阱的经典&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 的核心使命是在多线程环境下，为每个线程提供一个专属的数据存储空间，从而实现线程级别的数据隔离。它让开发者感觉好像在使用一个普通的全局变量，但实际上每个线程操作的都是自己的独立副本。&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-核心架构委托与寄生的艺术&#34;&gt;1.1 核心架构：委托与寄生的艺术&lt;/h4&gt;&#xA;&lt;p&gt;要理解 &lt;code&gt;ThreadLocal&lt;/code&gt;，首先必须破除一个误解：数据并非存储在 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象本身。&lt;code&gt;ThreadLocal&lt;/code&gt; 实例扮演的是一个“访问工具”或“代理”的角色，真正的存储发生在执行线程 &lt;code&gt;Thread&lt;/code&gt; 对象的内部。这种关系可以被理解为一种巧妙的“委托”或“寄生”模型。&lt;/p&gt;&#xA;&lt;p&gt;它们之间的关系如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Thread&lt;/code&gt; 对象&lt;/strong&gt;: 线程的实体。每个 &lt;code&gt;Thread&lt;/code&gt; 实例内部都有一个 &lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt; 类型的成员变量 &lt;code&gt;threadLocals&lt;/code&gt;。这个 Map 是惰性创建的，只在线程首次需要存储 &lt;code&gt;ThreadLocal&lt;/code&gt; 数据时才被实例化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;ThreadLocal&lt;/code&gt; 的一个内部静态类，是一个为 &lt;code&gt;ThreadLocal&lt;/code&gt; 量身定制的、非通用的哈希表。它才是真正存储数据的容器，其所有权完全归属于 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 对象&lt;/strong&gt;: 它在整个体系中是“定位键”和“访问入口”。你的代码通过调用 &lt;code&gt;ThreadLocal&lt;/code&gt; 实例的 &lt;code&gt;set()&lt;/code&gt; 或 &lt;code&gt;get()&lt;/code&gt; 方法来操作数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;用户数据 (e.g., &lt;code&gt;RequestData&lt;/code&gt;)&lt;/strong&gt;: 期望在线程内共享的业务数据，作为“值”被存储。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;一次 &lt;code&gt;set&lt;/code&gt; 操作的完整轨迹&lt;/strong&gt;:&#xA;当 &lt;code&gt;CONTEXT.set(data)&lt;/code&gt; 被调用时：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虚拟线程 on LuyangのBlog</title>
    <link>/tags/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 虚拟线程 on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 24 Jun 2025 02:30:00 +0800</lastBuildDate>
    <atom:link href="/tags/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>📘深入解析 Java 线程本地化：从 ThreadLocal 到 ScopedValue 的演进与选择</title>
      <link>/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-java-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8C%96%E4%BB%8E-threadlocal-%E5%88%B0-scopedvalue-%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E9%80%89%E6%8B%A9/</link>
      <pubDate>Tue, 24 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-java-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8C%96%E4%BB%8E-threadlocal-%E5%88%B0-scopedvalue-%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E9%80%89%E6%8B%A9/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;The beauty of open source is that it is technically borderless. &amp;mdash; &lt;a href=&#34;https://www.reddit.com/user/AlterTableUsernames/&#34;&gt;u/AlterTableUsernames&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;深入解析-java-线程本地化从-threadlocal-到-scopedvalue-的演进与选择&#34;&gt;深入解析 Java 线程本地化：从 ThreadLocal 到 ScopedValue 的演进与选择&lt;/h2&gt;&#xA;&lt;h3 id=&#34;摘要&#34;&gt;摘要&lt;/h3&gt;&#xA;&lt;p&gt;在 Java 服务端开发中，将贯穿单次业务流程的上下文信息（如用户身份、分布式追踪ID）在线程内部进行传递，是一项基础且关键的需求。为应对这一挑战，Java 提供了经典的 &lt;code&gt;ThreadLocal&lt;/code&gt; 机制，它通过巧妙地将数据与执行线程绑定，实现了高效的无锁化数据隔离。然而，这一经典方案如同一把双刃剑：其精巧的设计背后，是充满陷阱的无界生命周期、难以追踪的可变性，以及在现代线程池模型下极易触发的内存泄漏风险。&lt;/p&gt;&#xA;&lt;p&gt;随着 Project Loom 计划的成熟，Java 并发编程正经历一场深刻的范式革命。虚拟线程（Virtual Threads）的引入，使得 &lt;code&gt;InheritableThreadLocal&lt;/code&gt; 的继承成本变得不可接受；而结构化并发（Structured Concurrency）的提出，则呼唤一种更安全、更具确定性的上下文传递机制。在此背景下，&lt;code&gt;ScopedValue&lt;/code&gt; 应运而生。它并非 &lt;code&gt;ThreadLocal&lt;/code&gt; 的简单改良，而是从设计哲学上对线程本地数据的一次重塑，用“动态作用域”的不可变绑定，取代了“线程寄生”的可变状态。&lt;/p&gt;&#xA;&lt;p&gt;本文将对 Java 的线程本地化技术进行一次从经典到现代的完整、深入的探索。我们将首先解构 &lt;code&gt;ThreadLocal&lt;/code&gt; 的内部架构，详尽剖析其 &lt;code&gt;Thread-ThreadLocalMap-ThreadLocal&lt;/code&gt; 的委托关系模型，并对其“弱引用Key-强引用Value”等关键设计决策背后的深层思辨进行论证。接着，我们将聚焦于 &lt;code&gt;InheritableThreadLocal&lt;/code&gt; 在线程池和虚拟线程时代下的困境与宿怨。随后，文章将全面转向 &lt;code&gt;ScopedValue&lt;/code&gt;，将其作为面向未来的解决方案，重点阐述其与结构化并发如何天作之合般地解决了数据自动、安全、高效传播的核心难题。最后，本文通过一场涉及正确性、性能与心智模型的全方位对决，为开发者在技术演进的浪潮中做出明智选择提供坚实的理论依据。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;第一章-threadlocal---一个设计精巧而又充满陷阱的经典&#34;&gt;第一章: &lt;code&gt;ThreadLocal&lt;/code&gt; - 一个设计精巧而又充满陷阱的经典&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 的核心使命是在多线程环境下，为每个线程提供一个专属的数据存储空间，从而实现线程级别的数据隔离。它让开发者感觉好像在使用一个普通的全局变量，但实际上每个线程操作的都是自己的独立副本。&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-核心架构委托与寄生的艺术&#34;&gt;1.1 核心架构：委托与寄生的艺术&lt;/h4&gt;&#xA;&lt;p&gt;要理解 &lt;code&gt;ThreadLocal&lt;/code&gt;，首先必须破除一个误解：数据并非存储在 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象本身。&lt;code&gt;ThreadLocal&lt;/code&gt; 实例扮演的是一个“访问工具”或“代理”的角色，真正的存储发生在执行线程 &lt;code&gt;Thread&lt;/code&gt; 对象的内部。这种关系可以被理解为一种巧妙的“委托”或“寄生”模型。&lt;/p&gt;&#xA;&lt;p&gt;它们之间的关系如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;Thread&lt;/code&gt; 对象&lt;/strong&gt;: 线程的实体。每个 &lt;code&gt;Thread&lt;/code&gt; 实例内部都有一个 &lt;code&gt;ThreadLocal.ThreadLocalMap&lt;/code&gt; 类型的成员变量 &lt;code&gt;threadLocals&lt;/code&gt;。这个 Map 是惰性创建的，只在线程首次需要存储 &lt;code&gt;ThreadLocal&lt;/code&gt; 数据时才被实例化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;&lt;/strong&gt;: &lt;code&gt;ThreadLocal&lt;/code&gt; 的一个内部静态类，是一个为 &lt;code&gt;ThreadLocal&lt;/code&gt; 量身定制的、非通用的哈希表。它才是真正存储数据的容器，其所有权完全归属于 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ThreadLocal&lt;/code&gt; 对象&lt;/strong&gt;: 它在整个体系中是“定位键”和“访问入口”。你的代码通过调用 &lt;code&gt;ThreadLocal&lt;/code&gt; 实例的 &lt;code&gt;set()&lt;/code&gt; 或 &lt;code&gt;get()&lt;/code&gt; 方法来操作数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;用户数据 (e.g., &lt;code&gt;RequestData&lt;/code&gt;)&lt;/strong&gt;: 期望在线程内共享的业务数据，作为“值”被存储。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;一次 &lt;code&gt;set&lt;/code&gt; 操作的完整轨迹&lt;/strong&gt;:&#xA;当 &lt;code&gt;CONTEXT.set(data)&lt;/code&gt; 被调用时：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Github on LuyangのBlog</title>
    <link>/tags/github/</link>
    <description>Recent content in Github on LuyangのBlog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 04 Jun 2025 02:30:00 +0800</lastBuildDate>
    <atom:link href="/tags/github/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>🔊告别混乱，玩转高效协作：GitHub 与 Git CLI 的“三角工作流”深度解析</title>
      <link>/posts/%E5%91%8A%E5%88%AB%E6%B7%B7%E4%B9%B1%E7%8E%A9%E8%BD%AC%E9%AB%98%E6%95%88%E5%8D%8F%E4%BD%9Cgithub-%E4%B8%8E-git-cli-%E7%9A%84%E4%B8%89%E8%A7%92%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 04 Jun 2025 02:30:00 +0800</pubDate>
      <guid>/posts/%E5%91%8A%E5%88%AB%E6%B7%B7%E4%B9%B1%E7%8E%A9%E8%BD%AC%E9%AB%98%E6%95%88%E5%8D%8F%E4%BD%9Cgithub-%E4%B8%8E-git-cli-%E7%9A%84%E4%B8%89%E8%A7%92%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;告别混乱玩转高效协作github-与-git-cli-的三角工作流深度解析&#34;&gt;告别混乱，玩转高效协作：GitHub 与 Git CLI 的“三角工作流”深度解析&lt;/h2&gt;&#xA;&lt;p&gt;在现代软件开发中，团队协作是常态。无论是参与热门的开源项目，还是在公司内部与同事并肩作战，高效的代码管理策略都是成功的基石。如果你曾对 Git 的分支操作感到困惑，或者觉得 GitHub 上的 Fork (派生) 和 Pull Request (PR) 让人望而却步，那么是时候深入了解并掌握一套强大的协作模式了——那就是 &lt;strong&gt;“三角工作流”（Triangular Workflow）&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;它不仅能让你的代码管理井然有序，还能大幅提升团队的协作效率。更棒的是，有了强大的 &lt;strong&gt;GitHub CLI (&lt;code&gt;gh&lt;/code&gt; 命令)&lt;/strong&gt; 作为你的得力助手，整个流程将变得前所未有的流畅和智能。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;理解三角工作流的核心概念一场厨房里的协作革命&#34;&gt;理解“三角工作流”的核心概念：一场厨房里的协作革命&lt;/h3&gt;&#xA;&lt;p&gt;为了更好地理解“三角工作流”，我们不妨把它想象成一家星级餐馆的厨房运作模式。&lt;/p&gt;&#xA;&lt;h4 id=&#34;1-主厨的食谱书项目的上游仓库upstream-repository&#34;&gt;1. 主厨的食谱书：项目的“上游仓库”（Upstream Repository）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;类比：&lt;/strong&gt; 这本食谱书是餐馆的灵魂，记载了所有招牌菜的&lt;strong&gt;稳定、经过严格验证&lt;/strong&gt;的配方。它是所有菜品的最终版本，不会被随意修改。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实际意义：&lt;/strong&gt; &lt;strong&gt;上游仓库&lt;/strong&gt;就是项目的原始仓库，通常由项目维护者掌控。它的 &lt;code&gt;main&lt;/code&gt; (或 &lt;code&gt;master&lt;/code&gt;) 和 &lt;code&gt;develop&lt;/code&gt; 分支包含了项目的核心代码，稳定且随时准备发布。你通常&lt;strong&gt;没有直接向其推送代码的权限&lt;/strong&gt;，这是为了保证代码库的质量和稳定性。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;2-你自己的食谱本你的派生仓库forked-repository&#34;&gt;2. 你自己的食谱本：你的“派生仓库”（Forked Repository）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;类比：&lt;/strong&gt; 作为一名新加入的厨师，你不能直接在主厨的食谱书上涂改。因此，你会&lt;strong&gt;抄写一本属于你自己的食谱本&lt;/strong&gt;。这本食谱本是你个人的试验田，你可以随意在上面添加笔记、修改配方，甚至尝试全新的菜肴。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实际意义：&lt;/strong&gt; &lt;strong&gt;派生仓库&lt;/strong&gt;是你在 GitHub 上从上游仓库复制的一个&lt;strong&gt;个人副本&lt;/strong&gt;。这个副本完全属于你，你可以自由地向其推送（&lt;code&gt;push&lt;/code&gt;）代码、创建分支，而不会影响到原始的上游仓库。这是你进行个人开发和试验的“安全沙箱”。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;3-你的新菜试验单你的特性分支feature-branch--topic-branch&#34;&gt;3. 你的新菜试验单：你的“特性分支”（Feature Branch / Topic Branch）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;类比：&lt;/strong&gt; 主厨让你开发一道新甜点。你不会直接在你自己的食谱本上修改，因为你可能需要尝试好几种配方和做法。你会拿出一张&lt;strong&gt;空白的试验单&lt;/strong&gt;，专门用来记录和修改这个新甜点的配方。你可以在这张试验单上放心地试验，即使失败了，也不会弄乱你自己的食谱本。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实际意义：&lt;/strong&gt; &lt;strong&gt;特性分支&lt;/strong&gt;是你在本地从 &lt;code&gt;main&lt;/code&gt; 或 &lt;code&gt;develop&lt;/code&gt; 分支创建的&lt;strong&gt;临时性、短生命周期分支&lt;/strong&gt;。每当你需要开发一个新功能、修复一个 Bug 或进行任何独立的工作时，都应该创建一个新的特性分支。这能确保你的不同工作任务之间&lt;strong&gt;互相隔离&lt;/strong&gt;，避免代码冲突和混乱。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;4-递交新菜建议提交拉取请求pull-request---pr&#34;&gt;4. 递交新菜建议：提交“拉取请求”（Pull Request - PR）&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;类比：&lt;/strong&gt; 当你确信新甜点的配方完美无缺，并想让它成为餐馆的正式菜品时，你不会直接把它写到主厨的食谱书里。你会把你的&lt;strong&gt;试验单&lt;/strong&gt;连同你的自信，一起递交给“主厨”，并说：“主厨，这是我研发的新甜点配方，请您审查！” 主厨和资深厨师会仔细审查你的配方。如果没问题，它就会被正式收录到&lt;strong&gt;主厨的食谱书&lt;/strong&gt;中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实际意义：&lt;/strong&gt; &lt;strong&gt;Pull Request&lt;/strong&gt; 是你在 GitHub 上发起的一个&lt;strong&gt;请求&lt;/strong&gt;，请求项目维护者（主厨）将你派生仓库中特性分支的代码，合并到上游仓库的指定分支（通常是 &lt;code&gt;develop&lt;/code&gt; 或 &lt;code&gt;main&lt;/code&gt;）。这是一个代码审查和讨论的平台，确保只有高质量、符合规范的代码才能进入主项目。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;三角工作流的实战演练git-cli-与-github-联手&#34;&gt;“三角工作流”的实战演练：Git CLI 与 GitHub 联手&lt;/h3&gt;&#xA;&lt;p&gt;理解了核心概念，接下来我们通过 Git CLI 命令，一步步地实现这个强大的工作流：&lt;/p&gt;</description>
    </item>
    <item>
      <title>📘 Git Submodule 全面技术文档</title>
      <link>/posts/-git-submodule-%E5%85%A8%E9%9D%A2%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      <guid>/posts/-git-submodule-%E5%85%A8%E9%9D%A2%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</guid>
      <description>&lt;h1 id=&#34;git-submodule-全面技术文档&#34;&gt;Git Submodule 全面技术文档&lt;/h1&gt;&#xA;&lt;h2 id=&#34;-简介&#34;&gt;📘 简介&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Git Submodule&lt;/code&gt;（子模块）是 Git 提供的一种机制，使得一个 Git 仓库可以包含另一个 Git 仓库作为其子目录。这在大型项目中非常有用，例如依赖多个第三方库、模块化项目结构、多个项目共享组件等场景。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-基本概念&#34;&gt;📦 基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;主仓库（Superproject）&lt;/strong&gt;：包含子模块的顶层仓库。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;子模块（Submodule）&lt;/strong&gt;：嵌套在主仓库中的另一个 Git 仓库，记录的是其特定提交版本。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;.gitmodules&lt;/code&gt; 文件&lt;/strong&gt;：记录子模块路径和对应的远程地址。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;子模块 HEAD 是“冻结”的&lt;/strong&gt;：主仓库记录的是子模块的某个&lt;strong&gt;提交哈希值&lt;/strong&gt;，而不是其分支。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-子模块的基本操作&#34;&gt;📥 子模块的基本操作&lt;/h2&gt;&#xA;&lt;h3 id=&#34;添加子模块&#34;&gt;添加子模块&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git submodule add &amp;lt;repository-url&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git submodule add https://github.com/example/libfoo external/libfoo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;克隆子模块到指定路径&lt;/li&gt;&#xA;&lt;li&gt;在 &lt;code&gt;.gitmodules&lt;/code&gt; 添加记录&lt;/li&gt;&#xA;&lt;li&gt;在主仓库中记录子模块当前 commit&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;克隆带子模块的项目&#34;&gt;克隆带子模块的项目&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone --recurse-submodules &amp;lt;repo-url&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git clone &amp;lt;repo-url&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd &amp;lt;repo-name&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git submodule update --init --recursive&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;更新子模块内容&#34;&gt;更新子模块内容&lt;/h3&gt;&#xA;&lt;p&gt;拉取最新的子模块版本：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git submodule update --remote --merge&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你只是想把子模块切换到其远程分支的最新提交：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git submodule update --remote&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;-子模块日常工作流&#34;&gt;🔁 子模块日常工作流&lt;/h2&gt;&#xA;&lt;h3 id=&#34;切换分支时初始化子模块&#34;&gt;切换分支时初始化子模块&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git checkout &amp;lt;branch-name&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git submodule update --init --recursive&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;提交包含子模块更新的更改&#34;&gt;提交包含子模块更新的更改&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd external/libfoo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git pull origin master  &lt;span style=&#34;color:#75715e&#34;&gt;# 更新子模块内容&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd ../..&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git add external/libfoo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git commit -m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Update submodule libfoo&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注意：提交的是子模块指针的变化（commit hash 改变）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>git 使用指定的 ssh key</title>
      <link>/posts/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84ssh_key/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      <guid>/posts/git%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84ssh_key/</guid>
      <description>&lt;p&gt;Git 提供了以下两种方式来指定使用哪个 SSH Key 进行认证：&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用-git-config-命令&#34;&gt;使用 Git Config 命令&lt;/h2&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;git config&lt;/code&gt; 命令来配置 Git 的全局或本地参数。在这个命令中，可以使用 &lt;code&gt;core.sshCommand&lt;/code&gt; 参数来指定使用哪个 SSH Key 进行认证。&lt;/p&gt;&#xA;&lt;p&gt;例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 全局范围内使用 SSH Key&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git config --global core.sshCommand &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ssh -i ~/.ssh/my_private_key&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 仅对当前仓库使用 SSH Key&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git config core.sshCommand &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ssh -i ~/.ssh/my_private_key&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的命令会告诉 Git，使用 &lt;code&gt;~/.ssh/my_private_key&lt;/code&gt; 文件作为 SSH 私钥进行认证。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用-git-clone-命令&#34;&gt;使用 Git Clone 命令&lt;/h2&gt;&#xA;&lt;p&gt;在使用 git clone 命令克隆项目时，可以通过 &lt;code&gt;-c&lt;/code&gt; 或 &lt;code&gt;--config&lt;/code&gt; 参数来指定使用哪个 SSH Key 进行认证。示例如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ git clone -c core.sshCommand&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ssh -i ~/.ssh/my_private_key&amp;#34;&lt;/span&gt; git@github.com:user/repo.git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的命令将会使用 &lt;code&gt;-i ~/.ssh/my_private_key&lt;/code&gt; 指定的 SSH Key 进行认证。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

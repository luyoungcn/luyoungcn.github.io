<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>CMake条件编译：原理、工程实践与变量作用域管理 | LuyangのBlog</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="/posts/cmake%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%AE%A1%E7%90%86/">
  <meta property="og:site_name" content="LuyangのBlog">
  <meta property="og:title" content="CMake条件编译：原理、工程实践与变量作用域管理">
  <meta property="og:description" content="摘要
条件编译（Conditional Compilation）是 CMake 构建系统实现跨平台、多配置、多功能模块化构建的重要机制。本文以学术论文的严谨风格，系统剖析 CMake 条件编译的原理，结合实际工程案例探讨其在大型项目中的应用，并深入分析变量作用域对条件逻辑的影响。文中还专门介绍 option(USE_FOO &#34;Enable FOO support&#34; OFF) 语句的行为及其在条件判断中的应用与区别。通过对官方文档与经典社区资料的引用，力求为 CMake 工程师提供全面、可复用的指导与最佳实践。
关键词 CMake；条件编译；if；生成器表达式；变量作用域；缓存变量；目录作用域；函数作用域；option()
1. 引言 近年来，随着跨平台 C/C&#43;&#43; 项目规模的不断扩张，开发者需要针对操作系统、编译器版本、构建类型（如 Debug/Release）等多种维度，灵活地控制构建过程。CMake 作为一种流行的元构建（meta-build）工具，内置了强大的条件编译能力，使得同一套 CMake 脚本能够自动适配多种环境与需求。本文旨在系统阐述 CMake 条件编译的核心原理，包括 if() 语句与生成器表达式（Generator Expressions）的区别与协同；并结合工程实践介绍常见模式。此外，针对 CMake 的动态作用域模型，深入讨论目录作用域（Directory Scope）、函数作用域（Function Scope）与缓存作用域（Cache Scope）对条件逻辑的影响，帮助读者避免常见错误、提升脚本可维护性。最后，以 option(USE_FOO &#34;Enable FOO support&#34; OFF) 为例，演示变量在条件判断中的常见误区与正确用法。
2. CMake 条件编译原理 2.1 if() 条件判断语法与行为 CMake 提供了 if()、elseif()、else()、endif() 等控制结构，用来根据条件选择性地执行脚本代码。其基本语法为：
if(&lt;condition&gt;) &lt;commands&gt; elseif(&lt;condition&gt;) &lt;commands&gt; else() &lt;commands&gt; endif() 其中 &lt;condition&gt; 可为布尔常量、数值或字符串比较、变量存在性判断、逻辑组合等多种形式。根据官方文档，以下情形会被视为“假”（False）：0/&#34;0&#34;、OFF/&#34;OFF&#34;、NO/&#34;NO&#34;、FALSE/&#34;FALSE&#34;、NOTFOUND、空字符串，或未定义变量；而 1/&#34;1&#34;、ON/&#34;ON&#34;、YES/&#34;YES&#34;、TRUE/&#34;TRUE&#34;、Y、非零数字等被视为“真”（True）(cmake.org, cmake.org)。">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-03T00:00:00+08:00">
    <meta property="article:modified_time" content="2025-06-03T00:00:00+08:00">
    <meta property="article:tag" content="Cmake">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="CMake条件编译：原理、工程实践与变量作用域管理">
  <meta name="twitter:description" content="摘要
条件编译（Conditional Compilation）是 CMake 构建系统实现跨平台、多配置、多功能模块化构建的重要机制。本文以学术论文的严谨风格，系统剖析 CMake 条件编译的原理，结合实际工程案例探讨其在大型项目中的应用，并深入分析变量作用域对条件逻辑的影响。文中还专门介绍 option(USE_FOO &#34;Enable FOO support&#34; OFF) 语句的行为及其在条件判断中的应用与区别。通过对官方文档与经典社区资料的引用，力求为 CMake 工程师提供全面、可复用的指导与最佳实践。
关键词 CMake；条件编译；if；生成器表达式；变量作用域；缓存变量；目录作用域；函数作用域；option()
1. 引言 近年来，随着跨平台 C/C&#43;&#43; 项目规模的不断扩张，开发者需要针对操作系统、编译器版本、构建类型（如 Debug/Release）等多种维度，灵活地控制构建过程。CMake 作为一种流行的元构建（meta-build）工具，内置了强大的条件编译能力，使得同一套 CMake 脚本能够自动适配多种环境与需求。本文旨在系统阐述 CMake 条件编译的核心原理，包括 if() 语句与生成器表达式（Generator Expressions）的区别与协同；并结合工程实践介绍常见模式。此外，针对 CMake 的动态作用域模型，深入讨论目录作用域（Directory Scope）、函数作用域（Function Scope）与缓存作用域（Cache Scope）对条件逻辑的影响，帮助读者避免常见错误、提升脚本可维护性。最后，以 option(USE_FOO &#34;Enable FOO support&#34; OFF) 为例，演示变量在条件判断中的常见误区与正确用法。
2. CMake 条件编译原理 2.1 if() 条件判断语法与行为 CMake 提供了 if()、elseif()、else()、endif() 等控制结构，用来根据条件选择性地执行脚本代码。其基本语法为：
if(&lt;condition&gt;) &lt;commands&gt; elseif(&lt;condition&gt;) &lt;commands&gt; else() &lt;commands&gt; endif() 其中 &lt;condition&gt; 可为布尔常量、数值或字符串比较、变量存在性判断、逻辑组合等多种形式。根据官方文档，以下情形会被视为“假”（False）：0/&#34;0&#34;、OFF/&#34;OFF&#34;、NO/&#34;NO&#34;、FALSE/&#34;FALSE&#34;、NOTFOUND、空字符串，或未定义变量；而 1/&#34;1&#34;、ON/&#34;ON&#34;、YES/&#34;YES&#34;、TRUE/&#34;TRUE&#34;、Y、非零数字等被视为“真”（True）(cmake.org, cmake.org)。">

      <link rel="stylesheet" href="/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css" integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H&#43;ZeT/jBpieRZ8=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/bundle.min.e139b0e3b3aff8f0e8e0272554b671a06c857a42278b36c539d96c69ddee2ca2.css" integrity="sha256-4Tmw47Ov&#43;PDo4CclVLZxoGyFekInizbFOdlsad3uLKI=" crossorigin="anonymous">

      <script src="/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js" integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin="anonymous"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="/" style="color: inherit;">LuyangのBlog</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="/features/"
      >Features</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="/features/"
      >Features</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>CMake条件编译：原理、工程实践与变量作用域管理</h1><time class="dim" datetime="2025-06-03T00:00:00&#43;08:00">June 3, 2025</time><div class="term-container"><div class="tag">
        <a href="/tags/cmake/">#cmake</a>
      </div></ol></div>
  <section class="page-section"><p><strong>摘要</strong><br>
条件编译（Conditional Compilation）是 CMake 构建系统实现跨平台、多配置、多功能模块化构建的重要机制。本文以学术论文的严谨风格，系统剖析 CMake 条件编译的原理，结合实际工程案例探讨其在大型项目中的应用，并深入分析变量作用域对条件逻辑的影响。文中还专门介绍 <code>option(USE_FOO &quot;Enable FOO support&quot; OFF)</code> 语句的行为及其在条件判断中的应用与区别。通过对官方文档与经典社区资料的引用，力求为 CMake 工程师提供全面、可复用的指导与最佳实践。</p>
<hr>
<h2 id="关键词">关键词</h2>
<p>CMake；条件编译；if；生成器表达式；变量作用域；缓存变量；目录作用域；函数作用域；<code>option()</code></p>
<hr>
<h2 id="1-引言">1. 引言</h2>
<p>近年来，随着跨平台 C/C++ 项目规模的不断扩张，开发者需要针对操作系统、编译器版本、构建类型（如 Debug/Release）等多种维度，灵活地控制构建过程。CMake 作为一种流行的元构建（meta-build）工具，内置了强大的条件编译能力，使得同一套 CMake 脚本能够自动适配多种环境与需求。本文旨在系统阐述 CMake 条件编译的核心原理，包括 <code>if()</code> 语句与生成器表达式（Generator Expressions）的区别与协同；并结合工程实践介绍常见模式。此外，针对 CMake 的动态作用域模型，深入讨论目录作用域（Directory Scope）、函数作用域（Function Scope）与缓存作用域（Cache Scope）对条件逻辑的影响，帮助读者避免常见错误、提升脚本可维护性。最后，以 <code>option(USE_FOO &quot;Enable FOO support&quot; OFF)</code> 为例，演示变量在条件判断中的常见误区与正确用法。</p>
<hr>
<h2 id="2-cmake-条件编译原理">2. CMake 条件编译原理</h2>
<h3 id="21-if-条件判断语法与行为">2.1 <code>if()</code> 条件判断语法与行为</h3>
<p>CMake 提供了 <code>if()</code>、<code>elseif()</code>、<code>else()</code>、<code>endif()</code> 等控制结构，用来根据条件选择性地执行脚本代码。其基本语法为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>if(<span style="color:#e6db74">&lt;condition&gt;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  <span style="color:#960050;background-color:#1e0010">&lt;commands&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>elseif(<span style="color:#e6db74">&lt;condition&gt;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  <span style="color:#960050;background-color:#1e0010">&lt;commands&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>else()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  <span style="color:#960050;background-color:#1e0010">&lt;commands&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>其中 <code>&lt;condition&gt;</code> 可为布尔常量、数值或字符串比较、变量存在性判断、逻辑组合等多种形式。根据官方文档，以下情形会被视为“假”（False）：<code>0</code>/<code>&quot;0&quot;</code>、<code>OFF</code>/<code>&quot;OFF&quot;</code>、<code>NO</code>/<code>&quot;NO&quot;</code>、<code>FALSE</code>/<code>&quot;FALSE&quot;</code>、<code>NOTFOUND</code>、空字符串，或未定义变量；而 <code>1</code>/<code>&quot;1&quot;</code>、<code>ON</code>/<code>&quot;ON&quot;</code>、<code>YES</code>/<code>&quot;YES&quot;</code>、<code>TRUE</code>/<code>&quot;TRUE&quot;</code>、<code>Y</code>、非零数字等被视为“真”（True）(<a href="https://cmake.org/cmake/help/v3.1/command/if.html?utm_source=chatgpt.com" title="if — CMake 3.1.3 Documentation">cmake.org</a>, <a href="https://cmake.org/cmake/help/latest/command/if.html?utm_source=chatgpt.com" title="if — CMake 4.0.2 Documentation">cmake.org</a>)。</p>
<p>在条件中若直接写 <code>&lt;variable&gt;</code>，CMake 会判别该变量是否已定义，且其值不在上述“假”列表中，则结果为真；否则为假。需特别注意的是，CMake 的 <code>if()</code> 并不会为布尔判断单独创建作用域，位于 <code>if()</code>/<code>endif()</code> 之间用 <code>set()</code> 定义的变量，会绑定到当前目录作用域并影响后续逻辑，而不会在 <code>endif()</code> 时销毁，这与大多数编程语言（如 C/C++）不同(<a href="https://cmake.org/cmake/help/latest/command/if.html?utm_source=chatgpt.com" title="if — CMake 4.0.2 Documentation">cmake.org</a>, <a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html?utm_source=chatgpt.com" title="cmake-language(7) — CMake 4.0.0-rc4 Documentation">cmake.org</a>)。</p>
<p>此外，比较操作（如 <code>EQUAL</code>、<code>LESS</code>、<code>GREATER</code>）、字符串比较（如 <code>STREQUAL</code>、<code>STRLESS</code>）、版本比较（如 <code>VERSION_LESS</code>、<code>VERSION_GREATER</code>）等，在遇到 <code>&lt;variable|string&gt;</code> 形式时，会先判断是否为已定义变量，再取其值进行比较；不存在时即按字面值处理。而逻辑运算符 <code>NOT</code>、<code>AND</code>、<code>OR</code> 则按照优先级自上而下依次解析(<a href="https://cmake.org/cmake/help/v3.18/command/if.html?utm_source=chatgpt.com" title="if — CMake 3.18.6 Documentation">cmake.org</a>, <a href="https://cmake.org/cmake/help/v3.1/command/if.html?utm_source=chatgpt.com" title="if — CMake 3.1.3 Documentation">cmake.org</a>)。</p>
<h3 id="22-生成器表达式generator-expressions及延迟求值">2.2 生成器表达式（Generator Expressions）及延迟求值</h3>
<p>除了 <code>if()</code> 语法，CMake 还通过生成器表达式（Generator Expressions）实现针对目标属性（target properties）和编译选项的条件化配置。这种表达式形如 <code>$&lt;condition:result&gt;</code> 或 <code>$&lt;IF:condition,true_string,false_string&gt;</code>，在构建系统生成阶段（而非配置阶段）延迟求值，以便根据实际构建上下文（如生成器类型、多配置模式、平台、编译器版本等）输出不同结果。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>target_compile_options(<span style="color:#e6db74">MyTarget</span> <span style="color:#e6db74">PRIVATE</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;CONFIG:Debug<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:-O0&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;CONFIG:Release<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:-O3&gt;</span>
</span></span><span style="display:flex;"><span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>当构建类型为 Debug 时，<code>$&lt;CONFIG:Debug&gt;</code> 求值为 <code>1</code>，输出 <code>-O0</code>；当为 Release 时，<code>$&lt;CONFIG:Release&gt;</code> 求值为 <code>1</code>，输出 <code>-O3</code>。若使用多配置生成器（如 Visual Studio、Ninja Multi-Config），则应依赖生成器表达式判断 <code>CONFIG</code>，而非直接判断 <code>${CMAKE_BUILD_TYPE}</code>，因为后者在构建阶段可能不准确(<a href="https://cmake.org/cmake/help/v3.24/manual/cmake-generator-expressions.7.html?utm_source=chatgpt.com" title="cmake-generator-expressions(7) — CMake 3.24.4 Documentation">cmake.org</a>, <a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20Generator%20Expressions.html?utm_source=chatgpt.com" title="Step 4: Adding Generator Expressions — CMake 4.0.1 Documentation">cmake.org</a>)。</p>
<p>更复杂的嵌套示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">$&lt;$&lt;AND:$&lt;CXX_COMPILER_ID:GNU&gt;,$&lt;VERSION_GREATER_EQUAL:$&lt;CXX_COMPILER_VERSION&gt;,9.0&gt;&gt;:-Wall&gt;
</span></span></span></code></pre></div><p>该表达式仅在编译器为 GNU 且版本 ≥ 9.0 时产生 <code>-Wall</code>，否则输出空串。由内向外依次解析 <code>$&lt;CXX_COMPILER_ID:GNU&gt;</code> 判断编译器标识，<code>$&lt;CXX_COMPILER_VERSION&gt;</code> 判断版本号，最终通过 <code>$&lt;AND:…&gt;</code> 组合逻辑(<a href="https://cmake.org/cmake/help/v3.24/manual/cmake-generator-expressions.7.html?utm_source=chatgpt.com" title="cmake-generator-expressions(7) — CMake 3.24.4 Documentation">cmake.org</a>, <a href="https://github.com/Kitware/CMake/blob/master/Help/manual/cmake-generator-expressions.7.rst?utm_source=chatgpt.com" title="CMake/Help/manual/cmake-generator-expressions.7.rst at master · Kitware/CMake · GitHub">github.com</a>)。</p>
<hr>
<h2 id="3-工程实践灵活运用条件编译">3. 工程实践：灵活运用条件编译</h2>
<h3 id="31-平台与编译器差异的编译选项设置">3.1 平台与编译器差异的编译选项设置</h3>
<p>在跨平台项目中，对不同操作系统、编译器提供不同编译选项或链接库路径的需求极为常见。以下示例展示两种对比做法：</p>
<ul>
<li>
<p><strong>使用 <code>if()</code></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>if(<span style="color:#e6db74">WIN32</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  set(<span style="color:#e6db74">PLATFORM_LIBS</span> <span style="color:#e6db74">ws2_32</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>elseif(<span style="color:#e6db74">APPLE</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  set(<span style="color:#e6db74">PLATFORM_LIBS</span> <span style="color:#e6db74">&#34;-framework CoreFoundation&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>else()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  set(<span style="color:#e6db74">PLATFORM_LIBS</span> <span style="color:#e6db74">pthread</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>add_executable(<span style="color:#e6db74">MyApp</span> <span style="color:#e6db74">main.cpp</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>target_link_libraries(<span style="color:#e6db74">MyApp</span> <span style="color:#e6db74">PRIVATE</span> <span style="color:#f92672">${</span>PLATFORM_LIBS<span style="color:#f92672">}</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>代码直观，对应平台关联系统库。条件判断在配置阶段即时生效(<a href="https://cmake.org/cmake/help/v3.1/command/if.html?utm_source=chatgpt.com" title="if — CMake 3.1.3 Documentation">cmake.org</a>, <a href="https://cmake.org/cmake/help/latest/command/if.html?utm_source=chatgpt.com" title="if — CMake 4.0.2 Documentation">cmake.org</a>)。</p>
</li>
<li>
<p><strong>使用生成器表达式</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>add_executable(<span style="color:#e6db74">MyApp</span> <span style="color:#e6db74">main.cpp</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>target_link_libraries(<span style="color:#e6db74">MyApp</span> <span style="color:#e6db74">PRIVATE</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;PLATFORM_ID:Windows<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:ws2_32&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;PLATFORM_ID:Darwin<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:</span><span style="color:#e6db74">&#34;-framework CoreFoundation&#34;</span><span style="color:#e6db74">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;PLATFORM_ID:Linux<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:pthread&gt;</span>
</span></span><span style="display:flex;"><span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>生成器表达式将平台判断“推迟”到构建系统生成阶段，脚本更为简洁。无论在哪个子目录，只要针对 <code>MyApp</code> 设置属性，都能正确链接对应库(<a href="https://cmake.org/cmake/help/v3.24/manual/cmake-generator-expressions.7.html?utm_source=chatgpt.com" title="cmake-generator-expressions(7) — CMake 3.24.4 Documentation">cmake.org</a>, <a href="https://stuff.mit.edu/afs/athena/software/root_v6.12/arch/amd64_linux26/doc/cmake/html/manual/cmake-generator-expressions.7.html?utm_source=chatgpt.com" title="cmake-generator-expressions(7) — CMake 3.10.1 Documentation">stuff.mit.edu</a>)。</p>
</li>
</ul>
<h3 id="32-多配置与编译选项管理">3.2 多配置与编译选项管理</h3>
<p>对于支持多配置的生成器（如 Visual Studio、Ninja Multi-Config），通过生成器表达式管理不同配置下的编译宏与选项是最佳实践：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>add_executable(<span style="color:#e6db74">MyLib</span> <span style="color:#e6db74">lib.cpp</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>target_compile_definitions(<span style="color:#e6db74">MyLib</span> <span style="color:#e6db74">PRIVATE</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;CONFIG:Debug<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:DEBUG_MODE&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;CONFIG:Release<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:NDEBUG&gt;</span>
</span></span><span style="display:flex;"><span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>target_compile_options(<span style="color:#e6db74">MyLib</span> <span style="color:#e6db74">PRIVATE</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;CONFIG:Debug<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:-g&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;CONFIG:RelWithDebInfo<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:-O2</span> <span style="color:#e6db74">-g&gt;</span>
</span></span><span style="display:flex;"><span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>相比在多个 <code>if(CONFIG STREQUAL &quot;Debug&quot;)</code> 分支中反复设置，生成器表达式方式更具可读性、易扩展。当项目需要新增配置（如 <code>Profile</code>），只需在同一语句组中新增对应表达式即可，无需修改多处位置(<a href="https://cmake.org/cmake/help/v3.24/manual/cmake-generator-expressions.7.html?utm_source=chatgpt.com" title="cmake-generator-expressions(7) — CMake 3.24.4 Documentation">cmake.org</a>, <a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20Generator%20Expressions.html?utm_source=chatgpt.com" title="Step 4: Adding Generator Expressions — CMake 4.0.1 Documentation">cmake.org</a>)。</p>
<h3 id="33-可选依赖与插件化架构">3.3 可选依赖与插件化架构</h3>
<p>在大型项目中，常需根据用户选项或检测结果决定是否链接某些第三方库。典型模式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>option(<span style="color:#e6db74">USE_FOO</span> <span style="color:#e6db74">&#34;Enable FOO support&#34;</span> <span style="color:#e6db74">OFF</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>if(<span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  find_package(<span style="color:#e6db74">FOO</span> <span style="color:#e6db74">REQUIRED</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  target_compile_definitions(<span style="color:#e6db74">MyApp</span> <span style="color:#e6db74">PRIVATE</span> <span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  target_link_libraries(<span style="color:#e6db74">MyApp</span> <span style="color:#e6db74">PRIVATE</span> <span style="color:#e6db74">FOO::FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>若用户通过 <code>-DUSE_FOO=ON</code> 开启，则执行 <code>find_package(FOO)</code>，并将 <code>FOO::FOO</code> 链接到目标。若将上述逻辑改为生成器表达式，可在链接阶段再判断：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>find_package(<span style="color:#e6db74">FOO</span> <span style="color:#e6db74">QUIET</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>target_compile_definitions(<span style="color:#e6db74">MyApp</span> <span style="color:#e6db74">PRIVATE</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;BOOL:${FOO_FOUND}<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:USE_FOO&gt;</span>
</span></span><span style="display:flex;"><span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>target_link_libraries(<span style="color:#e6db74">MyApp</span> <span style="color:#e6db74">PRIVATE</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">$&lt;</span>$&lt;BOOL:${FOO_FOUND}<span style="color:#f92672">&gt;</span><span style="color:#e6db74">:FOO::FOO&gt;</span>
</span></span><span style="display:flex;"><span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>此时，无需显式 <code>if(USE_FOO)</code>，而是通过 <code>$&lt;BOOL:${FOO_FOUND}&gt;</code> 判断 <code>find_package()</code> 成功与否，再决定是否传递宏与链接库，可有效简化脚本层次(<a href="https://stackoverflow.com/questions/68409032/why-cmake-option-command-should-be-on-or-off?utm_source=chatgpt.com" title="Why CMake option command should be ON or OFF? - Stack Overflow">stackoverflow.com</a>, <a href="https://cmake.org/cmake/help/v3.24/manual/cmake-generator-expressions.7.html?utm_source=chatgpt.com" title="cmake-generator-expressions(7) — CMake 3.24.4 Documentation">cmake.org</a>)。</p>
<hr>
<h2 id="4-变量作用域管理">4. 变量作用域管理</h2>
<h3 id="41-cmake-的动态作用域模型">4.1 CMake 的动态作用域模型</h3>
<p>CMake 采用<strong>动态作用域</strong>（Dynamic Scoping），包含三类主要作用域：函数作用域（Function Scope）、目录作用域（Directory Scope）与缓存作用域（Cache Scope）(<a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html?utm_source=chatgpt.com" title="cmake-language(7) — CMake 4.0.0-rc4 Documentation">cmake.org</a>, <a href="https://stuff.mit.edu/afs/athena/software/root_v6.12/arch/amd64_linux26/doc/cmake/html/manual/cmake-language.7.html?utm_source=chatgpt.com" title="cmake-language(7) — CMake 3.10.1 Documentation">stuff.mit.edu</a>)。</p>
<ol>
<li>
<p><strong>函数作用域</strong></p>
<ul>
<li>由 <code>function()</code> 创建，函数内部调用 <code>set(VAR val)</code> 则绑定于当前函数作用域，函数结束后该绑定失效，不会影响外部目录作用域。</li>
</ul>
</li>
<li>
<p><strong>目录作用域</strong></p>
<ul>
<li>每个 <code>CMakeLists.txt</code> 文件对应一个目录作用域。在处理子目录前，CMake 会将父目录的变量绑定复制到子目录，形成层级继承。若在当前目录（非函数内部）使用 <code>set(VAR val)</code>，则绑定至当前目录与其后续子目录。</li>
</ul>
</li>
<li>
<p><strong>缓存作用域</strong></p>
<ul>
<li>通过 <code>-DVAR=val</code> 或 <code>set(VAR val CACHE TYPE &quot;docstring&quot;)</code> 等方式创建，持久保存在 <code>CMakeCache.txt</code> 中，可跨多次配置运行维持不变。缓存变量在所有目录及函数作用域最低优先级查询。</li>
</ul>
</li>
</ol>
<p>在变量引用时，CMake 会依次在函数调用栈、当前目录作用域、缓存作用域中查找绑定；若均未找到，则变量视为空字符串。若需强制读取缓存条目可使用 <code>$CACHE{VAR}</code> 语法。这样层次化的查找逻辑对正确理解条件编译至关重要(<a href="https://stuff.mit.edu/afs/athena/software/root_v6.12/arch/amd64_linux26/doc/cmake/html/manual/cmake-language.7.html?utm_source=chatgpt.com" title="cmake-language(7) — CMake 3.10.1 Documentation">stuff.mit.edu</a>, <a href="https://cmake.org/cmake/help/v3.0/command/set.html?utm_source=chatgpt.com" title="set — CMake 3.0.2 Documentation">cmake.org</a>)。</p>
<h3 id="42-条件逻辑与变量持久性陷阱">4.2 条件逻辑与变量持久性陷阱</h3>
<p>CMake <code>if()</code> 本身不创建独立作用域，意味着在 <code>if()</code>/<code>endif()</code> 中用 <code>set()</code> 定义的普通变量，将绑定到当前目录作用域并对后续逻辑生效，除非显示指定 <code>PARENT_SCOPE</code> 或 <code>CACHE</code>。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>if(<span style="color:#e6db74">USE_BAR</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  set(<span style="color:#e6db74">BAR_ENABLED</span> <span style="color:#e6db74">TRUE</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>message(<span style="color:#e6db74">&#34;BAR_ENABLED = ${BAR_ENABLED}&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>
<p>若 <code>USE_BAR</code> 为真，则 <code>BAR_ENABLED</code> 被赋值 <code>TRUE</code> 并输出。</p>
</li>
<li>
<p>若 <code>USE_BAR</code> 为假，则 <code>BAR_ENABLED</code> 未定义，输出为空字符串。</p>
</li>
</ul>
<p>此行为与许多编程语言不同，后者通常在 <code>if</code> 块结束时销毁局部变量。为避免此类风险，建议在条件外先初始化变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>set(<span style="color:#e6db74">BAR_ENABLED</span> <span style="color:#e6db74">FALSE</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>if(<span style="color:#e6db74">USE_BAR</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  set(<span style="color:#e6db74">BAR_ENABLED</span> <span style="color:#e6db74">TRUE</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>这样确保无论条件如何，<code>BAR_ENABLED</code> 都有确定值(<a href="https://cmake.org/cmake/help/v3.0/command/set.html?utm_source=chatgpt.com" title="set — CMake 3.0.2 Documentation">cmake.org</a>, <a href="https://manpages.debian.org/jessie/cmake-data/cmake-commands.7.en.html?utm_source=chatgpt.com" title="cmake-commands(7) — cmake-data — Debian jessie — Debian Manpages">manpages.debian.org</a>)。</p>
<h3 id="43-parent_scope-与-cache-的典型场景">4.3 <code>PARENT_SCOPE</code> 与 <code>CACHE</code> 的典型场景</h3>
<ul>
<li>
<p><strong><code>PARENT_SCOPE</code></strong><br>
用于将某个子目录中定义的变量值“上抛”到直接父目录作用域。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span><span style="color:#75715e"># 根 CMakeLists.txt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>set(<span style="color:#e6db74">FOO_FOUND</span> <span style="color:#e6db74">FALSE</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>add_subdirectory(<span style="color:#e6db74">libfoo</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>if(<span style="color:#e6db74">FOO_FOUND</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;Foo 已启用&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span><span style="color:#75715e"># libfoo/CMakeLists.txt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>if(<span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  add_library(<span style="color:#e6db74">foo</span> <span style="color:#e6db74">STATIC</span> <span style="color:#e6db74">foo.cpp</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  set(<span style="color:#e6db74">FOO_FOUND</span> <span style="color:#e6db74">TRUE</span> <span style="color:#e6db74">PARENT_SCOPE</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>当 <code>USE_FOO</code> 为真时，<code>FOO_FOUND</code> 在 <code>libfoo</code> 中被置为 <code>TRUE</code> 并传递至根目录，根目录即可检测到子模块状态。但需注意，<code>PARENT_SCOPE</code> 仅将绑定传递给直接父目录，若需跨层次传递，则需多次使用或借助缓存变量(<a href="https://stuff.mit.edu/afs/athena/software/root_v6.12/arch/amd64_linux26/doc/cmake/html/manual/cmake-language.7.html?utm_source=chatgpt.com" title="cmake-language(7) — CMake 3.10.1 Documentation">stuff.mit.edu</a>, <a href="https://releases.llvm.org/18.1.1/docs/CMakePrimer.html?utm_source=chatgpt.com" title="CMake Primer — LLVM 18.1.1 documentation">releases.llvm.org</a>)。</p>
</li>
<li>
<p><strong><code>CACHE</code></strong><br>
缓存变量适用于用户可在 CMake GUI（如 ccmake、cmake-gui）或命令行 <code>-D</code> 提供交互式配置的场景。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>option(<span style="color:#e6db74">ENABLE_BAZ</span> <span style="color:#e6db74">&#34;Enable BAZ feature&#34;</span> <span style="color:#e6db74">OFF</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>if(<span style="color:#e6db74">ENABLE_BAZ</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  add_subdirectory(<span style="color:#e6db74">baz</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>该语句将 <code>ENABLE_BAZ</code> 写入缓存，用户可以在后续配置时修改其值。如果使用 <code>set(VAR val CACHE TYPE &quot;doc&quot;)</code>，则在首次加入缓存后，除非加上 <code>FORCE</code>，否则后续同名缓存设置不会覆盖已存在值；当前目录 <code>set(VAR val)</code> 会屏蔽缓存中同名条目，直到该局部变量失效或被 <code>unset()</code> 删除(<a href="https://cmake.org/cmake/help/v3.0/command/set.html?utm_source=chatgpt.com" title="set — CMake 3.0.2 Documentation">cmake.org</a>, <a href="https://manpages.debian.org/jessie/cmake-data/cmake-commands.7.en.html?utm_source=chatgpt.com" title="cmake-commands(7) — cmake-data — Debian jessie — Debian Manpages">manpages.debian.org</a>)。</p>
</li>
</ul>
<hr>
<h2 id="5-optionuse_foo-示例及条件判断">5. <code>option(USE_FOO)</code> 示例及条件判断</h2>
<h3 id="51-option-本质与行为">5.1 <code>option()</code> 本质与行为</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>option(<span style="color:#e6db74">USE_FOO</span> <span style="color:#e6db74">&#34;Enable FOO support&#34;</span> <span style="color:#e6db74">OFF</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><ul>
<li>
<p><strong>含义</strong>：该命令定义一个<strong>缓存变量</strong> <code>USE_FOO</code>，并设置其默认值为 <code>OFF</code>。如果同名缓存变量已存在，则不会改写；如果用户通过命令行 <code>-DUSE_FOO=ON</code> 或在 cmake-gui 中修改，则以用户设置为准。初次执行时，<code>USE_FOO</code> 的值必然为 <code>OFF</code> 并保存在 <code>CMakeCache.txt</code> 中 (<a href="https://cmake.org/cmake/help/latest/command/option.html?utm_source=chatgpt.com" title="option — CMake 4.0.2 Documentation">cmake.org</a>, <a href="https://stackoverflow.com/questions/68409032/why-cmake-option-command-should-be-on-or-off?utm_source=chatgpt.com" title="Why CMake option command should be ON or OFF? - Stack Overflow">stackoverflow.com</a>)。</p>
</li>
<li>
<p><strong>作用域</strong>：</p>
<ul>
<li>
<p><strong>缓存作用域</strong>：无论在项目哪个目录执行，均会向缓存写入 <code>USE_FOO:BOOL=OFF</code>。</p>
</li>
<li>
<p><strong>目录作用域</strong>：调用 <code>option()</code> 并不会将 <code>USE_FOO</code> 绑定为普通目录变量，而是写入缓存；因此在同一项目的其他目录仅能通过 <code>${USE_FOO}</code> 或 <code>if(USE_FOO)</code> 读取其值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="52-条件判断的三种情况">5.2 条件判断的三种情况</h3>
<ol>
<li>
<p><strong><code>if(USE_FOO)</code></strong></p>
<ul>
<li>
<p><strong>语义</strong>：判断缓存变量 <code>USE_FOO</code> 的布尔值。当 <code>USE_FOO</code> 为 <code>ON</code>、<code>1</code>、<code>YES</code>、<code>TRUE</code> 等“真”时条件成立；若为 <code>OFF</code>、<code>0</code>、<code>FALSE</code>、空、<code>NOTFOUND</code> 或未定义，都视为“假”(<a href="https://cmake.org/cmake/help/v3.1/command/if.html?utm_source=chatgpt.com" title="if — CMake 3.1.3 Documentation">cmake.org</a>, <a href="https://stackoverflow.com/questions/68409032/why-cmake-option-command-should-be-on-or-off?utm_source=chatgpt.com" title="Why CMake option command should be ON or OFF? - Stack Overflow">stackoverflow.com</a>)。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>if(<span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;FOO 支持已启用&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>else()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;FOO 支持未启用&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>由于 <code>option()</code> 默认将 <code>USE_FOO</code> 设为 <code>OFF</code>，执行初次配置时，<code>if(USE_FOO)</code> 判断为假，会输出“FOO 支持未启用”。</p>
</li>
</ul>
</li>
<li>
<p><strong><code>if(DEFINED USE_FOO)</code></strong></p>
<ul>
<li>
<p><strong>语义</strong>：仅判断变量名 <code>USE_FOO</code> 是否在当前目录作用域或缓存中存在条目，与其具体值无关。由于 <code>option()</code> 已经在缓存中创建了对应条目，无论值为 <code>ON</code> 还是 <code>OFF</code>，<code>DEFINED USE_FOO</code> 都返回真；仅当从未调用 <code>option(USE_FOO …)</code> 或手动移除缓存条目时，该判断才为假(<a href="https://cmake.org/cmake/help/latest/command/if.html?utm_source=chatgpt.com" title="if — CMake 4.0.2 Documentation">cmake.org</a>, <a href="https://manpages.ubuntu.com/manpages/bionic/en/man7/cmake-commands.7.html?utm_source=chatgpt.com" title="Ubuntu Manpage: cmake-commands - CMake Language Command Reference">manpages.ubuntu.com</a>)。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>if(<span style="color:#e6db74">DEFINED</span> <span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;USE_FOO 已在缓存或目录中定义，当前值 = ${USE_FOO}&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>else()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;USE_FOO 未定义，需要先调用 option()&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>首次执行会输出“USE_FOO 已在缓存或目录中定义，当前值 = OFF”；若用户执行 <code>cmake --fresh</code> 删除缓存并未再次调用 <code>option()</code>，则输出“USE_FOO 未定义”。</p>
</li>
</ul>
</li>
<li>
<p><strong><code>if(NOT DEFINED USE_FOO)</code></strong></p>
<ul>
<li>
<p><strong>语义</strong>：与上述相反，仅在 <code>USE_FOO</code> 既不在缓存，也不在当前目录作用域时为真。由于 <code>option()</code> 已将其写入缓存，故此判断通常为假，除非缓存被删除且尚未到达 <code>option()</code> 那行代码(<a href="https://manpages.ubuntu.com/manpages/bionic/en/man7/cmake-commands.7.html?utm_source=chatgpt.com" title="Ubuntu Manpage: cmake-commands - CMake Language Command Reference">manpages.ubuntu.com</a>, <a href="https://cmake.org/cmake/help/latest/command/option.html?utm_source=chatgpt.com" title="option — CMake 4.0.2 Documentation">cmake.org</a>)。</p>
</li>
<li>
<p><strong>示例用法</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>if(<span style="color:#e6db74">NOT</span> <span style="color:#e6db74">DEFINED</span> <span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  option(<span style="color:#e6db74">USE_FOO</span> <span style="color:#e6db74">&#34;Enable FOO support&#34;</span> <span style="color:#e6db74">OFF</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div><p>保证了无论在何处首次调用该片段，都只会有一次“写入缓存”操作，避免在多个子模块重复定义而产生冲突。</p>
</li>
</ul>
</li>
</ol>
<h3 id="53-综合示例option-在多目录中的应用">5.3 综合示例：<code>option()</code> 在多目录中的应用</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>project_root/
</span></span><span style="display:flex;"><span>├── CMakeLists.txt
</span></span><span style="display:flex;"><span>└── libfoo/
</span></span><span style="display:flex;"><span>    └── CMakeLists.txt
</span></span></code></pre></div><ul>
<li>
<p><strong>project_root/CMakeLists.txt</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>cmake_minimum_required(<span style="color:#e6db74">VERSION</span> <span style="color:#e6db74">3.15</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>project(<span style="color:#e6db74">MyProject</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 若尚未定义 USE_FOO，则初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>if(<span style="color:#e6db74">NOT</span> <span style="color:#e6db74">DEFINED</span> <span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  option(<span style="color:#e6db74">USE_FOO</span> <span style="color:#e6db74">&#34;Enable FOO support&#34;</span> <span style="color:#e6db74">OFF</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>if(<span style="color:#e6db74">DEFINED</span> <span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;根目录：USE_FOO 已定义，当前值 = ${USE_FOO}&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>if(<span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;根目录：FOO 支持已启用&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>else()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;根目录：FOO 支持未启用&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>add_subdirectory(<span style="color:#e6db74">libfoo</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
<li>
<p><strong>libfoo/CMakeLists.txt</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span>if(<span style="color:#e6db74">DEFINED</span> <span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;libfoo：检测到 USE_FOO，当前值 = ${USE_FOO}&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>if(<span style="color:#e6db74">USE_FOO</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  add_library(<span style="color:#e6db74">foo</span> <span style="color:#e6db74">STATIC</span> <span style="color:#e6db74">foo.cpp</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;libfoo：已构建 foo 库&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>else()<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  message(<span style="color:#e6db74">STATUS</span> <span style="color:#e6db74">&#34;libfoo：跳过 foo 库构建&#34;</span>)<span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>endif()<span style="color:#960050;background-color:#1e0010">
</span></span></span></code></pre></div></li>
</ul>
<p><strong>执行流程示例</strong></p>
<ol>
<li>
<p><strong>第一次配置，命令行未指定 <code>-DUSE_FOO</code></strong></p>
<ul>
<li>
<p>根目录：<code>NOT DEFINED USE_FOO</code> 为真 → 执行 <code>option(USE_FOO ... OFF)</code> → 写入缓存；随后 <code>DEFINED USE_FOO</code> 与 <code>if(USE_FOO)</code> 分别输出 “已定义，OFF” 与 “未启用”。</p>
</li>
<li>
<p>进入 <code>libfoo</code>：<code>DEFINED USE_FOO</code> 為真 → 输出 “检测到 USE_FOO = OFF”；<code>if(USE_FOO)</code> 為假 → “跳过 foo 库构建”。</p>
</li>
</ul>
</li>
<li>
<p><strong>第一次配置，命令行显式指定 <code>-DUSE_FOO=ON</code></strong></p>
<ul>
<li>
<p>缓存已由命令行初始化，根目录 <code>NOT DEFINED USE_FOO</code> 为假 → 跳过 <code>option()</code>；<code>if(USE_FOO)</code> 为真 → 输出“FOO 支持已启用”。</p>
</li>
<li>
<p><code>libfoo</code> 同样检测到 <code>USE_FOO=ON</code> → 输出“检测到 USE_FOO = ON”，并构建 <code>foo</code> 库。</p>
</li>
</ul>
</li>
<li>
<p><strong>再次配置（保留缓存），不修改 <code>USE_FOO</code> 值</strong></p>
<ul>
<li>缓存已存在 → <code>NOT DEFINED USE_FOO</code> 为假 → 不再执行 <code>option()</code>，<code>if(USE_FOO)</code> 行为与上次保持一致。</li>
</ul>
</li>
</ol>
<p>通过上述示例可见，<code>option()</code> 作为缓存变量定义的方式，结合 <code>if(USE_FOO)</code>、<code>if(DEFINED USE_FOO)</code> 与 <code>if(NOT DEFINED USE_FOO)</code> 的判断，能够清晰地区分“是否已定义该选项”与“选项值为真/假”两种语义，避免冲突并支持多目录模块化管理(<a href="https://cmake.org/cmake/help/latest/command/option.html?utm_source=chatgpt.com" title="option — CMake 4.0.2 Documentation">cmake.org</a>, <a href="https://stackoverflow.com/questions/68409032/why-cmake-option-command-should-be-on-or-off?utm_source=chatgpt.com" title="Why CMake option command should be ON or OFF? - Stack Overflow">stackoverflow.com</a>)。</p>
<hr>
<h2 id="6-结论">6. 结论</h2>
<p>本文首先从 CMake 条件编译机制出发，详细分析了 <code>if()</code> 条件判断与生成器表达式的不同求值阶段及适用场景。随后，通过多个跨平台、多配置、可选依赖等工程实践示例，阐述了如何灵活运用条件编译实现功能模块化与构建可定制化。针对 CMake 的动态作用域模型，重点剖析了函数作用域、目录作用域与缓存作用域的查询逻辑，提醒开发者在 <code>if()</code> 语句块中定义变量时，要警惕持久化绑定对后续逻辑的影响。最后，以 <code>option(USE_FOO &quot;Enable FOO support&quot; OFF)</code> 为典型实例，演示其作为缓存变量的行为，并结合 <code>if(USE_FOO)</code>、<code>if(DEFINED USE_FOO)</code>、<code>if(NOT DEFINED USE_FOO)</code> 三种判断方式，帮助读者正确设计条件分支与选项管理。唯有深入理解 CMake 条件编译原理与变量作用域特性，方能构建出可维护性高、扩展性强的现代化 C/C++ 构建系统。</p>
<hr>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>
<p>CMake 官方文档：<code>option()</code> 命令说明, CMake 4.0.2 文档，检索于 2025 年 6 月，详见 (<a href="https://cmake.org/cmake/help/latest/command/option.html?utm_source=chatgpt.com" title="option — CMake 4.0.2 Documentation">cmake.org</a>)。</p>
</li>
<li>
<p>Tsyvarev, “Why CMake option command should be ON or OFF?”, Stack Overflow, Jul 16, 2021，详见 (<a href="https://stackoverflow.com/questions/68409032/why-cmake-option-command-should-be-on-or-off?utm_source=chatgpt.com" title="Why CMake option command should be ON or OFF? - Stack Overflow">stackoverflow.com</a>)。</p>
</li>
<li>
<p>CMake 官方文档：<code>if()</code> 命令说明, CMake 3.18.6 文档，检索于 2025 年 6 月，详见 (<a href="https://cmake.org/cmake/help/v3.18/command/if.html?utm_source=chatgpt.com" title="if — CMake 3.18.6 Documentation">cmake.org</a>, <a href="https://cmake.org/cmake/help/v3.1/command/if.html?utm_source=chatgpt.com" title="if — CMake 3.1.3 Documentation">cmake.org</a>)。</p>
</li>
<li>
<p>CMake 官方文档：语言手册—变量作用域章节, CMake 4.0.0-rc4 文档，检索于 2025 年 6 月，详见 (<a href="https://cmake.org/cmake/help/latest/manual/cmake-language.7.html?utm_source=chatgpt.com" title="cmake-language(7) — CMake 4.0.0-rc4 Documentation">cmake.org</a>, <a href="https://stuff.mit.edu/afs/athena/software/root_v6.12/arch/amd64_linux26/doc/cmake/html/manual/cmake-language.7.html?utm_source=chatgpt.com" title="cmake-language(7) — CMake 3.10.1 Documentation">stuff.mit.edu</a>)。</p>
</li>
<li>
<p>CMake 官方文档：缓存变量逻辑, CMake 3.0.2 文档，检索于 2025 年 6 月，详见 (<a href="https://cmake.org/cmake/help/v3.0/command/set.html?utm_source=chatgpt.com" title="set — CMake 3.0.2 Documentation">cmake.org</a>, <a href="https://manpages.debian.org/jessie/cmake-data/cmake-commands.7.en.html?utm_source=chatgpt.com" title="cmake-commands(7) — cmake-data — Debian jessie — Debian Manpages">manpages.debian.org</a>)。</p>
</li>
<li>
<p>CMake 官方文档：生成器表达式说明, CMake 3.24.4 文档，检索于 2025 年 6 月，详见 (<a href="https://cmake.org/cmake/help/v3.24/manual/cmake-generator-expressions.7.html?utm_source=chatgpt.com" title="cmake-generator-expressions(7) — CMake 3.24.4 Documentation">cmake.org</a>, <a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20Generator%20Expressions.html?utm_source=chatgpt.com" title="Step 4: Adding Generator Expressions — CMake 4.0.1 Documentation">cmake.org</a>)。</p>
</li>
<li>
<p>Mucha, Jeremi, “CMake Generator-Expressions”, Mar 1, 2021，详见 (<a href="https://jeremimucha.com/2021/03/cmake-generator-expressions/?utm_source=chatgpt.com" title="CMake Generator-Expressions | Jeremi Mucha">jeremimucha.com</a>, <a href="https://github.com/Kitware/CMake/blob/master/Help/manual/cmake-generator-expressions.7.rst?utm_source=chatgpt.com" title="CMake/Help/manual/cmake-generator-expressions.7.rst at master · Kitware/CMake · GitHub">github.com</a>)。</p>
</li>
</ol>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Lu Yang</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>784 words</span>
    <span>24 - 31 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#关键词">关键词</a></li>
    <li><a href="#1-引言">1. 引言</a></li>
    <li><a href="#2-cmake-条件编译原理">2. CMake 条件编译原理</a>
      <ul>
        <li><a href="#21-if-条件判断语法与行为">2.1 <code>if()</code> 条件判断语法与行为</a></li>
        <li><a href="#22-生成器表达式generator-expressions及延迟求值">2.2 生成器表达式（Generator Expressions）及延迟求值</a></li>
      </ul>
    </li>
    <li><a href="#3-工程实践灵活运用条件编译">3. 工程实践：灵活运用条件编译</a>
      <ul>
        <li><a href="#31-平台与编译器差异的编译选项设置">3.1 平台与编译器差异的编译选项设置</a></li>
        <li><a href="#32-多配置与编译选项管理">3.2 多配置与编译选项管理</a></li>
        <li><a href="#33-可选依赖与插件化架构">3.3 可选依赖与插件化架构</a></li>
      </ul>
    </li>
    <li><a href="#4-变量作用域管理">4. 变量作用域管理</a>
      <ul>
        <li><a href="#41-cmake-的动态作用域模型">4.1 CMake 的动态作用域模型</a></li>
        <li><a href="#42-条件逻辑与变量持久性陷阱">4.2 条件逻辑与变量持久性陷阱</a></li>
        <li><a href="#43-parent_scope-与-cache-的典型场景">4.3 <code>PARENT_SCOPE</code> 与 <code>CACHE</code> 的典型场景</a></li>
      </ul>
    </li>
    <li><a href="#5-optionuse_foo-示例及条件判断">5. <code>option(USE_FOO)</code> 示例及条件判断</a>
      <ul>
        <li><a href="#51-option-本质与行为">5.1 <code>option()</code> 本质与行为</a></li>
        <li><a href="#52-条件判断的三种情况">5.2 条件判断的三种情况</a></li>
        <li><a href="#53-综合示例option-在多目录中的应用">5.3 综合示例：<code>option()</code> 在多目录中的应用</a></li>
      </ul>
    </li>
    <li><a href="#6-结论">6. 结论</a></li>
    <li><a href="#参考文献">参考文献</a></li>
  </ul>
</nav><h3>Related</h3>
    <ul><li><a href="/posts/cmakeinclude_directories-%E4%B8%8E-target_include_directories-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">CMake：include_directories 与 target_include_directories 使用指南</a></li><li><a href="/posts/windows_vcpkg_boost/">windows vcpkg boost 开发环境</a></li><li><a href="/posts/linux-%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85-cmake/">📘 Linux 系统源码编译和安装 CMake</a></li></ul></aside></div>
  </div>
</body>
</html>

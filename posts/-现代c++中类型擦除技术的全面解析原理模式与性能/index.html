<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>📘 现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能 | LuyangのBlog</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="/posts/-%E7%8E%B0%E4%BB%A3c&#43;&#43;%E4%B8%AD%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%80%A7%E8%83%BD/">
  <meta property="og:site_name" content="LuyangのBlog">
  <meta property="og:title" content="📘 现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能">
  <meta property="og:description" content="📘现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能 第一部分：类型擦除的起源：连接静态与动态多态 本部分旨在阐明[[类型擦除]]技术所解决的根本问题，将其定位为一种旨在克服传统C&#43;&#43;[[多态]]技术局限性的高级[[解决方案]]。
1.1 C&#43;&#43;中的多态困境 在C&#43;&#43;中，[[多态]]性——即以统一接口处理不同类型对象的能力——是构建灵活、可扩展软件系统的基石。然而，实现多态的传统方法各自存在固有的局限性，这为类型擦除技术的出现提供了动机。
void * 方法 (C风格多态) 最原始的类型擦除形式是通过 void * 指针实现的。C标准库中的 qsort 函数便是典型范例，它能够对任意类型的数组进行排序，正是因为它通过 void * 接受数据。
这种方法的本质在于将任何类型的指针转换为一个通用的、无类型的指针，从而“擦除”了编译时的类型信息。然而，这种极致的灵活性带来了巨大的代价：类型安全的完全丧失。程序员必须承担将 void * 手动 reinterpret_cast 回原始正确类型的责任。这是一个极易出错的过程，一旦类型不匹配，便会立即导致未定义行为（[[Undefined Behavior]], UB）。此外，由于[[编译器]]在处理 void * 时对底层数据类型一无所知，它无法进行任何有意义的类型驱动优化，可能导致性能下降。
面向对象多态 (继承与虚函数) 面向对象编程（OOP）提供了C&#43;&#43;中实现运行时多态的惯用方法。该方法依赖于一个包含虚函数（virtual functions）的公共基类，各个具体类通过继承该基类并重写虚函数来实现多态行为。
这种模式的主要局限性在于其 侵入性（intrusive）。任何希望以多态方式使用的具体类型都 必须 公开继承自这个共同的基类。这在许多场景下是不可行或不理想的，例如，我们无法修改[[标准库类型]]（如 std::string）、[[内建类型]]（如 int）或来自第三方库的类型，让它们去继承我们的基类。
此外，这种方法存在“类型丢失”问题。当一个派生类对象通过基类引用或指针传递时，编译器在函数内部就“丢失”了该对象的真实类型信息。从编译器的角度看，它只知道这是一个基类对象。这使得某些操作变得异常困难，尤其是多态复制。若要复制一个基类指针指向的对象，必须依赖于额外的样板代码，如 clone() 虚函数模式，因为无法直接调用派生类的拷贝构造函数。这种设计还会在本不相关的类型之间建立紧密的耦合关系，迫使它们遵从同一个基类接口。
静态多态 (模板) 与运行时多态相对的是静态多态，主要通过C&#43;&#43;[[模板]]（[[Templates]]）实现。模板在编译期为每个使用的具体类型生成特化代码，从而保留了完整的类型信息。这使得编译器能够执行深度优化，如函数[[内联]]，从而获得极高的性能。
然而，模板的强大能力也伴随着一个核心限制：无法创建 [[异质容器]]（heterogeneous collections）。例如，std::vector&lt;MyClass&lt;int&gt;&gt; 和 std::vector&lt;MyClass&lt;double&gt;&gt; 是两种完全不同且不相关的类型，它们不能被存储在同一个容器中。为了处理不同类型，编译器会对模板进行“单态化”（monomorphization），为每个类型参数生成一份独立的代码实例，这可能导致最终二进制文件体积膨胀，即所谓的“代码膨胀”（code bloat）。
1.2 在现代C&#43;&#43;语境下定义类型擦除 “类型擦除”这一术语本身在C&#43;&#43;社区中存在一定的模糊性，它并非一个单一、被严格定义的语言特性，而是一系列技术和模式的统称 1。广义上，
void * 和继承都可以被视为某种形式的类型擦除。然而，在现代C&#43;&#43;的讨论中，尤其是在[[Sean Parent]]和[[Klaus Iglberger]]等专家的影响下，该术语通常指代一种更具体、更强大的设计模式，这也是本报告的核心焦点。
核心原则：现代C&#43;&#43;类型擦除是一种旨在 将接口与其实现解耦 的技术，它为 不相关的类型 提供了 非侵入式 的 运行时多态，同时保持了 值语义（value semantics）。">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-04T02:30:00+08:00">
    <meta property="article:modified_time" content="2025-06-04T02:30:00+08:00">
    <meta property="article:tag" content="Cpp">
    <meta property="article:tag" content="类型擦除">
    <meta property="article:tag" content="#SBO">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="📘 现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能">
  <meta name="twitter:description" content="📘现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能 第一部分：类型擦除的起源：连接静态与动态多态 本部分旨在阐明[[类型擦除]]技术所解决的根本问题，将其定位为一种旨在克服传统C&#43;&#43;[[多态]]技术局限性的高级[[解决方案]]。
1.1 C&#43;&#43;中的多态困境 在C&#43;&#43;中，[[多态]]性——即以统一接口处理不同类型对象的能力——是构建灵活、可扩展软件系统的基石。然而，实现多态的传统方法各自存在固有的局限性，这为类型擦除技术的出现提供了动机。
void * 方法 (C风格多态) 最原始的类型擦除形式是通过 void * 指针实现的。C标准库中的 qsort 函数便是典型范例，它能够对任意类型的数组进行排序，正是因为它通过 void * 接受数据。
这种方法的本质在于将任何类型的指针转换为一个通用的、无类型的指针，从而“擦除”了编译时的类型信息。然而，这种极致的灵活性带来了巨大的代价：类型安全的完全丧失。程序员必须承担将 void * 手动 reinterpret_cast 回原始正确类型的责任。这是一个极易出错的过程，一旦类型不匹配，便会立即导致未定义行为（[[Undefined Behavior]], UB）。此外，由于[[编译器]]在处理 void * 时对底层数据类型一无所知，它无法进行任何有意义的类型驱动优化，可能导致性能下降。
面向对象多态 (继承与虚函数) 面向对象编程（OOP）提供了C&#43;&#43;中实现运行时多态的惯用方法。该方法依赖于一个包含虚函数（virtual functions）的公共基类，各个具体类通过继承该基类并重写虚函数来实现多态行为。
这种模式的主要局限性在于其 侵入性（intrusive）。任何希望以多态方式使用的具体类型都 必须 公开继承自这个共同的基类。这在许多场景下是不可行或不理想的，例如，我们无法修改[[标准库类型]]（如 std::string）、[[内建类型]]（如 int）或来自第三方库的类型，让它们去继承我们的基类。
此外，这种方法存在“类型丢失”问题。当一个派生类对象通过基类引用或指针传递时，编译器在函数内部就“丢失”了该对象的真实类型信息。从编译器的角度看，它只知道这是一个基类对象。这使得某些操作变得异常困难，尤其是多态复制。若要复制一个基类指针指向的对象，必须依赖于额外的样板代码，如 clone() 虚函数模式，因为无法直接调用派生类的拷贝构造函数。这种设计还会在本不相关的类型之间建立紧密的耦合关系，迫使它们遵从同一个基类接口。
静态多态 (模板) 与运行时多态相对的是静态多态，主要通过C&#43;&#43;[[模板]]（[[Templates]]）实现。模板在编译期为每个使用的具体类型生成特化代码，从而保留了完整的类型信息。这使得编译器能够执行深度优化，如函数[[内联]]，从而获得极高的性能。
然而，模板的强大能力也伴随着一个核心限制：无法创建 [[异质容器]]（heterogeneous collections）。例如，std::vector&lt;MyClass&lt;int&gt;&gt; 和 std::vector&lt;MyClass&lt;double&gt;&gt; 是两种完全不同且不相关的类型，它们不能被存储在同一个容器中。为了处理不同类型，编译器会对模板进行“单态化”（monomorphization），为每个类型参数生成一份独立的代码实例，这可能导致最终二进制文件体积膨胀，即所谓的“代码膨胀”（code bloat）。
1.2 在现代C&#43;&#43;语境下定义类型擦除 “类型擦除”这一术语本身在C&#43;&#43;社区中存在一定的模糊性，它并非一个单一、被严格定义的语言特性，而是一系列技术和模式的统称 1。广义上，
void * 和继承都可以被视为某种形式的类型擦除。然而，在现代C&#43;&#43;的讨论中，尤其是在[[Sean Parent]]和[[Klaus Iglberger]]等专家的影响下，该术语通常指代一种更具体、更强大的设计模式，这也是本报告的核心焦点。
核心原则：现代C&#43;&#43;类型擦除是一种旨在 将接口与其实现解耦 的技术，它为 不相关的类型 提供了 非侵入式 的 运行时多态，同时保持了 值语义（value semantics）。">

      <link rel="stylesheet" href="/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css" integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H&#43;ZeT/jBpieRZ8=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/bundle.min.ffb26980ae2df7bdfe47815d8a3f0130f36070ee4a3320a5f22d16842be2537f.css" integrity="sha256-/7JpgK4t973&#43;R4Fdij8BMPNgcO5KMyCl8i0WhCviU38=" crossorigin="anonymous">

      <script src="/js/bundle.995e4ec99401021e081ec256bee66154ef7f4e5136809432513b2e6d014b4b1d.js" integrity="sha256-mV5OyZQBAh4IHsJWvuZhVO9/TlE2gJQyUTsubQFLSx0=" crossorigin="anonymous"></script><script defer src="/js/search/flexsearch.compact.64594b125f7b78bdf4fa8316955922bbebb1cd6baef3f16654bfca20309f18f8.js" integrity="sha256-ZFlLEl97eL30&#43;oMWlVkiu&#43;uxzWuu8/FmVL/KIDCfGPg="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="/" style="color: inherit;">LuyangのBlog</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="/features/"
      >Features</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="/features/"
      >Features</a>
    </div>
    <div class="nav-item">
      <a href="/about/"
      >About</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>📘 现代C&#43;&#43;中类型擦除技术的全面解析：原理、模式与性能</h1><time class="dim" datetime="2025-06-04T02:30:00&#43;08:00">June 4, 2025</time><div class="term-container"><div class="tag">
        <a href="/tags/cpp/">#cpp</a>
      </div><div class="tag">
        <a href="/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/">#类型擦除</a>
      </div><div class="tag">
        <a href="/tags/%23sbo/">##SBO</a>
      </div></ol></div>
  <section class="page-section"><h1 id="现代c中类型擦除技术的全面解析原理模式与性能">📘现代C++中类型擦除技术的全面解析：原理、模式与性能</h1>
<h2 id="第一部分类型擦除的起源连接静态与动态多态">第一部分：类型擦除的起源：连接静态与动态多态</h2>
<p>本部分旨在阐明[[类型擦除]]技术所解决的根本问题，将其定位为一种旨在克服传统C++[[多态]]技术局限性的高级[[解决方案]]。</p>
<h3 id="11-c中的多态困境">1.1 C++中的多态困境</h3>
<p>在C++中，[[多态]]性——即<strong>以统一接口处理不同类型对象的能力</strong>——是构建灵活、可扩展软件系统的基石。然而，实现多态的传统方法各自存在固有的局限性，这为类型擦除技术的出现提供了动机。</p>
<h4 id="void--方法-c风格多态"><code>void *</code> 方法 (C风格多态)</h4>
<p>最原始的类型擦除形式是通过 <code>void *</code> 指针实现的。C标准库中的 <code>qsort</code> 函数便是典型范例，它能够对任意类型的数组进行排序，正是因为它通过 <code>void *</code> 接受数据。</p>
<p>这种方法的本质在于将任何类型的指针转换为一个通用的、无类型的指针，从而“擦除”了编译时的类型信息。然而，这种极致的灵活性带来了<strong>巨大的代价</strong>：<strong>类型安全的完全丧失</strong>。程序员必须承担将 <code>void *</code> 手动 <code>reinterpret_cast</code> 回原始正确类型的责任。这是一个极易出错的过程，一旦类型不匹配，便会立即导致未定义行为（[[Undefined Behavior]], UB）。此外，由于[[编译器]]在处理 <code>void *</code> 时对底层数据类型一无所知，它<strong>无法进行任何有意义的类型驱动优化</strong>，可能导致<strong>性能下降</strong>。</p>
<h4 id="面向对象多态-继承与虚函数">面向对象多态 (继承与虚函数)</h4>
<p>面向对象编程（OOP）提供了C++中实现运行时多态的惯用方法。该方法依赖于一个包含虚函数（virtual functions）的公共基类，各个具体类通过继承该基类并重写虚函数来实现多态行为。</p>
<p>这种模式的主要局限性在于其 <strong>侵入性（intrusive）</strong>。任何希望以多态方式使用的具体类型都 <strong>必须</strong> 公开继承自这个共同的基类。这在许多场景下是不可行或不理想的，例如，我们无法修改[[标准库类型]]（如 <code>std::string</code>）、[[内建类型]]（如 <code>int</code>）或来自第三方库的类型，让它们去继承我们的基类。</p>
<p>此外，这种方法存在“类型丢失”问题。当一个派生类对象通过基类引用或指针传递时，编译器在函数内部就“丢失”了该对象的真实类型信息。从编译器的角度看，它只知道这是一个基类对象。这使得某些操作变得异常困难，尤其是多态复制。若要复制一个基类指针指向的对象，必须依赖于额外的样板代码，如 <code>clone()</code> 虚函数模式，因为无法直接调用派生类的拷贝构造函数。这种设计还会在本不相关的类型之间建立紧密的耦合关系，迫使它们遵从同一个基类接口。</p>
<h4 id="静态多态-模板">静态多态 (模板)</h4>
<p>与运行时多态相对的是静态多态，主要通过C++[[模板]]（[[Templates]]）实现。模板在编译期为每个使用的具体类型生成特化代码，从而保留了完整的类型信息。这使得编译器能够执行深度优化，如函数[[内联]]，从而获得<strong>极高的性能</strong>。</p>
<p>然而，模板的强大能力也伴随着一个核心限制：无法创建 [[异质容器]]（heterogeneous collections）。例如，<code>std::vector&lt;MyClass&lt;int&gt;&gt;</code> 和 <code>std::vector&lt;MyClass&lt;double&gt;&gt;</code> 是两种完全不同且不相关的类型，它们不能被存储在同一个容器中。为了处理不同类型，编译器会对模板进行“单态化”（monomorphization），为每个类型参数生成一份独立的代码实例，这可能导致最终二进制文件体积膨胀，即所谓的“代码膨胀”（code bloat）。</p>
<h3 id="12-在现代c语境下定义类型擦除">1.2 在现代C++语境下定义类型擦除</h3>
<p>“类型擦除”这一术语本身在C++社区中存在一定的模糊性，它并非一个单一、被严格定义的语言特性，而是一系列技术和模式的统称 1。广义上，</p>
<p><code>void *</code> 和继承都可以被视为某种形式的类型擦除。然而，在现代C++的讨论中，尤其是在[[Sean Parent]]和[[Klaus Iglberger]]等专家的影响下，该术语通常指代一种更具体、更强大的设计模式，这也是本报告的核心焦点。</p>
<p><strong>核心原则</strong>：现代C++类型擦除是一种旨在 <strong>将接口与其实现解耦</strong> 的技术，它为 <strong>不相关的类型</strong> 提供了 <strong>非侵入式</strong> 的 <strong>运行时多态</strong>，同时保持了 <strong>值语义（value semantics）</strong>。</p>
<p>其关键特征如下：</p>
<ul>
<li><strong>非侵入性 (Non-Intrusive)</strong>：被“擦除”的类型无需继承自某个公共基类。它们只需要在语法和语义上满足一个特定的概念（Concept），即所谓的“鸭子类型”（duck typing）——如果它走起来像鸭子，叫起来也像鸭子，那么它就是一只鸭子 4。</li>
<li><strong>值语义 (Value Semantics)</strong>：类型擦除的包装器对象（wrapper）表现得像一个普通的值类型。它可以被复制、移动，并直接存储在标准容器中（如 std::vector），这与传统面向对象多态所要求的指针语义形成鲜明对比 6。</li>
<li><strong>类型安全 (Type-Safety)</strong>：与 void* 不同，该技术是类型安全的。所有操作在运行时都会被正确地分派到对应的实现上。当尝试以错误的类型访问底层对象时，系统会以安全的方式处理（通常是抛出异常），而不会导致未定义行为 1。</li>
</ul>
<p>为了清晰地展现这些多态技术的权衡，下表进行了总结。</p>
<p><strong>表1：C++多态技术对比</strong></p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性/指标</th>
          <th style="text-align: left">C风格 (void*)</th>
          <th style="text-align: left">面向对象 (继承)</th>
          <th style="text-align: left">静态多态 (模板)</th>
          <th style="text-align: left">类型擦除 (现代模式)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>类型安全</strong></td>
          <td style="text-align: left">否</td>
          <td style="text-align: left">是</td>
          <td style="text-align: left">是</td>
          <td style="text-align: left">是</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>侵入性</strong></td>
          <td style="text-align: left">非侵入式</td>
          <td style="text-align: left">侵入式</td>
          <td style="text-align: left">非侵入式</td>
          <td style="text-align: left"><strong>非侵入式</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>运行时开销</strong></td>
          <td style="text-align: left">低（指针解引用）</td>
          <td style="text-align: left">中（虚函数表查找）</td>
          <td style="text-align: left">无（编译期解析）</td>
          <td style="text-align: left">中（虚函数表查找或函数指针调用）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>值语义</strong></td>
          <td style="text-align: left">否</td>
          <td style="text-align: left">否（需要指针）</td>
          <td style="text-align: left">是</td>
          <td style="text-align: left"><strong>是</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>异质容器</strong></td>
          <td style="text-align: left">是</td>
          <td style="text-align: left">是（通过基类指针）</td>
          <td style="text-align: left">否</td>
          <td style="text-align: left"><strong>是</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>实现复杂度</strong></td>
          <td style="text-align: left">低</td>
          <td style="text-align: left">中</td>
          <td style="text-align: left">中</td>
          <td style="text-align: left">高</td>
      </tr>
  </tbody>
</table>
<p>这张表清晰地揭示了各种方法的优劣。<strong><code>void *</code> 虽灵活但危险；继承虽安全但具侵入性且牺牲了值语义；模板性能优异但无法用于异质容器。现代类型擦除技术正是在这个背景下应运而生，它巧妙地结合了各方优点，提供了一种在运行时处理异质对象集合的、兼具类型安全、非侵入性和值语义的强大解决方案。</strong></p>
<h2 id="第二部分经典实现concept-model模式">第二部分：经典实现：Concept-Model模式</h2>
<p>本部分将深入剖析实现类型擦除最经典、最强大的“Concept-Model”（概念-模型）模式。此模式并非临时起意的技巧，而是对多个成熟设计模式的精妙组合，从而赋予其坚实的软件工程基础。</p>
<h3 id="21-解构体系架构设计模式的组合">2.1 解构体系架构：设计模式的组合</h3>
<p>著名C++专家[[Klaus Iglberger]]指出，“Concept-Model”模式的优雅之处在于它并非孤立存在，而是 <strong>桥接模式（Bridge）</strong>、<strong>原型模式（Prototype）</strong> 与 <strong>外部多态（External Polymorphism）</strong> 思想的有机结合。从这个视角出发，我们能更深刻地理解该技术为何如此健壮和灵活。</p>
<h4 id="句柄-handle桥接模式的抽象部分">句柄 (Handle)：桥接模式的抽象部分</h4>
<p>句柄是面向客户的、公开的、非模板的类（例如，我们即将实现的 Drawable 类）。它是用户与之交互的唯一接口。</p>
<ul>
<li><strong>在桥接模式中的角色</strong>：句柄扮演了桥接模式中的“抽象部分”（Abstraction）。它将客户端代码与多态的实现细节完全解耦。由于句柄类本身不是模板，其大小在编译期是固定且已知的，这使得它可以像普通值一样被复制、移动和存储，从而实现了值语义。句柄内部通常持有一个指向“概念”（Concept）接口的智能指针（如 std::unique_ptr）6。</li>
</ul>
<h4 id="概念-concept桥接模式的实现者接口">概念 (Concept)：桥接模式的实现者接口</h4>
<p>概念是一个内部的、私有的抽象基类（例如，DrawableConcept）。它通过纯虚函数定义了一套所有具体类型都必须满足的操作契约。</p>
<ul>
<li><strong>角色</strong>：它定义了被擦除类型必须满足的“概念”。在桥接模式中，它对应“实现者接口”（Implementor）。句柄将所有操作委托给这个接口，实现了接口与实现的分离 5。</li>
</ul>
<h4 id="模型-model具体的实现者与适配器">模型 (Model)：具体的实现者与适配器</h4>
<p>模型是一个内部的、私有的模板类（例如，<code>DrawableModel&lt;T&gt;</code>），它继承自“概念”接口。</p>
<ul>
<li><strong>角色</strong>：它为具体的类型 T “建模”，使其符合“概念”接口。模型内部持有一个类型为 T 的对象实例，并实现“概念”接口中声明的纯虚函数。其实现方式是将调用 <strong>转发（forward）</strong> 给内部持有的 T 对象。从这个角度看，模型也扮演了 <strong>适配器模式（Adapter）</strong> 的角色，它适配了具体类型 T 的接口以满足 Concept 接口的要求。</li>
</ul>
<h4 id="clone-方法原型模式的应用">clone() 方法：原型模式的应用</h4>
<p>为了实现真正的多态复制（即支持值语义的核心），必须解决传统多态中无法直接复制派生类对象的问题。</p>
<ul>
<li><strong>角色</strong>：解决方案是在“概念”接口中增加一个纯虚的 clone() 方法。DrawableModel&lt;T&gt; 则通过调用自身的拷贝构造函数来实现这个方法，返回一个新创建的、指向 DrawableModel&lt;T&gt; 实例的智能指针（例如，return std::make_unique&lt;Model&lt;T&gt;&gt;(*this);）。这种“通过复制自身来创建新对象”的机制，正是 <strong>原型模式（Prototype）</strong> 的经典应用。它优雅地解决了在基类层面进行多态对象深拷贝的难题 5。</li>
</ul>
<h3 id="22-一个完整的可编译示例drawable-对象">2.2 一个完整的可编译示例：Drawable 对象</h3>
<p>下面我们将综合上述理论，提供一个完整的、经过详尽注释的C++20代码示例。该示例综合了研究资料中的优秀实践。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// --- 1. 待擦除的具体类型 ---
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 这些是我们将要通过类型擦除技术统一处理的类。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 它们之间没有任何继承关系，唯一的共同点是都提供了一个 `draw(std::ostream&amp;)` 方法。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> Circle(<span style="color:#66d9ef">double</span> radius) <span style="color:#f92672">:</span> m_radius(radius) {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Drawing a Circle with radius &#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_radius <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> m_radius;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Square</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> Square(<span style="color:#66d9ef">double</span> side) <span style="color:#f92672">:</span> m_side(side) {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Drawing a Square with side &#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_side <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> m_side;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Triangle</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> Triangle(<span style="color:#66d9ef">double</span> base, <span style="color:#66d9ef">double</span> height) <span style="color:#f92672">:</span> m_base(base), m_height(height) {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        out <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Drawing a Triangle with base &#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_base <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; and height &#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_height <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> m_base;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> m_height;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// --- 2. 类型擦除包装器 (Handle) ---
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// `Drawable` 是公开的句柄类，用户通过它与不同形状进行交互。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 它本身不是模板，因此可以存储在标准容器中。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Drawable</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 模板构造函数，接受任何类型 T 的对象。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这是类型擦除的入口点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    Drawable(T shape)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 通过 make_unique 创建一个 Model&lt;T&gt; 的实例，并将其存储在 pimpl 中。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// pimpl 的类型是 Concept*，从而“擦除”了 T 的具体类型。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">:</span> pimpl(std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Model<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>(std<span style="color:#f92672">::</span>move(shape))) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 拷贝构造函数，实现多态复制。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Drawable(<span style="color:#66d9ef">const</span> Drawable<span style="color:#f92672">&amp;</span> other) <span style="color:#f92672">:</span> pimpl(other.pimpl<span style="color:#f92672">-&gt;</span>clone()) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 拷贝赋值运算符。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Drawable<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Drawable<span style="color:#f92672">&amp;</span> other) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 使用 copy-and-swap 惯用法保证强异常安全。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pimpl <span style="color:#f92672">=</span> other.pimpl<span style="color:#f92672">-&gt;</span>clone();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 移动构造函数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Drawable(Drawable<span style="color:#f92672">&amp;&amp;</span> other) <span style="color:#66d9ef">noexcept</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 移动赋值运算符。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Drawable<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(Drawable<span style="color:#f92672">&amp;&amp;</span> other) <span style="color:#66d9ef">noexcept</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 析构函数（默认实现即可，因为 unique_ptr 会自动管理内存）。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>Drawable() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 公开的 draw 方法，将调用委托给内部实现。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        pimpl<span style="color:#f92672">-&gt;</span>draw(out);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// --- 内部实现：Concept 和 Model ---
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2a. Concept (概念): 定义了所有可绘制对象必须遵守的内部接口。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Concept</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Concept() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 原型模式：定义一个纯虚的 clone 方法用于多态复制。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">virtual</span> std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Concept<span style="color:#f92672">&gt;</span> clone() <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2b. Model (模型): 模板类，用于将任意类型 T 适配到 Concept 接口。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Model</span> <span style="color:#66d9ef">final</span> <span style="color:#f92672">:</span> Concept {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 构造函数，持有具体类型 T 的一个实例。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">Model</span>(T shape) <span style="color:#f92672">:</span> m_shape(std<span style="color:#f92672">::</span>move(shape)) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 实现 Concept 的 draw 接口，将调用转发给持有的 T 对象。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            m_shape.draw(out);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 实现多态复制，通过拷贝自身来创建一个新的 Model&lt;T&gt;。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Concept<span style="color:#f92672">&gt;</span> clone() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">override</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Model<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        T m_shape; <span style="color:#75715e">// 持有的具体形状对象。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 桥接模式的核心：句柄持有一个指向实现接口的指针。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这就是所谓的 &#34;Pointer to Implementation&#34; (PIMPL)。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Concept<span style="color:#f92672">&gt;</span> pimpl;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// --- 3. 客户端代码 ---
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 一个函数，接受一个包含不同 Drawable 对象的 vector，并依次绘制它们。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw_all_shapes</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Drawable<span style="color:#f92672">&gt;&amp;</span> shapes) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--- Drawing all shapes ---</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> shape : shapes) {
</span></span><span style="display:flex;"><span>        shape.draw(std<span style="color:#f92672">::</span>cout);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--------------------------</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个异质容器，它可以存储任何满足 &#34;Drawable&#34; 概念的对象。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Drawable<span style="color:#f92672">&gt;</span> document;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 添加不同类型的对象。注意，我们直接传递具体类型对象，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Drawable 的模板构造函数会自动处理类型擦除。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    document.emplace_back(Circle(<span style="color:#ae81ff">2.0</span>));
</span></span><span style="display:flex;"><span>    document.emplace_back(Square(<span style="color:#ae81ff">3.5</span>));
</span></span><span style="display:flex;"><span>    document.emplace_back(Triangle(<span style="color:#ae81ff">4.0</span>, <span style="color:#ae81ff">5.0</span>));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 第一次绘制所有形状。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    draw_all_shapes(document);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 演示值语义：可以对容器中的对象进行复制。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Drawable<span style="color:#f92672">&gt;</span> copied_document <span style="color:#f92672">=</span> document;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改原始 document 中的一个元素。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    document <span style="color:#f92672">=</span> Square(<span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--- After modifying original document ---</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    draw_all_shapes(document);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;--- Drawing copied document (should be unchanged) ---</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    draw_all_shapes(copied_document);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="23-深入底层追踪擦除机制">2.3 深入底层：追踪擦除机制</h3>
<p>为了完全理解类型擦除的工作原理，我们来追踪上述示例中的关键操作。</p>
<ul>
<li>构造过程: <code>Drawable d = Circle(5.0);</code>
<ol>
<li>一个 <code>Circle</code> 类型的临时对象被创建。</li>
<li><code>Drawable</code> 的模板构造函数 <code>template &lt;typename T&gt; Drawable(T shape)</code> 被调用，其中 <code>T</code> 被推导为 <code>Circle</code>。</li>
<li>在构造函数体内，<code>std::make_unique&lt;Model&lt;Circle&gt;&gt;(std::move(shape))</code> 执行。这会在堆上分配内存，并构造一个 <code>Model&lt;Circle&gt;</code> 对象。<code>Circle</code> 临时对象被移动到 <code>Model&lt;Circle&gt;</code> 的成员 <code>m_shape</code> 中。</li>
<li><code>std::make_unique</code> 返回一个 <code>std::unique_ptr&lt;Model&lt;Circle&gt;&gt;</code>。</li>
<li>由于 <code>Model&lt;Circle&gt;</code> 继承自 <code>Concept</code>，这个 <code>std::unique_ptr&lt;Model&lt;Circle&gt;&gt;</code> 被隐式向上转型为 <code>std::unique_ptr&lt;Concept&gt;</code>，并被用来初始化 <code>Drawable</code> 对象的成员 <code>pimpl</code>。至此，<code>Circle</code> 的类型信息在 <code>Drawable</code> 的公开接口层面被“擦除”，只剩下 <code>Concept</code> 接口。</li>
</ol>
</li>
<li>多态调用: <code>d.draw(std::cout)</code>;
<ol>
<li>客户端代码调用 <code>Drawable</code> 对象的 <code>draw</code> 方法。</li>
<li><code>Drawable::draw</code> 将调用转发给其 <code>pimpl</code> 成员：<code>pimpl-&gt;draw(out);</code>。</li>
<li><code>pimpl</code> 是一个 <code>std::unique_ptr&lt;Concept&gt;</code>，因此 <code>pimpl-&gt;draw(out)</code> 是一个通过基类指针进行的虚函数调用。</li>
<li>C++运行时系统查找与 pimpl 指向的实际对象（即 <code>Model&lt;Circle&gt;</code> 对象）相关联的虚函数表（<code>vtable</code>）。</li>
<li>通过<code>vtable</code>，调用被分派到 <code>Model&lt;Circle&gt;::draw</code> 的正确实现。</li>
<li><code>Model&lt;Circle&gt;::draw</code> 方法将其调用再次转发给它所持有的 <code>m_shape</code> 成员（一个 <code>Circle</code> 对象），最终执行 <code>m_shape.draw(out)</code>。</li>
</ol>
</li>
<li>多态复制: <code>Drawable d2 = d;</code>
<ol>
<li><code>Drawable</code> 的拷贝构造函数 <code>Drawable(const Drawable&amp; other)</code> 被调用，其中 <code>other</code> 是 <code>d</code>。</li>
<li>构造函数体执行 <code>pimpl(other.pimpl-&gt;clone())</code>。</li>
<li><code>other.pimpl-&gt;clone()</code> 是一个虚函数调用。由于 <code>other.pimpl</code> 指向一个 <code>Model&lt;Circle&gt;</code> 对象，实际被调用的是 <code>Model&lt;Circle&gt;::clone()</code>。</li>
<li><code>Model&lt;Circle&gt;::clone()</code> 执行 <code>return std::make_unique&lt;Model&lt;T&gt;&gt;(*this);</code>，其中 <code>T</code> 是 <code>Circle</code>。这会调用 <code>Model&lt;Circle&gt;</code> 的拷贝构造函数，在堆上创建一个 <code>d.pimpl</code> 所指向对象的完整深拷贝。</li>
<li>这个新创建的 <code>std::unique_ptr&lt;Model&lt;Circle&gt;&gt;</code> 向上转型为 <code>std::unique_ptr&lt;Concept&gt;</code>，并用于初始化 <code>d2</code> 的 <code>pimpl</code> 成员。最终，<code>d2</code> 成为 <code>d</code> 的一个完全独立的深拷贝。</li>
</ol>
</li>
</ul>
<h2 id="第三部分高级实现与优化策略">第三部分：高级实现与优化策略</h2>
<p>虽然 Concept-Model 模式功能强大，但其基础实现存在性能开销，主要源于<strong>强制的堆分配</strong>。本部分将探讨几种高级优化技术，旨在降低这些开销，提升类型擦除对象的性能。</p>
<h3 id="31-小缓冲区优化-small-buffer-optimization---sbo">3.1 小缓冲区优化 (Small Buffer Optimization - SBO)</h3>
<p><strong>原理</strong>：SBO是针对类型擦除最重要和最常见的性能优化。其核心思想是，对于尺寸较小的对象，避免在堆上动态分配内存，而是直接将其存储在句柄对象内部预先分配的一块缓冲区中 6。只有当对象尺寸超过缓冲区大小时，才回退到传统的堆分配策略。</p>
<p><strong>实现</strong>：</p>
<ol>
<li><strong>缓冲区定义</strong>：在句柄类（如 Drawable）内部，使用 <code>std::aligned_storage</code>（C++11/14）或 <code>std::byte</code>（C++17及以后）定义一块具有特定大小和对齐要求的原始内存缓冲区。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 在 Drawable 类中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> size_t SBO_SIZE <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>;      <span style="color:#75715e">// 缓冲区大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> size_t SBO_ALIGN <span style="color:#f92672">=</span> <span style="color:#66d9ef">alignof</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>); <span style="color:#75715e">// 对齐要求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>aligned_storage_t<span style="color:#f92672">&lt;</span>SBO_SIZE, SBO_ALIGN<span style="color:#f92672">&gt;</span> m_buffer;
</span></span></code></pre></div><ol start="2">
<li><strong>构造时的决策</strong>：在模板构造函数中，使用 <code>static_assert</code> 或<code> if constexpr</code>（C++17）在编译期检查被包装的 <code>Model&lt;T&gt;</code> 对象的大小和对齐是否满足SBO条件。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>Drawable(T shape) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> Model_t <span style="color:#f92672">=</span> Model<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (<span style="color:#66d9ef">sizeof</span>(Model_t) <span style="color:#f92672">&lt;=</span> SBO_SIZE <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">alignof</span>(Model_t) <span style="color:#f92672">&lt;=</span> SBO_ALIGN) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// SBO路径：使用 placement new 在缓冲区内构造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> (<span style="color:#f92672">&amp;</span>m_buffer) Model_t(std<span style="color:#f92672">::</span>move(shape));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 还需要存储一个函数指针来调用正确的析构函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        m_destructor <span style="color:#f92672">=</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> self) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>destroy_at(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Model_t<span style="color:#f92672">*&gt;</span>(self));
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 堆分配路径：回退到使用智能指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pimpl <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span>Model_t<span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>move(shape));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="3">
<li><strong>生命周期管理</strong>：当使用SBO时，句柄对象必须负责手动管理缓冲区内对象的生命周期。这意味着在句柄的析构函数或赋值运算符中，必须显式调用存储在缓冲区中对象的析构函数 21。这通常通过存储一个析构函数指针来实现。</li>
<li><strong>指针别名与 <code>std::launder</code></strong>：当一个对象被销毁后，其占用的存储空间被重新用于创建新对象时，可能会违反C++的严格别名规则（strict aliasing rules）。<code>std::launder</code>（C++17）可以作为一种解决方案，它告知编译器这块内存的生命周期已经重新开始，从而防止编译器进行可能导致错误的激进优化。</li>
</ol>
<p><strong>权衡分析</strong>：SBO的优势是显著的。对于大量的小对象，它能消除堆分配的开销，减少内存碎片，并因数据局部性改善而提升缓存性能。其代价是，句柄对象 sizeof(Drawable) 的体积会增大，即使对于那些因尺寸过大而必须存储在堆上的对象，这个缓冲区依然存在，造成了一定的空间浪费。因此，SBO缓冲区的尺寸选择是一个关键的设计决策，需要根据应用的典型使用场景来权衡。</p>
<h3 id="32-通过函数指针进行手动虚分派">3.2 通过函数指针进行手动虚分派</h3>
<p><strong>原理</strong>：作为使用C++原生虚函数表（vtable）的替代方案，句柄可以直接存储一个指向函数指针表的指针，这个表手动模拟了vtable的功能。每个函数指针对应“概念”中的一个操作 6。</p>
<p><strong>实现</strong>：</p>
<ol>
<li><strong>操作表</strong>：定义一个结构体，包含所有操作的函数指针。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">OperationsVTable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>draw)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>destroy)(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>Concept<span style="color:#f92672">&gt;</span> (<span style="color:#f92672">*</span>clone)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ol start="2">
<li><strong>句柄存储</strong>：句柄对象存储一个 void* 数据指针，指向具体对象，以及一个指向静态 OperationsVTable 实例的指针。</li>
<li><strong>静态分派函数</strong>：为每种具体类型 T 和每个操作定义一个静态的、模板化的分派函数。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> draw_impl(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> self, std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">*&gt;</span>(self)<span style="color:#f92672">-&gt;</span>draw(out);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="4">
<li><strong>构造</strong>：模板构造函数负责初始化 <code>void *</code> 数据指针，并设置vtable指针指向一个为该类型 T 特化的静态 OperationsVTable 实例。</li>
</ol>
<p><strong>分析</strong>：这种方法将数据（<code>void *</code>）与行为（<code>OperationsVTable *</code>）解耦。它的主要代价是句柄的大小会随着操作数量的增加而线性增长 22。对于只有一个或少数几个操作的接口，这种方法的开销可能比完整的vtable机制更小，因为它避免了vtable指针的额外间接层。</p>
<p><code>std::function</code> 的实现正是这种模式的绝佳范例。</p>
<h3 id="33-基于策略的设计以实现最大灵活性">3.3 基于策略的设计以实现最大灵活性</h3>
<p><strong>原理</strong>：与其在句柄类中硬编码存储策略（总是堆分配或总是SBO），不如将存储策略本身作为句柄类的一个模板参数，即策略（Policy）。这是一种强大的元编程技术，被称为基于策略的设计（Policy-Based Design）23。</p>
<p><strong>实现</strong>：</p>
<ol>
<li><strong>定义策略类</strong>：创建不同的存储策略模板，每个策略类都定义了如何分配、销毁和访问被包装的对象。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DynamicStoragePolicy</span> { <span style="color:#75715e">/*... */</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>size_t Size, size_t Align<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SBOStoragePolicy</span> { <span style="color:#75715e">/*... */</span> };
</span></span></code></pre></div><ol start="2">
<li><strong>参数化句柄</strong>：让句柄类接受一个存储策略作为其模板参数。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> StoragePolicy<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shape</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    StoragePolicy storage;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    Shape(T concrete_shape) <span style="color:#f92672">:</span> storage(std<span style="color:#f92672">::</span>move(concrete_shape)) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) <span style="color:#66d9ef">const</span> { storage.get()<span style="color:#f92672">-&gt;</span>draw(out); }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><ol start="3">
<li><strong>使用</strong>：用户可以根据具体需求在编译时选择最合适的策略。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 使用动态分配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> DynamicShape <span style="color:#f92672">=</span> Shape<span style="color:#f92672">&lt;</span>DynamicStoragePolicy<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用32字节的SBO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> SmallShape <span style="color:#f92672">=</span> Shape<span style="color:#f92672">&lt;</span>SBOStoragePolicy<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">32</span>, <span style="color:#66d9ef">alignof</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&gt;&gt;</span>;
</span></span></code></pre></div><p><strong>优势</strong>：这种方法提供了极高的灵活性，允许用户为不同的应用场景量身定制类型擦除对象的行为，从而在性能和资源使用之间做出最优的权衡。</p>
<h2 id="第四部分c标准库中的类型擦除">第四部分：C++标准库中的类型擦除</h2>
<p>C++标准库本身就提供了几个利用类型擦除技术构建的强大组件。分析它们的设计与实现，有助于我们深入理解类型擦除的实际应用和权衡。</p>
<h3 id="41-案例研究stdfunction---多态可调用对象">4.1 案例研究：<code>std::function</code> - 多态可调用对象</h3>
<p><strong>接口分析</strong>：自C++11起，<code>std::function</code>（定义于 <code>&lt;functional&gt;</code> 头文件）便成为标准库的一部分。根据标准（如 ISO/IEC 14882:2011 及后续版本），<code>std::function</code> 是一个通用的多态函数包装器。它可以存储、复制和调用任何满足 CopyConstructible 的可调用（Callable）目标，包括普通函数指针、成员函数指针、lambda表达式以及函数对象（functors)。</p>
<p><strong>底层机制</strong>：</p>
<ul>
<li><code>std::function</code> 是 <strong>手动虚分派</strong> 模式的典范。它内部并不依赖于一个带有虚函数的 Concept 基类。</li>
<li>取而代之的是，它通常存储一小组函数指针来管理被包装的可调用对象：一个用于 <strong>调用</strong>（invoke）的指针，一个用于 <strong>构造/复制</strong>（construct/copy）的指针，以及一个用于 <strong>销毁</strong>（destroy）的指针 。</li>
<li>被包装的可调用对象本身，则根据其大小采用不同策略存储。对于小的可调用对象，如裸函数指针或捕获少量变量的lambda，实现通常会采用 <strong>SBO</strong>，将其直接存放在 std::function 对象内部的缓冲区中，以避免堆分配 18。对于无法放入缓冲区的大型可调用对象，则会在堆上分配内存。C++标准鼓励但不强制要求SBO的实现（见<code>[func.wrap.func.con]</code>）。</li>
</ul>
<p><strong>标准引用</strong>：<code>std::function</code> 的规范在C++标准中有详细定义，例如在C++20工作草案N4861的章节 <code>[func.wrap.func]</code> 中。</p>
<h3 id="42-案例研究stdany---类型安全的-void-">4.2 案例研究：<code>std::any</code> - 类型安全的 <code>void *</code></h3>
<p><strong>接口分析</strong>：<code>std::any</code>（定义于 <code>&lt;any&gt;</code> 头文件）是C++17引入的另一个类型擦除工具。标准（如 ISO/IEC 14882:2017 及后续版本）将其描述为一个类型安全的、用于存储任意单个 CopyConstructible 类型值的容器。它提供了 <code>any_cast</code> 用于安全地取回被存储的值，以及 <code>type()</code> 方法来查询被存储对象的 <code>std::type_info</code>。</p>
<p><strong>底层机制</strong>：</p>
<ul>
<li><code>std::any</code> 的实现是 <strong>Concept-Model</strong> 模式的完美体现。</li>
<li>其内部实现依赖于一个类似vtable的机制（可以通过继承或手动管理的函数指针表实现），来管理所含对象的生命周期（复制、移动、销毁），而无需在编译时知道其具体类型 33。</li>
<li><code>any_cast&lt;T&gt;(any_obj)</code> 的工作原理是，在运行时比较模板参数 <code>T</code> 的 <code>typeid</code> 与 <code>any_obj</code> 内部存储的 <code>type_info</code>。如果两者匹配，就安全地将内部存储转换为 T 类型；如果不匹配，则抛出 <code>std::bad_any_cast</code> 异常。</li>
<li>与 <code>std::function</code> 类似，<code>std::any</code> 的实现也被标准鼓励使用 [[SBO]]，以避免为小且易于移动的类型进行堆分配。</li>
</ul>
<p><strong>标准引用</strong>：<code>std::any</code> 的规范在C++标准中有详细定义，例如在C++20工作草案N4861的章节 <code>[any.synop]</code> 中。</p>
<h3 id="43-对比分析stdany-vs-stdvariant">4.3 对比分析：std::any vs. std::variant</h3>
<p>选择 <code>std::any</code> 还是 <code>std::variant</code> 是C++程序员在处理异质数据时面临的一个基本架构决策。这个选择本质上是在一个“开放”类型集合和一个“封闭”类型集合之间做决定，并对性能、安全性和API设计产生深远影响。</p>
<p>一个精辟的类比是：“any 是一个穿了马甲的 <code>void *</code>，而 variant 是一个穿了马甲的 union”。这个比喻抓住了两者本质的区别。</p>
<ul>
<li><strong><code>std::variant&lt;T1, T2,...&gt;</code></strong>：代表一个 <strong>封闭的、编译时确定的</strong> 类型集合。一个 variant 对象在任何时刻只能持有其模板参数列表中某一个类型的值。</li>
<li><strong><code>std::any</code></strong>：代表一个 <strong>开放的、运行时确定的</strong> 类型集合。一个 any 对象可以持有任何满足 CopyConstructible 条件的类型的值。</li>
</ul>
<p>下表详细对比了这两者的关键差异 35。</p>
<p><strong>表2：std::any 与 std::variant 详细对比</strong></p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性/指标</th>
          <th style="text-align: left"><code>std::any</code></th>
          <th style="text-align: left"><code>std::variant&lt;Types...&gt;</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>类型集合</strong></td>
          <td style="text-align: left"><strong>开放集</strong>：可存储任何（CopyConstructible）类型。</td>
          <td style="text-align: left"><strong>封闭集</strong>：只能存储在模板参数列表中预定义的类型。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>内存分配</strong></td>
          <td style="text-align: left"><strong>可能堆分配</strong>：对于大对象或不满足SBO条件的类型，会在堆上分配内存。</td>
          <td style="text-align: left"><strong>仅栈分配</strong>：对象直接存储在 variant 内部。其大小为所有备选类型中最大的那个，外加一个小的类型判别符。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>值访问</strong></td>
          <td style="text-align: left"><strong>运行时检查</strong>：通过 <code>std::any_cast&lt;T&gt;</code> 访问，若类型不匹配则在运行时抛出 <code>std::bad_any_cast</code>。</td>
          <td style="text-align: left"><strong>编译时安全</strong>：通过 <code>std::visit</code> 配合访问者模式，可保证在编译期处理所有备选类型，无运行时意外。<code>std::get</code> 访问若类型不匹配也会抛出异常。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>性能</strong></td>
          <td style="text-align: left"><strong>较慢</strong>：潜在的堆分配开销、类型识别（typeid 比较）和虚分派开销。</td>
          <td style="text-align: left"><strong>更快</strong>：无堆分配，类型判别通常是 O(1) 的索引检查。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>错误处理</strong></td>
          <td style="text-align: left">运行时抛出 <code>std::bad_any_cast</code> 异常。</td>
          <td style="text-align: left"><code>std::get</code> 访问时抛出 <code>std::bad_variant_access</code>；<code>std::visit</code> 可在编译期保证穷尽所有情况。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>主要用例</strong></td>
          <td style="text-align: left"><strong>通用框架和库</strong>：当无法预知用户将存储何种类型时，如属性映射、事件系统、脚本语言绑定等。</td>
          <td style="text-align: left"><strong>应用级逻辑</strong>：当类型集合有限且已知时，如状态机、消息处理（代数数据类型）、错误处理（<code>std::variant&lt;Result, Error&gt;</code>）等。</td>
      </tr>
  </tbody>
</table>
<p>总结而言，当处理一个固定的、已知的类型集合时，<code>std::variant</code> 因其类型安全、高性能和无堆分配的特性而成为首选。而当需要真正的通用性，处理完全未知的类型时，<code>std::any</code> 提供了必要的灵活性，但需要接受其潜在的性能开销。</p>
<h2 id="第五部分类型擦除的架构级应用">第五部分：类型擦除的架构级应用</h2>
<p>超越具体的实现技巧，类型擦除是一种强大的架构工具，能够构建出松耦合、可扩展且稳定的系统。本部分将探讨其在两个关键领域的架构级应用：稳定的ABI和插件系统。</p>
<h3 id="51-构建稳定的应用二进制接口-abi">5.1 构建稳定的应用二进制接口 (ABI)</h3>
<p><strong>C++的ABI问题</strong>：C++标准并未规定一个统一的应用二进制接口（Application Binary Interface, ABI）。这意味着由不同编译器、不同版本的编译器，甚至同一编译器使用不同编译选项编译出的二进制文件（如库和可执行文件）之间，往往不具备二进制兼容性。类的大小、布局、成员排列、虚函数表结构、名字修饰（name mangling）等细节都可能不同，任何微小的改变都可能破坏ABI 40。</p>
<p><strong>PIMPL惯用法作为解决方案</strong>：</p>
<ul>
<li>PIMPL（Pointer to Implementation，指向实现的指针）是C++中用于创建稳定ABI的主要技术 43。</li>
<li>其机制是将一个类的所有私有成员变量和私有成员函数都移到一个独立的、前向声明的实现类（Impl）中。公开的接口类只包含一个指向这个 Impl 类的指针（通常是 std::unique_ptr）。Impl 类的完整定义仅存在于 .cpp 实现文件中。</li>
<li>PIMPL之所以能提供稳定的ABI，是因为公开接口类的大小和布局是固定的——它只包含一个指针。只要公开的API不变，无论其内部实现（Impl类）如何修改（例如增删私有成员），都不会影响到公开接口类的二进制布局。因此，客户端代码只需重新链接，而无需重新编译，就能使用新版本的库 43。</li>
</ul>
<p>PIMPL作为一种特殊的类型擦除：<br>
PIMPL的核心是隐藏实现细节，而类型擦除的核心是隐藏类型本身。这两者之间存在深刻的联系。当我们实现一个类型擦除的句柄（如第二部分的 Drawable）时，其内部持有的 std::unique_ptr&lt;Concept&gt; 成员实际上就是一个PIMPL指针。它指向的“实现”是一个多态的 Concept/Model 层次结构。<br>
这种联系揭示了一个重要的区别：</p>
<ul>
<li><strong>标准PIMPL</strong>：隐藏的是 <strong>单个具体类型</strong> 的实现细节。</li>
<li><strong>用于类型擦除的PIMPL</strong>：隐藏的是 <strong>一整族不相关的类型</strong>，将它们统一到一个多态接口之后。</li>
</ul>
<p>因此，PIMPL是实现类型擦除的底层机制。当PIMPL指向的实现是多态的时，它就构成了类型擦除模式的核心。</p>
<h3 id="52-设计灵活的插件系统">5.2 设计灵活的插件系统</h3>
<p><strong>架构目标</strong>：一个宿主应用程序（Host Application）需要在运行时加载并与插件（通常是动态链接库，DLLs/SOs）交互，而无需重新编译宿主程序。插件为某个特定功能（如图像编解码器、游戏实体、渲染后端等）提供具体实现。</p>
<p><strong>挑战</strong>：如何在宿主和插件之间定义一个稳定的接口？如果使用传统的继承模型，宿主和插件都必须依赖于同一个基类的头文件定义。这会造成“脆弱基类问题”（brittle base class problem）：一旦基类定义发生任何改变（即使只是增加一个私有成员），所有插件的ABI都会被破坏，导致兼容性灾难。此外，跨模块的C++名字修饰问题也增加了复杂性 45。</p>
<p>类型擦除作为解决方案：<br>
类型擦除为设计健壮的插件系统提供了完美的解决方案。</p>
<ol>
<li><strong>宿主定义接口</strong>：宿主程序定义一个类型擦除的句柄类（例如，ImageCodecHandle）及其支持的操作（如 encode, decode）。这个句柄类就是提供给插件的、稳定的、公开的接口。</li>
<li><strong>插件提供实现</strong>：每个插件（在其自己的DLL中）实现一个具体的编解码器（如 PNGCodec, JPEGCodec）。这些具体类型 <strong>不需要</strong> 继承自宿主头文件中的任何基类。它们只需要提供 ImageCodecHandle 所需的同名方法即可。</li>
<li><strong>C风格工厂函数</strong>：插件导出一个C风格的、无名字修饰问题的工厂函数（例如，extern &ldquo;C&rdquo; ImageCodecHandle* create_codec();）。这个函数在其内部创建插件自己的具体编解码器对象（如 PNGCodec），并用它构造一个 ImageCodecHandle，然后返回这个句柄的指针。</li>
<li><strong>运行时交互</strong>：
<ul>
<li>宿主使用操作系统API（如 dlopen/LoadLibrary）加载插件DLL。</li>
<li>宿主使用 dlsym/GetProcAddress 查找并获取工厂函数的地址。</li>
<li>宿主调用工厂函数，获得一个功能完备、但类型已被擦除的 ImageCodecHandle 实例。</li>
<li>之后，宿主的所有操作都通过这个句柄进行，完全与插件的具体实现类型解耦 49。</li>
</ul>
</li>
</ol>
<p>这种架构彻底避免了脆弱基类问题和名字修饰问题，实现了宿主与插件之间真正意义上的二进制级别的解耦和长期稳定性。</p>
<h2 id="第六部分结论与未来展望">第六部分：结论与未来展望</h2>
<h3 id="61-关键原则与权衡总结">6.1 关键原则与权衡总结</h3>
<p>C++类型擦除技术是一项强大而精妙的设计模式，它成功地在静态多态和动态多态之间架起了一座桥梁。其核心价值在于实现了 <strong>非侵入式、类型安全、具有值语义的运行时多态</strong>。这使得程序员能够编写出高度解耦、灵活且可维护的代码，尤其是在处理异构对象集合、设计插件架构和维持稳定的ABI时，其优势尤为突出。</p>
<p>然而，这种灵活性和解耦能力并非没有代价。类型擦除引入了额外的间接层（无论是通过虚函数表还是函数指针），这不可避免地带来了一定的运行时性能开销。幸运的是，通过诸如小缓冲区优化（SBO）等高级技术，可以在许多常见场景下有效地缓解这些开销。最终，是否采用类型擦除，以及采用何种实现方式，是一个需要在实现复杂度、性能、内存使用和设计灵活性之间进行审慎权衡的架构决策。</p>
<h3 id="62-c中类型擦除的未来">6.2 C++中类型擦除的未来</h3>
<p>C++语言本身也在不断演进，未来可能会为类型擦除提供更直接的语言级支持，从而减少当前手动实现所需的样板代码。</p>
<ul>
<li><strong>语言级运行时多态</strong>：一些提案正在探索将类型擦除作为一种语言特性。这可能涉及引入新的语法，允许程序员更直接地定义一个运行时多态接口，并让编译器自动生成底层的Concept-Model结构。这种方式类似于Rust的 dyn Trait 或Swift的 any Protocol，它们通过“胖指针”（fat pointers，一个数据指针加一个vtable指针）在需要时才构建多态对象，从而避免了传统C++虚函数对对象布局的侵入性影响 51。</li>
<li><strong>反射（Reflection）</strong>：如果C++在未来的标准中引入了全面的编译时反射能力，那么类型擦除的实现将得到极大的简化。通过反射，可以自动地检查一个类型是否满足某个概念（即是否拥有所需的方法），并自动生成Model类中所有转发函数。这将彻底消除当前实现中最繁琐、最容易出错的样板代码部分，使得类型擦除的应用更加便捷和广泛。</li>
</ul>
<p>随着C++的不断发展，我们可以期待类型擦除这一强大的设计模式将变得更加易于使用，并更深入地融入到C++程序员的日常工具箱中，成为构建下一代高性能、高灵活性软件系统的关键技术。</p>
<h2 id="参考文献">参考文献</h2>
<h3 id="c标准文档">C++标准文档</h3>
<ul>
<li>ISO/IEC 14882:2011, <em>Programming Language C++</em>. (引入 std::function)</li>
<li>ISO/IEC 14882:2017, <em>Programming Language C++</em>. (引入 std::any 和 std::variant)</li>
<li>ISO/IEC 14882:2020, <em>Programming Language C++</em>. (工作草案 N4861 提供了对标准库组件实现的详细规范)</li>
</ul>
<h3 id="关键技术演讲与论文">关键技术演讲与论文</h3>
<ul>
<li>Parent, S. (2017). <em>Better Code: Runtime Polymorphism</em>. 7</li>
<li>Iglberger, K. (2021). <em>Breaking Dependencies: Type Erasure - A Design Analysis</em>. CppCon. 7</li>
<li>Iglberger, K. (2022). <em>Type Erasure - The Implementation Details</em>. CppCon. 6</li>
</ul>
<h3 id="其他相关文章与库文档">其他相关文章与库文档</h3>
<ul>
<li>Grimm, R. (2022). <em>Type Erasure</em>. Modernes C++. 1</li>
<li>Krzemieński, A. (2013). <em>Type erasure — Part I</em>. Andrzej&rsquo;s C++ blog. 2</li>
<li>Reddy, S. (2021). <em>C++ Type Erasure on the Stack</em>. Radiant Software. 19</li>
<li>O&rsquo;Dwyer, A. (2018). <em>Mastering the C++17 STL</em>. O&rsquo;Reilly Media. 52</li>
<li>cppreference.com. <em>Pointer to implementation</em>. 43</li>
</ul>
<h3 id="works-cited">Works cited</h3>
<ol>
<li>Type Erasure – MC++ BLOG - Modernes C++, accessed June 23, 2025, <a href="https://www.modernescpp.com/index.php/type-erasure/">https://www.modernescpp.com/index.php/type-erasure/</a></li>
<li>Type erasure — Part I | Andrzej&rsquo;s C++ blog - WordPress.com, accessed June 23, 2025, <a href="https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/">https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/</a></li>
<li>C++ &lsquo;Type Erasure&rsquo; Explained - Dave Kilian&rsquo;s Blog, accessed June 23, 2025, <a href="https://davekilian.com/cpp-type-erasure.html">https://davekilian.com/cpp-type-erasure.html</a></li>
<li>C++ Core Guidelines: Type Erasure : r/cpp - Reddit, accessed June 23, 2025, <a href="https://www.reddit.com/r/cpp/comments/9emvix/c_core_guidelines_type_erasure/">https://www.reddit.com/r/cpp/comments/9emvix/c_core_guidelines_type_erasure/</a></li>
<li>C++ type erasure - C++ Forum - CPlusPlus.com, accessed June 23, 2025, <a href="https://cplusplus.com/forum/articles/18756/">https://cplusplus.com/forum/articles/18756/</a></li>
<li>Type Erasure - The Implementation Details - CppCon 2022 Schedule, accessed June 23, 2025, <a href="https://cppcon.digital-medium.co.uk/wp-content/uploads/2022/09/Type-Erasure-The-Implementation-Details-Klaus-Iglberger-CppCon-2022.pdf">https://cppcon.digital-medium.co.uk/wp-content/uploads/2022/09/Type-Erasure-The-Implementation-Details-Klaus-Iglberger-CppCon-2022.pdf</a></li>
<li>yaozhenx/type-erasure: Implementation of Klaus Iglberger&rsquo;s &hellip; - GitHub, accessed June 23, 2025, <a href="https://github.com/yaozhenx/type-erasure">https://github.com/yaozhenx/type-erasure</a></li>
<li>Better polymorphic ducks - Mathieu Ropert, accessed June 23, 2025, <a href="https://mropert.github.io/2017/12/17/better_polymorphic_ducks/">https://mropert.github.io/2017/12/17/better_polymorphic_ducks/</a></li>
<li>std::any - cppreference.com - C++ Reference, accessed June 23, 2025, <a href="http://en.cppreference.com/w/cpp/utility/any.html">http://en.cppreference.com/w/cpp/utility/any.html</a></li>
<li>Breaking Dependencies: Type Erasure - A Design Analysis - Klaus Iglberger - CppCon 2021, accessed June 23, 2025, <a href="https://www.youtube.com/watch?v=4eeESJQk-mw">https://www.youtube.com/watch?v=4eeESJQk-mw</a></li>
<li>More C++ Idioms/Type Erasure - Wikibooks, open books for an open world, accessed June 23, 2025, <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure</a></li>
<li>How to use type erasure pattern to decouple polymorphic classes in C++?, accessed June 23, 2025, <a href="https://iamsorush.com/posts/cpp-type-erasure/">https://iamsorush.com/posts/cpp-type-erasure/</a></li>
<li>[C++] Use Type Erasure To Get Dynamic Polymorphic Behavior - Coding With Thomas, accessed June 23, 2025, <a href="https://www.codingwiththomas.com/blog/use-type-erasure-to-get-dynamic-polymorphic-behavior">https://www.codingwiththomas.com/blog/use-type-erasure-to-get-dynamic-polymorphic-behavior</a></li>
<li>c++ type erasure - C++ Forum - CPlusPlus.com, accessed June 23, 2025, <a href="https://cplusplus.com/forum/beginner/238304/">https://cplusplus.com/forum/beginner/238304/</a></li>
<li>c++ - Type erasure: Retrieving value - type check at compile time - Stack Overflow, accessed June 23, 2025, <a href="https://stackoverflow.com/questions/46041683/type-erasure-retrieving-value-type-check-at-compile-time">https://stackoverflow.com/questions/46041683/type-erasure-retrieving-value-type-check-at-compile-time</a></li>
<li>C+ Type erasure - GitHub Gist, accessed June 23, 2025, <a href="https://gist.github.com/vladiant/3ad3ace6e010378213b127bca25b879d">https://gist.github.com/vladiant/3ad3ace6e010378213b127bca25b879d</a></li>
<li>c++ - Templates and type erasure - Why does this program compile? - Stack Overflow, accessed June 23, 2025, <a href="https://stackoverflow.com/questions/73584172/templates-and-type-erasure-why-does-this-program-compile">https://stackoverflow.com/questions/73584172/templates-and-type-erasure-why-does-this-program-compile</a></li>
<li>Experimenting with Small Buffer Optimization for C++ Lambdas &hellip;, accessed June 23, 2025, <a href="https://hackernoon.com/experimenting-with-small-buffer-optimization-for-c-lambdas-d5b703fb47e4">https://hackernoon.com/experimenting-with-small-buffer-optimization-for-c-lambdas-d5b703fb47e4</a></li>
<li>C++ Type Erasure on the Stack - Part I, accessed June 23, 2025, <a href="https://radiantsoftware.hashnode.dev/c-type-erasure-part-i">https://radiantsoftware.hashnode.dev/c-type-erasure-part-i</a></li>
<li>Aliasing for small buffer optimization with std::aligned_union and std - Stack Overflow, accessed June 23, 2025, <a href="https://stackoverflow.com/questions/38070348/aliasing-for-small-buffer-optimization-with-stdaligned-union-and-stdaligned">https://stackoverflow.com/questions/38070348/aliasing-for-small-buffer-optimization-with-stdaligned-union-and-stdaligned</a></li>
<li>Generic owning type erasure - Fekir&rsquo;s Blog, accessed June 23, 2025, <a href="https://fekir.info/post/generic-owning-type-erasure/">https://fekir.info/post/generic-owning-type-erasure/</a></li>
<li>C++ Type Erasure Demystified - Fedor G Pikus - C++Now 2024 - YouTube, accessed June 23, 2025, <a href="https://www.youtube.com/watch?v=p-qaf6OS_f4">https://www.youtube.com/watch?v=p-qaf6OS_f4</a></li>
<li>C++ Type Erasure - The Implementation Details - Klaus Iglberger CppCon 2022 - YouTube, accessed June 23, 2025, <a href="https://www.youtube.com/watch?v=qn6OqefuH08">https://www.youtube.com/watch?v=qn6OqefuH08</a></li>
<li>std::function - cppreference.com, accessed June 23, 2025, <a href="https://en.cppreference.com/w/cpp/utility/functional/function.html">https://en.cppreference.com/w/cpp/utility/functional/function.html</a></li>
<li>std::function implementation · GitHub, accessed June 23, 2025, <a href="https://gist.github.com/Junch/3ac1f1d99c8f88f7d2333062d1ebcb2a">https://gist.github.com/Junch/3ac1f1d99c8f88f7d2333062d1ebcb2a</a></li>
<li>How is std::function implemented? - c++ - Stack Overflow, accessed June 23, 2025, <a href="https://stackoverflow.com/questions/18453145/how-is-stdfunction-implemented">https://stackoverflow.com/questions/18453145/how-is-stdfunction-implemented</a></li>
<li>Experimenting with Small Buffer Optimization for C++ Lambdas - Buckaroo, accessed June 23, 2025, <a href="https://buckaroo.pm/blog/experimenting-with-smallbuffer-optimization">https://buckaroo.pm/blog/experimenting-with-smallbuffer-optimization</a></li>
<li>Type erasure — Part II | Andrzej&rsquo;s C++ blog, accessed June 23, 2025, <a href="https://akrzemi1.wordpress.com/2013/12/06/type-erasure-part-ii/">https://akrzemi1.wordpress.com/2013/12/06/type-erasure-part-ii/</a></li>
<li>[func.wrap.func.con], accessed June 23, 2025, <a href="https://timsong-cpp.github.io/cppwp/n4861/func.wrap.func.con">https://timsong-cpp.github.io/cppwp/n4861/func.wrap.func.con</a></li>
<li>Draft C++ Standard: Contents, accessed June 23, 2025, <a href="https://timsong-cpp.github.io/cppwp/n4861/">https://timsong-cpp.github.io/cppwp/n4861/</a></li>
<li>std::any: How, when, and why - C++ Team Blog - Microsoft Developer Blogs, accessed June 23, 2025, <a href="https://devblogs.microsoft.com/cppblog/stdany-how-when-and-why/">https://devblogs.microsoft.com/cppblog/stdany-how-when-and-why/</a></li>
<li>Everything You Need to Know About std::any from C++17 - C++ Stories, accessed June 23, 2025, <a href="https://www.cppstories.com/2018/06/any/">https://www.cppstories.com/2018/06/any/</a></li>
<li>kocienda/Any: Implementation and optimization of std - GitHub, accessed June 23, 2025, <a href="https://github.com/kocienda/Any">https://github.com/kocienda/Any</a></li>
<li>How std::any Works - Fluent C++, accessed June 23, 2025, <a href="https://www.fluentcpp.com/2021/02/05/how-stdany-works/">https://www.fluentcpp.com/2021/02/05/how-stdany-works/</a></li>
<li>C++ std::variant vs std::any - Stack Overflow, accessed June 23, 2025, <a href="https://stackoverflow.com/questions/56303939/c-stdvariant-vs-stdany">https://stackoverflow.com/questions/56303939/c-stdvariant-vs-stdany</a></li>
<li>The std::variant - C++ High Performance [Book] - O&rsquo;Reilly Media, accessed June 23, 2025, <a href="https://www.oreilly.com/library/view/c-high-performance/9781787120952/bb3be0c7-90ef-4eff-9b3f-10373dc84b48.xhtml">https://www.oreilly.com/library/view/c-high-performance/9781787120952/bb3be0c7-90ef-4eff-9b3f-10373dc84b48.xhtml</a></li>
<li>std::variant - Why not just any? – Yet Another Technical Blog, accessed June 23, 2025, <a href="http://www.mycpu.org/std-variant/">http://www.mycpu.org/std-variant/</a></li>
<li>How does std::any compare to std::variant? - Meeting C++, accessed June 23, 2025, <a href="https://meetingcpp.com/blog/items/How-does-std-any-compare-to-std-variant-.html">https://meetingcpp.com/blog/items/How-does-std-any-compare-to-std-variant-.html</a></li>
<li>Performance of std::any - C++ High Performance [Book] - O&rsquo;Reilly Media, accessed June 23, 2025, <a href="https://www.oreilly.com/library/view/c-high-performance/9781787120952/e24859e6-0730-4459-b6f3-cf02ddbc6a28.xhtml">https://www.oreilly.com/library/view/c-high-performance/9781787120952/e24859e6-0730-4459-b6f3-cf02ddbc6a28.xhtml</a></li>
<li>Define a Rust ABI · Issue #600 · rust-lang/rfcs - GitHub, accessed June 23, 2025, <a href="https://github.com/rust-lang/rfcs/issues/600">https://github.com/rust-lang/rfcs/issues/600</a></li>
<li>ABI Breaks: Not just about rebuilding : r/cpp - Reddit, accessed June 23, 2025, <a href="https://www.reddit.com/r/cpp/comments/fc2qqv/abi_breaks_not_just_about_rebuilding/">https://www.reddit.com/r/cpp/comments/fc2qqv/abi_breaks_not_just_about_rebuilding/</a></li>
<li>Please explain the C++ ABI - Stack Overflow, accessed June 23, 2025, <a href="https://stackoverflow.com/questions/67839008/please-explain-the-c-abi">https://stackoverflow.com/questions/67839008/please-explain-the-c-abi</a></li>
<li>PImpl - cppreference.com, accessed June 23, 2025, <a href="https://en.cppreference.com/w/cpp/language/pimpl.html">https://en.cppreference.com/w/cpp/language/pimpl.html</a></li>
<li>C++ Core Guidelines: Interfaces II – MC++ BLOG - Modernes C++, accessed June 23, 2025, <a href="https://www.modernescpp.com/index.php/c-core-guidelines-interfaces-ii/">https://www.modernescpp.com/index.php/c-core-guidelines-interfaces-ii/</a></li>
<li>c++ type erasure / type encapsulation? discover type - Stack Overflow, accessed June 23, 2025, <a href="https://stackoverflow.com/questions/9486622/c-type-erasure-type-encapsulation-discover-type">https://stackoverflow.com/questions/9486622/c-type-erasure-type-encapsulation-discover-type</a></li>
<li>Designing a plugin framework for an application with a plugin architecture : r/cpp - Reddit, accessed June 23, 2025, <a href="https://www.reddit.com/r/cpp/comments/6gbv6c/designing_a_plugin_framework_for_an_application/">https://www.reddit.com/r/cpp/comments/6gbv6c/designing_a_plugin_framework_for_an_application/</a></li>
<li>Implementing A Plugin System in C or C++ [closed] - Stack Overflow, accessed June 23, 2025, <a href="https://stackoverflow.com/questions/708527/implementing-a-plugin-system-in-c-or-c">https://stackoverflow.com/questions/708527/implementing-a-plugin-system-in-c-or-c</a></li>
<li>Making a Plugin System - C++ Articles - CPlusPlus.com, accessed June 23, 2025, <a href="https://cplusplus.com/articles/48TbqMoL/">https://cplusplus.com/articles/48TbqMoL/</a></li>
<li>Type Erasure in C++: The Magic of Flexibility - HeyCoach | Blogs, accessed June 23, 2025, <a href="https://blog.heycoach.in/type-erasure-in-c/">https://blog.heycoach.in/type-erasure-in-c/</a></li>
<li>static_vector Needs Type-Erasure - Volt Software, accessed June 23, 2025, <a href="https://volt-software.nl/posts/static-vector-needs-type-erasure/">https://volt-software.nl/posts/static-vector-needs-type-erasure/</a></li>
<li>Potential C++ extension for type erasure as a language feature : r/cpp - Reddit, accessed June 23, 2025, <a href="https://www.reddit.com/r/cpp/comments/yriwxr/potential_c_extension_for_type_erasure_as_a/">https://www.reddit.com/r/cpp/comments/yriwxr/potential_c_extension_for_type_erasure_as_a/</a></li>
<li>std::any versus polymorphic class types - Mastering the C++17 STL [Book] - O&rsquo;Reilly Media, accessed June 23, 2025, <a href="https://www.oreilly.com/library/view/mastering-the-c17/9781787126824/7bce9721-6ba2-49e0-99e0-5f2c6ca2f989.xhtml">https://www.oreilly.com/library/view/mastering-the-c17/9781787126824/7bce9721-6ba2-49e0-99e0-5f2c6ca2f989.xhtml</a></li>
</ol>
</section></main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Lu Yang</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>2091 words</span>
    <span>45 - 58 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#第一部分类型擦除的起源连接静态与动态多态">第一部分：类型擦除的起源：连接静态与动态多态</a>
      <ul>
        <li><a href="#11-c中的多态困境">1.1 C++中的多态困境</a></li>
        <li><a href="#12-在现代c语境下定义类型擦除">1.2 在现代C++语境下定义类型擦除</a></li>
      </ul>
    </li>
    <li><a href="#第二部分经典实现concept-model模式">第二部分：经典实现：Concept-Model模式</a>
      <ul>
        <li><a href="#21-解构体系架构设计模式的组合">2.1 解构体系架构：设计模式的组合</a></li>
        <li><a href="#22-一个完整的可编译示例drawable-对象">2.2 一个完整的可编译示例：Drawable 对象</a></li>
        <li><a href="#23-深入底层追踪擦除机制">2.3 深入底层：追踪擦除机制</a></li>
      </ul>
    </li>
    <li><a href="#第三部分高级实现与优化策略">第三部分：高级实现与优化策略</a>
      <ul>
        <li><a href="#31-小缓冲区优化-small-buffer-optimization---sbo">3.1 小缓冲区优化 (Small Buffer Optimization - SBO)</a></li>
        <li><a href="#32-通过函数指针进行手动虚分派">3.2 通过函数指针进行手动虚分派</a></li>
        <li><a href="#33-基于策略的设计以实现最大灵活性">3.3 基于策略的设计以实现最大灵活性</a></li>
      </ul>
    </li>
    <li><a href="#第四部分c标准库中的类型擦除">第四部分：C++标准库中的类型擦除</a>
      <ul>
        <li><a href="#41-案例研究stdfunction---多态可调用对象">4.1 案例研究：<code>std::function</code> - 多态可调用对象</a></li>
        <li><a href="#42-案例研究stdany---类型安全的-void-">4.2 案例研究：<code>std::any</code> - 类型安全的 <code>void *</code></a></li>
        <li><a href="#43-对比分析stdany-vs-stdvariant">4.3 对比分析：std::any vs. std::variant</a></li>
      </ul>
    </li>
    <li><a href="#第五部分类型擦除的架构级应用">第五部分：类型擦除的架构级应用</a>
      <ul>
        <li><a href="#51-构建稳定的应用二进制接口-abi">5.1 构建稳定的应用二进制接口 (ABI)</a></li>
        <li><a href="#52-设计灵活的插件系统">5.2 设计灵活的插件系统</a></li>
      </ul>
    </li>
    <li><a href="#第六部分结论与未来展望">第六部分：结论与未来展望</a>
      <ul>
        <li><a href="#61-关键原则与权衡总结">6.1 关键原则与权衡总结</a></li>
        <li><a href="#62-c中类型擦除的未来">6.2 C++中类型擦除的未来</a></li>
      </ul>
    </li>
    <li><a href="#参考文献">参考文献</a>
      <ul>
        <li><a href="#c标准文档">C++标准文档</a></li>
        <li><a href="#关键技术演讲与论文">关键技术演讲与论文</a></li>
        <li><a href="#其他相关文章与库文档">其他相关文章与库文档</a></li>
        <li><a href="#works-cited">Works cited</a></li>
      </ul>
    </li>
  </ul>
</nav><h3>Related</h3>
    <ul><li><a href="/posts/-c&#43;&#43;-%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-static-%E4%B8%8E-const-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%E8%A7%A3%E6%9E%90/">📌 C&#43;&#43;类成员函数 static 与 const 的声明与定义规则解析</a></li><li><a href="/posts/%E5%B0%8F%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96small-object-optimization%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90c&#43;&#43;%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%A9%E5%99%A8/">📌小对象优化（Small Object Optimization）深度解析：C&#43;&#43;容器的性能利器</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90-delete-%E4%B8%8E%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/">📌深入分析 =delete 与私有化构造和析构函数的本质区别</a></li><li><a href="/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-c&#43;&#43;-%E4%B8%AD%E7%9A%84-std-ref-%E5%92%8C-cref-%E7%9A%84%E5%BC%95%E7%94%A8%E5%B0%81%E8%A3%85%E6%9C%BA%E5%88%B6/">📌深入理解 C&#43;&#43; 中的 std ref 和 cref 的引用封装机制</a></li><li><a href="/posts/-c&#43;&#43;%E9%9D%9E%E4%BE%B5%E5%85%A5%E6%80%A7%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/">📘 C&#43;&#43;非侵入性编程范式</a></li></ul></aside></div>
  </div>
</body>
</html>
